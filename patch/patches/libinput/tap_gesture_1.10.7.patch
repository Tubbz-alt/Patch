Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 libinput (1.10.7-1deepin) unstable; urgency=medium
 .
   * add tap_gesture_1.8.0.patch
Author: Packages <packages@deepin.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2018-07-11

--- libinput-1.10.7.orig/src/evdev-mt-touchpad-gestures.c
+++ libinput-1.10.7/src/evdev-mt-touchpad-gestures.c
@@ -31,6 +31,7 @@
 
 #define DEFAULT_GESTURE_SWITCH_TIMEOUT ms2us(100)
 #define DEFAULT_GESTURE_2FG_SCROLL_TIMEOUT ms2us(150)
+#define DEFAULT_GESTURE_TAP_TIMEOUT ms2us(200)
 
 static inline const char*
 gesture_state_to_str(enum tp_gesture_state state)
@@ -41,6 +42,7 @@ gesture_state_to_str(enum tp_gesture_sta
 	CASE_RETURN_STRING(GESTURE_STATE_SCROLL);
 	CASE_RETURN_STRING(GESTURE_STATE_PINCH);
 	CASE_RETURN_STRING(GESTURE_STATE_SWIPE);
+	CASE_RETURN_STRING(GESTURE_STATE_TAP);
 	}
 	return NULL;
 }
@@ -121,6 +123,12 @@ tp_gesture_start(struct tp_dispatch *tp,
 				     tp->gesture.finger_count,
 				     &zero, &zero);
 		break;
+  case GESTURE_STATE_TAP:
+    gesture_notify_tap(&tp->device->base, time,
+             LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+             tp->gesture.finger_count,
+             &zero, &zero);
+    break;
 	}
 
 	tp->gesture.started = true;
@@ -358,8 +366,17 @@ tp_gesture_handle_state_unknown(struct t
 	/* Else wait for both fingers to have moved */
 	dir1 = tp_gesture_get_direction(tp, first, tp->gesture.finger_count);
 	dir2 = tp_gesture_get_direction(tp, second, tp->gesture.finger_count);
-	if (dir1 == UNDEFINED_DIRECTION || dir2 == UNDEFINED_DIRECTION)
-		return GESTURE_STATE_UNKNOWN;
+	if (dir1 == UNDEFINED_DIRECTION || dir2 == UNDEFINED_DIRECTION) {
+      struct normalized_coords delta, unaccel;
+      unaccel = tp_get_average_touches_delta(tp);
+      delta = tp_filter_motion(tp, &unaccel, time);
+      if (normalized_is_zero(delta) && normalized_is_zero(unaccel) &&
+          time < (tp->gesture.initial_time + DEFAULT_GESTURE_TAP_TIMEOUT)) {
+          // TODO: check tap whether enabled
+          return GESTURE_STATE_TAP;
+      }
+      return GESTURE_STATE_UNKNOWN;
+  }
 
 	/* If both touches are moving in the same direction assume
 	 * scroll or swipe */
@@ -465,6 +482,53 @@ tp_gesture_handle_state_pinch(struct tp_
 	return GESTURE_STATE_PINCH;
 }
 
+static enum tp_gesture_state
+tp_gesture_handle_state_tap(struct tp_dispatch *tp, uint64_t time)
+{
+	struct normalized_coords delta, unaccel;
+	struct tp_touch *first = tp->gesture.touches[0],
+			*second = tp->gesture.touches[1];
+	int dir1, dir2;
+
+	if (time > (tp->gesture.initial_time + DEFAULT_GESTURE_TAP_TIMEOUT)) {
+		goto out;
+	}
+
+	unaccel = tp_get_average_touches_delta(tp);
+	delta = tp_filter_motion(tp, &unaccel, time);
+	if (normalized_is_zero(delta) && normalized_is_zero(unaccel)) {
+		tp_gesture_start(tp, time);
+		gesture_notify_tap(&tp->device->base, time,
+				LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+        tp->gesture.finger_count,
+        &delta, &unaccel);
+		return GESTURE_STATE_TAP;
+	}
+
+out:
+	// TODO: optimize structure
+
+	/* Else wait for both fingers to have moved */
+	dir1 = tp_gesture_get_direction(tp, first, tp->gesture.finger_count);
+	dir2 = tp_gesture_get_direction(tp, second, tp->gesture.finger_count);
+
+	/* If both touches are moving in the same direction assume
+	 * scroll or swipe */
+	if (tp_gesture_same_directions(dir1, dir2)) {
+		if (tp->gesture.finger_count == 2) {
+			tp_gesture_set_scroll_buildup(tp);
+			return GESTURE_STATE_SCROLL;
+		} else if (tp->gesture.enabled) {
+			return GESTURE_STATE_SWIPE;
+		}
+	} else {
+		tp_gesture_init_pinch(tp);
+		return GESTURE_STATE_PINCH;
+	}
+
+	return GESTURE_STATE_UNKNOWN;
+}
+
 static void
 tp_gesture_post_gesture(struct tp_dispatch *tp, uint64_t time)
 {
@@ -490,6 +554,10 @@ tp_gesture_post_gesture(struct tp_dispat
 		tp->gesture.state =
 			tp_gesture_handle_state_pinch(tp, time);
 
+  if (tp->gesture.state == GESTURE_STATE_TAP)
+      tp->gesture.state =
+          tp_gesture_handle_state_tap(tp, time);
+
 	evdev_log_debug(tp->device,
 			"gesture state: %s → %s\n",
 			gesture_state_to_str(oldstate),
@@ -569,6 +637,12 @@ tp_gesture_end(struct tp_dispatch *tp, u
 					 tp->gesture.finger_count,
 					 cancelled);
 		break;
+  case GESTURE_STATE_TAP:
+      gesture_notify_tap_end(&tp->device->base,
+                             time,
+                             tp->gesture.finger_count,
+                             cancelled);
+      break;
 	}
 
 	tp->gesture.started = false;
--- /dev/null
+++ libinput-1.10.7/src/evdev-mt-touchpad-gestures.c.orig
@@ -0,0 +1,660 @@
+/*
+ * Copyright © 2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <math.h>
+#include <stdbool.h>
+#include <limits.h>
+
+#include "evdev-mt-touchpad.h"
+
+#define DEFAULT_GESTURE_SWITCH_TIMEOUT ms2us(100)
+#define DEFAULT_GESTURE_2FG_SCROLL_TIMEOUT ms2us(150)
+
+static inline const char*
+gesture_state_to_str(enum tp_gesture_state state)
+{
+	switch (state) {
+	CASE_RETURN_STRING(GESTURE_STATE_NONE);
+	CASE_RETURN_STRING(GESTURE_STATE_UNKNOWN);
+	CASE_RETURN_STRING(GESTURE_STATE_SCROLL);
+	CASE_RETURN_STRING(GESTURE_STATE_PINCH);
+	CASE_RETURN_STRING(GESTURE_STATE_SWIPE);
+	}
+	return NULL;
+}
+
+static struct device_float_coords
+tp_get_touches_delta(struct tp_dispatch *tp, bool average)
+{
+	struct tp_touch *t;
+	unsigned int i, nactive = 0;
+	struct device_float_coords delta = {0.0, 0.0};
+
+	for (i = 0; i < tp->num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active(tp, t))
+			continue;
+
+		nactive++;
+
+		if (t->dirty) {
+			struct device_coords d;
+
+			d = tp_get_delta(t);
+
+			delta.x += d.x;
+			delta.y += d.y;
+		}
+	}
+
+	if (!average || nactive == 0)
+		return delta;
+
+	delta.x /= nactive;
+	delta.y /= nactive;
+
+	return delta;
+}
+
+static inline struct device_float_coords
+tp_get_combined_touches_delta(struct tp_dispatch *tp)
+{
+	return tp_get_touches_delta(tp, false);
+}
+
+static inline struct device_float_coords
+tp_get_average_touches_delta(struct tp_dispatch *tp)
+{
+	return tp_get_touches_delta(tp, true);
+}
+
+static void
+tp_gesture_start(struct tp_dispatch *tp, uint64_t time)
+{
+	const struct normalized_coords zero = { 0.0, 0.0 };
+
+	if (tp->gesture.started)
+		return;
+
+	switch (tp->gesture.state) {
+	case GESTURE_STATE_NONE:
+	case GESTURE_STATE_UNKNOWN:
+		evdev_log_bug_libinput(tp->device,
+				       "%s in unknown gesture mode\n",
+				       __func__);
+		break;
+	case GESTURE_STATE_SCROLL:
+		/* NOP */
+		break;
+	case GESTURE_STATE_PINCH:
+		gesture_notify_pinch(&tp->device->base, time,
+				    LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+				    tp->gesture.finger_count,
+				    &zero, &zero, 1.0, 0.0);
+		break;
+	case GESTURE_STATE_SWIPE:
+		gesture_notify_swipe(&tp->device->base, time,
+				     LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+				     tp->gesture.finger_count,
+				     &zero, &zero);
+		break;
+	}
+
+	tp->gesture.started = true;
+}
+
+static void
+tp_gesture_post_pointer_motion(struct tp_dispatch *tp, uint64_t time)
+{
+	struct device_float_coords raw;
+	struct normalized_coords delta;
+
+	/* When a clickpad is clicked, combine motion of all active touches */
+	if (tp->buttons.is_clickpad && tp->buttons.state)
+		raw = tp_get_combined_touches_delta(tp);
+	else
+		raw = tp_get_average_touches_delta(tp);
+
+	delta = tp_filter_motion(tp, &raw, time);
+
+	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
+		struct device_float_coords unaccel;
+
+		unaccel = tp_scale_to_xaxis(tp, raw);
+		pointer_notify_motion(&tp->device->base,
+				      time,
+				      &delta,
+				      &unaccel);
+	}
+}
+
+static unsigned int
+tp_gesture_get_active_touches(const struct tp_dispatch *tp,
+			      struct tp_touch **touches,
+			      unsigned int count)
+{
+	unsigned int n = 0;
+	struct tp_touch *t;
+
+	memset(touches, 0, count * sizeof(struct tp_touch *));
+
+	tp_for_each_touch(tp, t) {
+		if (tp_touch_active(tp, t)) {
+			touches[n++] = t;
+			if (n == count)
+				return count;
+		}
+	}
+
+	/*
+	 * This can happen when the user does .e.g:
+	 * 1) Put down 1st finger in center (so active)
+	 * 2) Put down 2nd finger in a button area (so inactive)
+	 * 3) Put down 3th finger somewhere, gets reported as a fake finger,
+	 *    so gets same coordinates as 1st -> active
+	 *
+	 * We could avoid this by looking at all touches, be we really only
+	 * want to look at real touches.
+	 */
+	return n;
+}
+
+static uint32_t
+tp_gesture_get_direction(struct tp_dispatch *tp, struct tp_touch *touch,
+			 unsigned int nfingers)
+{
+	struct phys_coords mm;
+	struct device_float_coords delta;
+	double move_threshold = 1.0; /* mm */
+
+	move_threshold *= (nfingers - 1);
+
+	delta = device_delta(touch->point, touch->gesture.initial);
+	mm = tp_phys_delta(tp, delta);
+
+	if (length_in_mm(mm) < move_threshold)
+		return UNDEFINED_DIRECTION;
+
+	return phys_get_direction(mm);
+}
+
+static void
+tp_gesture_get_pinch_info(struct tp_dispatch *tp,
+			  double *distance,
+			  double *angle,
+			  struct device_float_coords *center)
+{
+	struct normalized_coords normalized;
+	struct device_float_coords delta;
+	struct tp_touch *first = tp->gesture.touches[0],
+			*second = tp->gesture.touches[1];
+
+	delta = device_delta(first->point, second->point);
+	normalized = tp_normalize_delta(tp, delta);
+	*distance = normalized_length(normalized);
+	*angle = atan2(normalized.y, normalized.x) * 180.0 / M_PI;
+
+	*center = device_average(first->point, second->point);
+}
+
+static void
+tp_gesture_set_scroll_buildup(struct tp_dispatch *tp)
+{
+	struct device_float_coords d0, d1;
+	struct device_float_coords average;
+	struct tp_touch *first = tp->gesture.touches[0],
+			*second = tp->gesture.touches[1];
+
+	d0 = device_delta(first->point, first->gesture.initial);
+	d1 = device_delta(second->point, second->gesture.initial);
+
+	average = device_float_average(d0, d1);
+	tp->device->scroll.buildup = tp_normalize_delta(tp, average);
+}
+
+static enum tp_gesture_state
+tp_gesture_handle_state_none(struct tp_dispatch *tp, uint64_t time)
+{
+	struct tp_touch *first, *second;
+	struct tp_touch *touches[4];
+	unsigned int ntouches;
+	unsigned int i;
+
+	ntouches = tp_gesture_get_active_touches(tp, touches, 4);
+	if (ntouches < 2)
+		return GESTURE_STATE_NONE;
+
+	if (!tp->gesture.enabled) {
+		if (ntouches == 2)
+			return GESTURE_STATE_SCROLL;
+		else
+			return GESTURE_STATE_NONE;
+	}
+
+	first = touches[0];
+	second = touches[1];
+
+	/* For 3+ finger gestures we cheat. A human hand's finger
+	 * arrangement means that for a 3 or 4 finger swipe gesture, the
+	 * fingers are roughly arranged in a horizontal line.
+	 * They will all move in the same direction, so we can simply look
+	 * at the left and right-most ones only. If we have fake touches, we
+	 * just take the left/right-most real touch position, since the fake
+	 * touch has the same location as one of those.
+	 *
+	 * For a 3 or 4 finger pinch gesture, 2 or 3 fingers are roughly in
+	 * a horizontal line, with the thumb below and left (right-handed
+	 * users) or right (left-handed users). Again, the row of non-thumb
+	 * fingers moves identically so we can look at the left and
+	 * right-most only and then treat it like a two-finger
+	 * gesture.
+	 */
+	if (ntouches > 2) {
+		second = touches[0];
+
+		for (i = 1; i < ntouches && i < tp->num_slots; i++) {
+			if (touches[i]->point.x < first->point.x)
+				first = touches[i];
+			else if (touches[i]->point.x > second->point.x)
+				second = touches[i];
+		}
+
+		if (first == second)
+			return GESTURE_STATE_NONE;
+
+	}
+
+	tp->gesture.initial_time = time;
+	first->gesture.initial = first->point;
+	second->gesture.initial = second->point;
+	tp->gesture.touches[0] = first;
+	tp->gesture.touches[1] = second;
+
+	return GESTURE_STATE_UNKNOWN;
+}
+
+static inline int
+tp_gesture_same_directions(int dir1, int dir2)
+{
+	/*
+	 * In some cases (semi-mt touchpads) we may seen one finger move
+	 * e.g. N/NE and the other W/NW so we not only check for overlapping
+	 * directions, but also for neighboring bits being set.
+	 * The ((dira & 0x80) && (dirb & 0x01)) checks are to check for bit 0
+	 * and 7 being set as they also represent neighboring directions.
+	 */
+	return ((dir1 | (dir1 >> 1)) & dir2) ||
+		((dir2 | (dir2 >> 1)) & dir1) ||
+		((dir1 & 0x80) && (dir2 & 0x01)) ||
+		((dir2 & 0x80) && (dir1 & 0x01));
+}
+
+static inline void
+tp_gesture_init_pinch(struct tp_dispatch *tp)
+{
+	tp_gesture_get_pinch_info(tp,
+				  &tp->gesture.initial_distance,
+				  &tp->gesture.angle,
+				  &tp->gesture.center);
+	tp->gesture.prev_scale = 1.0;
+}
+
+static enum tp_gesture_state
+tp_gesture_handle_state_unknown(struct tp_dispatch *tp, uint64_t time)
+{
+	struct tp_touch *first = tp->gesture.touches[0],
+			*second = tp->gesture.touches[1];
+	uint32_t dir1, dir2;
+	int yres = tp->device->abs.absinfo_y->resolution;
+	int vert_distance;
+
+	if (time > (tp->gesture.initial_time + DEFAULT_GESTURE_2FG_SCROLL_TIMEOUT)) {
+		/* for two-finger gestures, if the fingers stay unmoving for a
+		 * while, assume (slow) scroll */
+		if (tp->gesture.finger_count == 2) {
+			tp_gesture_set_scroll_buildup(tp);
+			return GESTURE_STATE_SCROLL;
+		/* more fingers than slots, don't bother with pinch, always
+		 * assume swipe */
+		} else if (tp->gesture.finger_count > tp->num_slots) {
+			return GESTURE_STATE_SWIPE;
+		}
+
+		/* for 3+ finger gestures, check if one finger is > 20mm
+		   below the others */
+		vert_distance = abs(first->point.y - second->point.y);
+		if (vert_distance > 20 * yres &&
+		    tp->gesture.enabled) {
+			tp_gesture_init_pinch(tp);
+			return GESTURE_STATE_PINCH;
+		} else {
+			return GESTURE_STATE_SWIPE;
+		}
+	}
+
+	/* Else wait for both fingers to have moved */
+	dir1 = tp_gesture_get_direction(tp, first, tp->gesture.finger_count);
+	dir2 = tp_gesture_get_direction(tp, second, tp->gesture.finger_count);
+	if (dir1 == UNDEFINED_DIRECTION || dir2 == UNDEFINED_DIRECTION)
+		return GESTURE_STATE_UNKNOWN;
+
+	/* If both touches are moving in the same direction assume
+	 * scroll or swipe */
+	if (tp->gesture.finger_count > tp->num_slots ||
+	    tp_gesture_same_directions(dir1, dir2)) {
+		if (tp->gesture.finger_count == 2) {
+			tp_gesture_set_scroll_buildup(tp);
+			return GESTURE_STATE_SCROLL;
+		} else if (tp->gesture.enabled) {
+			return GESTURE_STATE_SWIPE;
+		}
+	} else {
+		tp_gesture_init_pinch(tp);
+		return GESTURE_STATE_PINCH;
+	}
+
+	return GESTURE_STATE_UNKNOWN;
+}
+
+static enum tp_gesture_state
+tp_gesture_handle_state_scroll(struct tp_dispatch *tp, uint64_t time)
+{
+	struct device_float_coords raw;
+	struct normalized_coords delta;
+
+	if (tp->scroll.method != LIBINPUT_CONFIG_SCROLL_2FG)
+		return GESTURE_STATE_SCROLL;
+
+	raw = tp_get_average_touches_delta(tp);
+
+	/* scroll is not accelerated */
+	delta = tp_filter_motion_unaccelerated(tp, &raw, time);
+
+	if (normalized_is_zero(delta))
+		return GESTURE_STATE_SCROLL;
+
+	tp_gesture_start(tp, time);
+	evdev_post_scroll(tp->device,
+			  time,
+			  LIBINPUT_POINTER_AXIS_SOURCE_FINGER,
+			  &delta);
+
+	return GESTURE_STATE_SCROLL;
+}
+
+static enum tp_gesture_state
+tp_gesture_handle_state_swipe(struct tp_dispatch *tp, uint64_t time)
+{
+	struct device_float_coords raw;
+	struct normalized_coords delta, unaccel;
+
+	raw = tp_get_average_touches_delta(tp);
+	delta = tp_filter_motion(tp, &raw, time);
+
+	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
+		unaccel = tp_normalize_delta(tp, raw);
+		tp_gesture_start(tp, time);
+		gesture_notify_swipe(&tp->device->base, time,
+				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+				     tp->gesture.finger_count,
+				     &delta, &unaccel);
+	}
+
+	return GESTURE_STATE_SWIPE;
+}
+
+static enum tp_gesture_state
+tp_gesture_handle_state_pinch(struct tp_dispatch *tp, uint64_t time)
+{
+	double angle, angle_delta, distance, scale;
+	struct device_float_coords center, fdelta;
+	struct normalized_coords delta, unaccel;
+
+	tp_gesture_get_pinch_info(tp, &distance, &angle, &center);
+
+	scale = distance / tp->gesture.initial_distance;
+
+	angle_delta = angle - tp->gesture.angle;
+	tp->gesture.angle = angle;
+	if (angle_delta > 180.0)
+		angle_delta -= 360.0;
+	else if (angle_delta < -180.0)
+		angle_delta += 360.0;
+
+	fdelta = device_float_delta(center, tp->gesture.center);
+	tp->gesture.center = center;
+
+	delta = tp_filter_motion(tp, &fdelta, time);
+
+	if (normalized_is_zero(delta) && device_float_is_zero(fdelta) &&
+	    scale == tp->gesture.prev_scale && angle_delta == 0.0)
+		return GESTURE_STATE_PINCH;
+
+	unaccel = tp_normalize_delta(tp, fdelta);
+	tp_gesture_start(tp, time);
+	gesture_notify_pinch(&tp->device->base, time,
+			     LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			     tp->gesture.finger_count,
+			     &delta, &unaccel, scale, angle_delta);
+
+	tp->gesture.prev_scale = scale;
+
+	return GESTURE_STATE_PINCH;
+}
+
+static void
+tp_gesture_post_gesture(struct tp_dispatch *tp, uint64_t time)
+{
+	enum tp_gesture_state oldstate = tp->gesture.state;
+
+	if (tp->gesture.state == GESTURE_STATE_NONE)
+		tp->gesture.state =
+			tp_gesture_handle_state_none(tp, time);
+
+	if (tp->gesture.state == GESTURE_STATE_UNKNOWN)
+		tp->gesture.state =
+			tp_gesture_handle_state_unknown(tp, time);
+
+	if (tp->gesture.state == GESTURE_STATE_SCROLL)
+		tp->gesture.state =
+			tp_gesture_handle_state_scroll(tp, time);
+
+	if (tp->gesture.state == GESTURE_STATE_SWIPE)
+		tp->gesture.state =
+			tp_gesture_handle_state_swipe(tp, time);
+
+	if (tp->gesture.state == GESTURE_STATE_PINCH)
+		tp->gesture.state =
+			tp_gesture_handle_state_pinch(tp, time);
+
+	evdev_log_debug(tp->device,
+			"gesture state: %s → %s\n",
+			gesture_state_to_str(oldstate),
+			gesture_state_to_str(tp->gesture.state));
+}
+
+void
+tp_gesture_post_events(struct tp_dispatch *tp, uint64_t time)
+{
+	if (tp->gesture.finger_count == 0)
+		return;
+
+	/* When tap-and-dragging, or a clickpad is clicked force 1fg mode */
+	if (tp_tap_dragging(tp) || (tp->buttons.is_clickpad && tp->buttons.state)) {
+		tp_gesture_cancel(tp, time);
+		tp->gesture.finger_count = 1;
+		tp->gesture.finger_count_pending = 0;
+	}
+
+	/* Don't send events when we're unsure in which mode we are */
+	if (tp->gesture.finger_count_pending)
+		return;
+
+	switch (tp->gesture.finger_count) {
+	case 1:
+		if (tp->queued & TOUCHPAD_EVENT_MOTION)
+			tp_gesture_post_pointer_motion(tp, time);
+		break;
+	case 2:
+	case 3:
+	case 4:
+		tp_gesture_post_gesture(tp, time);
+		break;
+	}
+}
+
+void
+tp_gesture_stop_twofinger_scroll(struct tp_dispatch *tp, uint64_t time)
+{
+	if (tp->scroll.method != LIBINPUT_CONFIG_SCROLL_2FG)
+		return;
+
+	evdev_stop_scroll(tp->device,
+			  time,
+			  LIBINPUT_POINTER_AXIS_SOURCE_FINGER);
+}
+
+static void
+tp_gesture_end(struct tp_dispatch *tp, uint64_t time, bool cancelled)
+{
+	enum tp_gesture_state state = tp->gesture.state;
+
+	tp->gesture.state = GESTURE_STATE_NONE;
+
+	if (!tp->gesture.started)
+		return;
+
+	switch (state) {
+	case GESTURE_STATE_NONE:
+	case GESTURE_STATE_UNKNOWN:
+		evdev_log_bug_libinput(tp->device,
+				       "%s in unknown gesture mode\n",
+				       __func__);
+		break;
+	case GESTURE_STATE_SCROLL:
+		tp_gesture_stop_twofinger_scroll(tp, time);
+		break;
+	case GESTURE_STATE_PINCH:
+		gesture_notify_pinch_end(&tp->device->base, time,
+					 tp->gesture.finger_count,
+					 tp->gesture.prev_scale,
+					 cancelled);
+		break;
+	case GESTURE_STATE_SWIPE:
+		gesture_notify_swipe_end(&tp->device->base,
+					 time,
+					 tp->gesture.finger_count,
+					 cancelled);
+		break;
+	}
+
+	tp->gesture.started = false;
+}
+
+void
+tp_gesture_cancel(struct tp_dispatch *tp, uint64_t time)
+{
+	tp_gesture_end(tp, time, true);
+}
+
+void
+tp_gesture_stop(struct tp_dispatch *tp, uint64_t time)
+{
+	tp_gesture_end(tp, time, false);
+}
+
+static void
+tp_gesture_finger_count_switch_timeout(uint64_t now, void *data)
+{
+	struct tp_dispatch *tp = data;
+
+	if (!tp->gesture.finger_count_pending)
+		return;
+
+	tp_gesture_cancel(tp, now); /* End current gesture */
+	tp->gesture.finger_count = tp->gesture.finger_count_pending;
+	tp->gesture.finger_count_pending = 0;
+}
+
+void
+tp_gesture_handle_state(struct tp_dispatch *tp, uint64_t time)
+{
+	unsigned int active_touches = 0;
+	struct tp_touch *t;
+
+	tp_for_each_touch(tp, t) {
+		if (tp_touch_active(tp, t))
+			active_touches++;
+	}
+
+	if (active_touches != tp->gesture.finger_count) {
+		/* If all fingers are lifted immediately end the gesture */
+		if (active_touches == 0) {
+			tp_gesture_stop(tp, time);
+			tp->gesture.finger_count = 0;
+			tp->gesture.finger_count_pending = 0;
+		/* Immediately switch to new mode to avoid initial latency */
+		} else if (!tp->gesture.started) {
+			tp->gesture.finger_count = active_touches;
+			tp->gesture.finger_count_pending = 0;
+		/* Else debounce finger changes */
+		} else if (active_touches != tp->gesture.finger_count_pending) {
+			tp->gesture.finger_count_pending = active_touches;
+			libinput_timer_set(&tp->gesture.finger_count_switch_timer,
+				time + DEFAULT_GESTURE_SWITCH_TIMEOUT);
+		}
+	} else {
+		 tp->gesture.finger_count_pending = 0;
+	}
+}
+
+void
+tp_init_gesture(struct tp_dispatch *tp)
+{
+	char timer_name[64];
+
+	/* two-finger scrolling is always enabled, this flag just
+	 * decides whether we detect pinch. semi-mt devices are too
+	 * unreliable to do pinch gestures. */
+	tp->gesture.enabled = !tp->semi_mt && tp->num_slots > 1;
+
+	tp->gesture.state = GESTURE_STATE_NONE;
+
+	snprintf(timer_name,
+		 sizeof(timer_name),
+		 "%s gestures",
+		 evdev_device_get_sysname(tp->device));
+	libinput_timer_init(&tp->gesture.finger_count_switch_timer,
+			    tp_libinput_context(tp),
+			    timer_name,
+			    tp_gesture_finger_count_switch_timeout, tp);
+}
+
+void
+tp_remove_gesture(struct tp_dispatch *tp)
+{
+	libinput_timer_cancel(&tp->gesture.finger_count_switch_timer);
+}
--- libinput-1.10.7.orig/src/evdev-mt-touchpad.h
+++ libinput-1.10.7/src/evdev-mt-touchpad.h
@@ -134,6 +134,7 @@ enum tp_gesture_state {
 	GESTURE_STATE_SCROLL,
 	GESTURE_STATE_PINCH,
 	GESTURE_STATE_SWIPE,
+	GESTURE_STATE_TAP,
 };
 
 enum tp_thumb_state {
--- /dev/null
+++ libinput-1.10.7/src/evdev-mt-touchpad.h.orig
@@ -0,0 +1,628 @@
+/*
+ * Copyright © 2014-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef EVDEV_MT_TOUCHPAD_H
+#define EVDEV_MT_TOUCHPAD_H
+
+#include <stdbool.h>
+
+#include "evdev.h"
+#include "filter.h"
+#include "timer.h"
+
+#define TOUCHPAD_HISTORY_LENGTH 4
+#define TOUCHPAD_MIN_SAMPLES 4
+
+/* Convert mm to a distance normalized to DEFAULT_MOUSE_DPI */
+#define TP_MM_TO_DPI_NORMALIZED(mm) (DEFAULT_MOUSE_DPI/25.4 * mm)
+
+enum touchpad_event {
+	TOUCHPAD_EVENT_NONE		= 0,
+	TOUCHPAD_EVENT_MOTION		= (1 << 0),
+	TOUCHPAD_EVENT_BUTTON_PRESS	= (1 << 1),
+	TOUCHPAD_EVENT_BUTTON_RELEASE	= (1 << 2),
+	TOUCHPAD_EVENT_OTHERAXIS	= (1 << 3),
+};
+
+enum touch_state {
+	TOUCH_NONE = 0,
+	TOUCH_HOVERING = 1,
+	TOUCH_BEGIN = 2,
+	TOUCH_UPDATE = 3,
+	TOUCH_MAYBE_END = 4,
+	TOUCH_END = 5,
+};
+
+enum touch_palm_state {
+	PALM_NONE = 0,
+	PALM_EDGE,
+	PALM_TYPING,
+	PALM_TRACKPOINT,
+	PALM_TOOL_PALM,
+	PALM_PRESSURE,
+	PALM_TOUCH_SIZE,
+};
+
+enum button_event {
+	BUTTON_EVENT_IN_BOTTOM_R = 30,
+	BUTTON_EVENT_IN_BOTTOM_M,
+	BUTTON_EVENT_IN_BOTTOM_L,
+	BUTTON_EVENT_IN_TOP_R,
+	BUTTON_EVENT_IN_TOP_M,
+	BUTTON_EVENT_IN_TOP_L,
+	BUTTON_EVENT_IN_AREA,
+	BUTTON_EVENT_UP,
+	BUTTON_EVENT_PRESS,
+	BUTTON_EVENT_RELEASE,
+	BUTTON_EVENT_TIMEOUT,
+};
+
+enum button_state {
+	BUTTON_STATE_NONE,
+	BUTTON_STATE_AREA,
+	BUTTON_STATE_BOTTOM,
+	BUTTON_STATE_TOP,
+	BUTTON_STATE_TOP_NEW,
+	BUTTON_STATE_TOP_TO_IGNORE,
+	BUTTON_STATE_IGNORE,
+};
+
+enum tp_tap_state {
+	TAP_STATE_IDLE = 4,
+	TAP_STATE_TOUCH,
+	TAP_STATE_HOLD,
+	TAP_STATE_TAPPED,
+	TAP_STATE_TOUCH_2,
+	TAP_STATE_TOUCH_2_HOLD,
+	TAP_STATE_TOUCH_2_RELEASE,
+	TAP_STATE_TOUCH_3,
+	TAP_STATE_TOUCH_3_HOLD,
+	TAP_STATE_DRAGGING_OR_DOUBLETAP,
+	TAP_STATE_DRAGGING_OR_TAP,
+	TAP_STATE_DRAGGING,
+	TAP_STATE_DRAGGING_WAIT,
+	TAP_STATE_DRAGGING_2,
+	TAP_STATE_MULTITAP,
+	TAP_STATE_MULTITAP_DOWN,
+	TAP_STATE_MULTITAP_PALM,
+	TAP_STATE_DEAD, /**< finger count exceeded */
+};
+
+enum tp_tap_touch_state {
+	TAP_TOUCH_STATE_IDLE = 16,	/**< not in touch */
+	TAP_TOUCH_STATE_TOUCH,		/**< touching, may tap */
+	TAP_TOUCH_STATE_DEAD,		/**< exceeded motion/timeout */
+};
+
+/* For edge scrolling, so we only care about right and bottom */
+enum tp_edge {
+	EDGE_NONE = 0,
+	EDGE_RIGHT = (1 << 0),
+	EDGE_BOTTOM = (1 << 1),
+};
+
+enum tp_edge_scroll_touch_state {
+	EDGE_SCROLL_TOUCH_STATE_NONE,
+	EDGE_SCROLL_TOUCH_STATE_EDGE_NEW,
+	EDGE_SCROLL_TOUCH_STATE_EDGE,
+	EDGE_SCROLL_TOUCH_STATE_AREA,
+};
+
+enum tp_gesture_state {
+	GESTURE_STATE_NONE,
+	GESTURE_STATE_UNKNOWN,
+	GESTURE_STATE_SCROLL,
+	GESTURE_STATE_PINCH,
+	GESTURE_STATE_SWIPE,
+};
+
+enum tp_thumb_state {
+	THUMB_STATE_NO,
+	THUMB_STATE_YES,
+	THUMB_STATE_MAYBE,
+};
+
+struct tp_touch {
+	struct tp_dispatch *tp;
+	enum touch_state state;
+	bool has_ended;				/* TRACKING_ID == -1 */
+	bool dirty;
+	struct device_coords point;
+	struct device_coords last_point;
+	uint64_t time;
+	int pressure;
+	bool is_tool_palm; /* MT_TOOL_PALM */
+	int major, minor;
+
+	bool was_down; /* if distance == 0, false for pure hovering
+			  touches */
+
+	struct {
+		/* A quirk mostly used on Synaptics touchpads. In a
+		   transition to/from fake touches > num_slots, the current
+		   event data is likely garbage and the subsequent event
+		   is likely too. This marker tells us to reset the motion
+		   history again -> this effectively swallows any motion */
+		bool reset_motion_history;
+	} quirks;
+
+	struct {
+		struct tp_history_point {
+			uint64_t time;
+			struct device_coords point;
+		} samples[TOUCHPAD_HISTORY_LENGTH];
+		unsigned int index;
+		unsigned int count;
+	} history;
+
+	struct {
+		struct device_coords center;
+		uint8_t x_motion_history;
+	} hysteresis;
+
+	/* A pinned touchpoint is the one that pressed the physical button
+	 * on a clickpad. After the release, it won't move until the center
+	 * moves more than a threshold away from the original coordinates
+	 */
+	struct {
+		bool is_pinned;
+		struct device_coords center;
+	} pinned;
+
+	/* Software-button state and timeout if applicable */
+	struct {
+		enum button_state state;
+		/* We use button_event here so we can use == on events */
+		enum button_event curr;
+		struct libinput_timer timer;
+	} button;
+
+	struct {
+		enum tp_tap_touch_state state;
+		struct device_coords initial;
+		bool is_thumb;
+		bool is_palm;
+	} tap;
+
+	struct {
+		enum tp_edge_scroll_touch_state edge_state;
+		uint32_t edge;
+		int direction;
+		struct libinput_timer timer;
+		struct device_coords initial;
+	} scroll;
+
+	struct {
+		enum touch_palm_state state;
+		struct device_coords first; /* first coordinates if is_palm == true */
+		uint64_t time; /* first timestamp if is_palm == true */
+	} palm;
+
+	struct {
+		struct device_coords initial;
+	} gesture;
+
+	struct {
+		enum tp_thumb_state state;
+		uint64_t first_touch_time;
+		struct device_coords initial;
+	} thumb;
+
+	struct {
+		double last_speed; /* speed in mm/s at last sample */
+		unsigned int exceeded_count;
+	} speed;
+};
+
+struct tp_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device *device;
+	unsigned int nfingers_down;		/* number of fingers down */
+	unsigned int old_nfingers_down;		/* previous no fingers down */
+	unsigned int slot;			/* current slot */
+	bool has_mt;
+	bool semi_mt;
+
+	/* true if we're reading events (i.e. not suspended) but we're
+	 * ignoring them */
+	bool ignore_events;
+
+	unsigned int num_slots;			/* number of slots */
+	unsigned int ntouches;			/* no slots inc. fakes */
+	struct tp_touch *touches;		/* len == ntouches */
+	/* bit 0: BTN_TOUCH
+	 * bit 1: BTN_TOOL_FINGER
+	 * bit 2: BTN_TOOL_DOUBLETAP
+	 * ...
+	 */
+	unsigned int fake_touches;
+
+	/* if pressure goes above high -> touch down,
+	   if pressure then goes below low -> touch up */
+	struct {
+		bool use_pressure;
+		int high;
+		int low;
+	} pressure;
+
+	/* If touch size (either axis) goes above high -> touch down,
+	   if touch size (either axis) goes below low -> touch up */
+	struct  {
+		bool use_touch_size;
+		int high;
+		int low;
+
+		/* convert device units to angle */
+		double orientation_to_angle;
+	} touch_size;
+
+	struct {
+		bool enabled;
+		struct device_coords margin;
+		unsigned int other_event_count;
+		uint64_t last_motion_time;
+	} hysteresis;
+
+	struct {
+		double x_scale_coeff;
+		double y_scale_coeff;
+		double xy_scale_coeff;
+	} accel;
+
+	struct {
+		bool enabled;
+		bool started;
+		unsigned int finger_count;
+		unsigned int finger_count_pending;
+		struct libinput_timer finger_count_switch_timer;
+		enum tp_gesture_state state;
+		struct tp_touch *touches[2];
+		uint64_t initial_time;
+		double initial_distance;
+		double prev_scale;
+		double angle;
+		struct device_float_coords center;
+	} gesture;
+
+	struct {
+		bool is_clickpad;		/* true for clickpads */
+		bool has_topbuttons;
+		bool use_clickfinger;		/* number of fingers decides button number */
+		bool click_pending;
+		uint32_t state;
+		uint32_t old_state;
+		struct {
+			double x_scale_coeff;
+			double y_scale_coeff;
+		} motion_dist;			/* for pinned touches */
+		unsigned int active;		/* currently active button, for release event */
+		bool active_is_topbutton;	/* is active a top button? */
+
+		/* Only used for clickpads. The software button areas are
+		 * always 2 horizontal stripes across the touchpad.
+		 * The buttons are split according to the edge settings.
+		 */
+		struct {
+			int32_t top_edge;	/* in device coordinates */
+			int32_t rightbutton_left_edge; /* in device coordinates */
+			int32_t middlebutton_left_edge; /* in device coordinates */
+		} bottom_area;
+
+		struct {
+			int32_t bottom_edge;	/* in device coordinates */
+			int32_t rightbutton_left_edge; /* in device coordinates */
+			int32_t leftbutton_right_edge; /* in device coordinates */
+		} top_area;
+
+		struct evdev_device *trackpoint;
+
+		enum libinput_config_click_method click_method;
+		struct libinput_device_config_click_method config_method;
+	} buttons;
+
+	struct {
+		struct libinput_device_config_scroll_method config_method;
+		enum libinput_config_scroll_method method;
+		int32_t right_edge;		/* in device coordinates */
+		int32_t bottom_edge;		/* in device coordinates */
+	} scroll;
+
+	enum touchpad_event queued;
+
+	struct {
+		struct libinput_device_config_tap config;
+		bool enabled;
+		bool suspended;
+		struct libinput_timer timer;
+		enum tp_tap_state state;
+		uint32_t buttons_pressed;
+		uint64_t saved_press_time,
+			 saved_release_time;
+
+		enum libinput_config_tap_button_map map;
+		enum libinput_config_tap_button_map want_map;
+
+		bool drag_enabled;
+		bool drag_lock_enabled;
+
+		unsigned int nfingers_down;	/* number of fingers down for tapping (excl. thumb/palm) */
+	} tap;
+
+	struct {
+		int32_t right_edge;		/* in device coordinates */
+		int32_t left_edge;		/* in device coordinates */
+		int32_t upper_edge;		/* in device coordinates */
+
+		bool trackpoint_active;
+		struct libinput_event_listener trackpoint_listener;
+		struct libinput_timer trackpoint_timer;
+		uint64_t trackpoint_last_event_time;
+		uint32_t trackpoint_event_count;
+		bool monitor_trackpoint;
+
+		bool use_mt_tool;
+
+		bool use_pressure;
+		int pressure_threshold;
+
+		bool use_size;
+		int size_threshold;
+	} palm;
+
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+
+	struct {
+		struct libinput_device_config_dwt config;
+		bool dwt_enabled;
+
+		/* We have to allow for more than one device node to be the
+		 * internal dwt keyboard (Razer Blade). But they're the same
+		 * physical device, so we don't care about per-keyboard
+		 * key/modifier masks.
+		 */
+		struct paired_keyboard {
+			struct evdev_device *device;
+			struct libinput_event_listener listener;
+		} paired_keyboard[3];
+
+		unsigned long key_mask[NLONGS(KEY_CNT)];
+		unsigned long mod_mask[NLONGS(KEY_CNT)];
+		bool keyboard_active;
+		struct libinput_timer keyboard_timer;
+		uint64_t keyboard_last_press_time;
+	} dwt;
+
+	struct {
+		bool detect_thumbs;
+		int threshold;
+		int upper_thumb_line;
+		int lower_thumb_line;
+	} thumb;
+
+	struct {
+		/* A quirk used on the T450 series Synaptics hardware.
+		 * Slowly moving the finger causes multiple events with only
+		 * ABS_MT_PRESSURE but no x/y information. When the x/y
+		 * event comes, it will be a jump of ~20 units. We use the
+		 * below to count non-motion events to discard that first
+		 * event with the jump.
+		 */
+		unsigned int nonmotion_event_count;
+	} quirks;
+
+	struct {
+		struct libinput_event_listener listener;
+		struct evdev_device *lid_switch;
+	} lid_switch;
+
+	struct {
+		struct libinput_event_listener listener;
+		struct evdev_device *tablet_mode_switch;
+	} tablet_mode_switch;
+};
+
+static inline struct tp_dispatch*
+tp_dispatch(struct evdev_dispatch *dispatch)
+{
+	evdev_verify_dispatch_type(dispatch, DISPATCH_TOUCHPAD);
+
+	return container_of(dispatch, struct tp_dispatch, base);
+}
+
+#define tp_for_each_touch(_tp, _t) \
+	for (unsigned int _i = 0; _i < (_tp)->ntouches && (_t = &(_tp)->touches[_i]); _i++)
+
+static inline struct libinput*
+tp_libinput_context(const struct tp_dispatch *tp)
+{
+	return evdev_libinput_context(tp->device);
+}
+
+static inline struct normalized_coords
+tp_normalize_delta(const struct tp_dispatch *tp,
+		   struct device_float_coords delta)
+{
+	struct normalized_coords normalized;
+
+	normalized.x = delta.x * tp->accel.x_scale_coeff;
+	normalized.y = delta.y * tp->accel.y_scale_coeff;
+
+	return normalized;
+}
+
+static inline struct phys_coords
+tp_phys_delta(const struct tp_dispatch *tp,
+	      struct device_float_coords delta)
+{
+	struct phys_coords mm;
+
+	mm.x = delta.x / tp->device->abs.absinfo_x->resolution;
+	mm.y = delta.y / tp->device->abs.absinfo_y->resolution;
+
+	return mm;
+}
+
+/**
+ * Takes a set of device coordinates, returns that set of coordinates in the
+ * x-axis' resolution.
+ */
+static inline struct device_float_coords
+tp_scale_to_xaxis(const struct tp_dispatch *tp,
+		  struct device_float_coords delta)
+{
+	struct device_float_coords raw;
+
+	raw.x = delta.x;
+	raw.y = delta.y * tp->accel.xy_scale_coeff;
+
+	return raw;
+}
+
+struct device_coords
+tp_get_delta(struct tp_touch *t);
+
+struct normalized_coords
+tp_filter_motion(struct tp_dispatch *tp,
+		 const struct device_float_coords *unaccelerated,
+		 uint64_t time);
+
+struct normalized_coords
+tp_filter_motion_unaccelerated(struct tp_dispatch *tp,
+			       const struct device_float_coords *unaccelerated,
+			       uint64_t time);
+
+bool
+tp_touch_active(const struct tp_dispatch *tp, const struct tp_touch *t);
+
+int
+tp_tap_handle_state(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_tap_post_process_state(struct tp_dispatch *tp);
+
+void
+tp_init_tap(struct tp_dispatch *tp);
+
+void
+tp_remove_tap(struct tp_dispatch *tp);
+
+void
+tp_init_buttons(struct tp_dispatch *tp, struct evdev_device *device);
+
+void
+tp_init_top_softbuttons(struct tp_dispatch *tp,
+			struct evdev_device *device,
+			double topbutton_size_mult);
+
+void
+tp_remove_buttons(struct tp_dispatch *tp);
+
+void
+tp_process_button(struct tp_dispatch *tp,
+		  const struct input_event *e,
+		  uint64_t time);
+
+void
+tp_release_all_buttons(struct tp_dispatch *tp,
+		       uint64_t time);
+
+int
+tp_post_button_events(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_button_handle_state(struct tp_dispatch *tp, uint64_t time);
+
+bool
+tp_button_touch_active(const struct tp_dispatch *tp,
+		       const struct tp_touch *t);
+
+bool
+tp_button_is_inside_softbutton_area(const struct tp_dispatch *tp,
+				    const struct tp_touch *t);
+
+void
+tp_release_all_taps(struct tp_dispatch *tp,
+		    uint64_t time);
+
+void
+tp_tap_suspend(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_tap_resume(struct tp_dispatch *tp, uint64_t time);
+
+bool
+tp_tap_dragging(const struct tp_dispatch *tp);
+
+void
+tp_edge_scroll_init(struct tp_dispatch *tp, struct evdev_device *device);
+
+void
+tp_remove_edge_scroll(struct tp_dispatch *tp);
+
+void
+tp_edge_scroll_handle_state(struct tp_dispatch *tp, uint64_t time);
+
+int
+tp_edge_scroll_post_events(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_edge_scroll_stop_events(struct tp_dispatch *tp, uint64_t time);
+
+int
+tp_edge_scroll_touch_active(const struct tp_dispatch *tp,
+			    const struct tp_touch *t);
+
+uint32_t
+tp_touch_get_edge(const struct tp_dispatch *tp, const struct tp_touch *t);
+
+void
+tp_init_gesture(struct tp_dispatch *tp);
+
+void
+tp_remove_gesture(struct tp_dispatch *tp);
+
+void
+tp_gesture_stop(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_gesture_cancel(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_gesture_handle_state(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_gesture_post_events(struct tp_dispatch *tp, uint64_t time);
+
+void
+tp_gesture_stop_twofinger_scroll(struct tp_dispatch *tp, uint64_t time);
+
+bool
+tp_palm_tap_is_palm(const struct tp_dispatch *tp, const struct tp_touch *t);
+
+void
+tp_clickpad_middlebutton_apply_config(struct evdev_device *device);
+
+#endif
--- libinput-1.10.7.orig/src/libinput-private.h
+++ libinput-1.10.7/src/libinput-private.h
@@ -562,20 +562,34 @@ gesture_notify_swipe_end(struct libinput
 
 void
 gesture_notify_pinch(struct libinput_device *device,
-		     uint64_t time,
-		     enum libinput_event_type type,
-		     int finger_count,
-		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel,
-		     double scale,
-		     double angle);
+                     uint64_t time,
+                     enum libinput_event_type type,
+                     int finger_count,
+                     const struct normalized_coords *delta,
+                     const struct normalized_coords *unaccel,
+                     double scale,
+                     double angle);
 
 void
 gesture_notify_pinch_end(struct libinput_device *device,
-			 uint64_t time,
-			 int finger_count,
-			 double scale,
-			 int cancelled);
+                         uint64_t time,
+                         int finger_count,
+                         double scale,
+                         int cancelled);
+
+void
+gesture_notify_tap(struct libinput_device *device,
+                     uint64_t time,
+                     enum libinput_event_type type,
+                     int finger_count,
+                     const struct normalized_coords *delta,
+                     const struct normalized_coords *unaccel);
+
+void
+gesture_notify_tap_end(struct libinput_device *device,
+                         uint64_t time,
+                         int finger_count,
+                         int cancelled);
 
 void
 tablet_notify_axis(struct libinput_device *device,
--- /dev/null
+++ libinput-1.10.7/src/libinput-private.h.orig
@@ -0,0 +1,792 @@
+/*
+ * Copyright © 2013 Jonas Ådahl
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBINPUT_PRIVATE_H
+#define LIBINPUT_PRIVATE_H
+
+#include "config.h"
+
+#include <errno.h>
+#include <math.h>
+#include <stdarg.h>
+
+#include "linux/input.h"
+
+#include "libinput.h"
+#include "libinput-util.h"
+#include "libinput-version.h"
+
+#if LIBINPUT_VERSION_MICRO >= 90
+#define HTTP_DOC_LINK "https://wayland.freedesktop.org/libinput/doc/latest/"
+#else
+#define HTTP_DOC_LINK "https://wayland.freedesktop.org/libinput/doc/" LIBINPUT_VERSION "/"
+#endif
+
+struct libinput_source;
+
+/* A coordinate pair in device coordinates */
+struct device_coords {
+	int x, y;
+};
+
+/*
+ * A coordinate pair in device coordinates, capable of holding non discrete
+ * values, this is necessary e.g. when device coordinates get averaged.
+ */
+struct device_float_coords {
+	double x, y;
+};
+
+/* A dpi-normalized coordinate pair */
+struct normalized_coords {
+	double x, y;
+};
+
+/* A discrete step pair (mouse wheels) */
+struct discrete_coords {
+	int x, y;
+};
+
+/* A pair of coordinates normalized to a [0,1] or [-1, 1] range */
+struct normalized_range_coords {
+	double x, y;
+};
+
+/* A pair of angles in degrees */
+struct wheel_angle {
+	double x, y;
+};
+
+/* A pair of angles in degrees */
+struct tilt_degrees {
+	double x, y;
+};
+
+/* A threshold with an upper and lower limit */
+struct threshold {
+	int upper;
+	int lower;
+};
+
+/* A pair of coordinates in mm */
+struct phys_coords {
+	double x;
+	double y;
+};
+
+/* A pair of tilt flags */
+struct wheel_tilt_flags {
+	bool vertical, horizontal;
+};
+
+struct libinput_interface_backend {
+	int (*resume)(struct libinput *libinput);
+	void (*suspend)(struct libinput *libinput);
+	void (*destroy)(struct libinput *libinput);
+	int (*device_change_seat)(struct libinput_device *device,
+				  const char *seat_name);
+};
+
+struct libinput {
+	int epoll_fd;
+	struct list source_destroy_list;
+
+	struct list seat_list;
+
+	struct {
+		struct list list;
+		struct libinput_source *source;
+		int fd;
+		uint64_t next_expiry;
+	} timer;
+
+	struct libinput_event **events;
+	size_t events_count;
+	size_t events_len;
+	size_t events_in;
+	size_t events_out;
+
+	struct list tool_list;
+
+	const struct libinput_interface *interface;
+	const struct libinput_interface_backend *interface_backend;
+
+	libinput_log_handler log_handler;
+	enum libinput_log_priority log_priority;
+	void *user_data;
+	int refcount;
+
+	struct list device_group_list;
+
+	uint64_t last_event_time;
+};
+
+typedef void (*libinput_seat_destroy_func) (struct libinput_seat *seat);
+
+struct libinput_seat {
+	struct libinput *libinput;
+	struct list link;
+	struct list devices_list;
+	void *user_data;
+	int refcount;
+	libinput_seat_destroy_func destroy;
+
+	char *physical_name;
+	char *logical_name;
+
+	uint32_t slot_map;
+
+	uint32_t button_count[KEY_CNT];
+};
+
+struct libinput_device_config_tap {
+	int (*count)(struct libinput_device *device);
+	enum libinput_config_status (*set_enabled)(struct libinput_device *device,
+						   enum libinput_config_tap_state enable);
+	enum libinput_config_tap_state (*get_enabled)(struct libinput_device *device);
+	enum libinput_config_tap_state (*get_default)(struct libinput_device *device);
+
+	enum libinput_config_status (*set_map)(struct libinput_device *device,
+						   enum libinput_config_tap_button_map map);
+	enum libinput_config_tap_button_map (*get_map)(struct libinput_device *device);
+	enum libinput_config_tap_button_map (*get_default_map)(struct libinput_device *device);
+
+	enum libinput_config_status (*set_drag_enabled)(struct libinput_device *device,
+							enum libinput_config_drag_state);
+	enum libinput_config_drag_state (*get_drag_enabled)(struct libinput_device *device);
+	enum libinput_config_drag_state (*get_default_drag_enabled)(struct libinput_device *device);
+
+	enum libinput_config_status (*set_draglock_enabled)(struct libinput_device *device,
+							    enum libinput_config_drag_lock_state);
+	enum libinput_config_drag_lock_state (*get_draglock_enabled)(struct libinput_device *device);
+	enum libinput_config_drag_lock_state (*get_default_draglock_enabled)(struct libinput_device *device);
+};
+
+struct libinput_device_config_calibration {
+	int (*has_matrix)(struct libinput_device *device);
+	enum libinput_config_status (*set_matrix)(struct libinput_device *device,
+						  const float matrix[6]);
+	int (*get_matrix)(struct libinput_device *device,
+			  float matrix[6]);
+	int (*get_default_matrix)(struct libinput_device *device,
+							  float matrix[6]);
+};
+
+struct libinput_device_config_send_events {
+	uint32_t (*get_modes)(struct libinput_device *device);
+	enum libinput_config_status (*set_mode)(struct libinput_device *device,
+						   enum libinput_config_send_events_mode mode);
+	enum libinput_config_send_events_mode (*get_mode)(struct libinput_device *device);
+	enum libinput_config_send_events_mode (*get_default_mode)(struct libinput_device *device);
+};
+
+struct libinput_device_config_accel {
+	int (*available)(struct libinput_device *device);
+	enum libinput_config_status (*set_speed)(struct libinput_device *device,
+						 double speed);
+	double (*get_speed)(struct libinput_device *device);
+	double (*get_default_speed)(struct libinput_device *device);
+
+	uint32_t (*get_profiles)(struct libinput_device *device);
+	enum libinput_config_status (*set_profile)(struct libinput_device *device,
+						   enum libinput_config_accel_profile);
+	enum libinput_config_accel_profile (*get_profile)(struct libinput_device *device);
+	enum libinput_config_accel_profile (*get_default_profile)(struct libinput_device *device);
+};
+
+struct libinput_device_config_natural_scroll {
+	int (*has)(struct libinput_device *device);
+	enum libinput_config_status (*set_enabled)(struct libinput_device *device,
+						   int enabled);
+	int (*get_enabled)(struct libinput_device *device);
+	int (*get_default_enabled)(struct libinput_device *device);
+};
+
+struct libinput_device_config_left_handed {
+	int (*has)(struct libinput_device *device);
+	enum libinput_config_status (*set)(struct libinput_device *device, int left_handed);
+	int (*get)(struct libinput_device *device);
+	int (*get_default)(struct libinput_device *device);
+};
+
+struct libinput_device_config_scroll_method {
+	uint32_t (*get_methods)(struct libinput_device *device);
+	enum libinput_config_status (*set_method)(struct libinput_device *device,
+						  enum libinput_config_scroll_method method);
+	enum libinput_config_scroll_method (*get_method)(struct libinput_device *device);
+	enum libinput_config_scroll_method (*get_default_method)(struct libinput_device *device);
+	enum libinput_config_status (*set_button)(struct libinput_device *device,
+						  uint32_t button);
+	uint32_t (*get_button)(struct libinput_device *device);
+	uint32_t (*get_default_button)(struct libinput_device *device);
+};
+
+struct libinput_device_config_click_method {
+	uint32_t (*get_methods)(struct libinput_device *device);
+	enum libinput_config_status (*set_method)(struct libinput_device *device,
+						  enum libinput_config_click_method method);
+	enum libinput_config_click_method (*get_method)(struct libinput_device *device);
+	enum libinput_config_click_method (*get_default_method)(struct libinput_device *device);
+};
+
+struct libinput_device_config_middle_emulation {
+	int (*available)(struct libinput_device *device);
+	enum libinput_config_status (*set)(
+			 struct libinput_device *device,
+			 enum libinput_config_middle_emulation_state);
+	enum libinput_config_middle_emulation_state (*get)(
+			 struct libinput_device *device);
+	enum libinput_config_middle_emulation_state (*get_default)(
+			 struct libinput_device *device);
+};
+
+struct libinput_device_config_dwt {
+	int (*is_available)(struct libinput_device *device);
+	enum libinput_config_status (*set_enabled)(
+			 struct libinput_device *device,
+			 enum libinput_config_dwt_state enable);
+	enum libinput_config_dwt_state (*get_enabled)(
+			 struct libinput_device *device);
+	enum libinput_config_dwt_state (*get_default_enabled)(
+			 struct libinput_device *device);
+};
+
+struct libinput_device_config_rotation {
+	int (*is_available)(struct libinput_device *device);
+	enum libinput_config_status (*set_angle)(
+			 struct libinput_device *device,
+			 unsigned int degrees_cw);
+	unsigned int (*get_angle)(struct libinput_device *device);
+	unsigned int (*get_default_angle)(struct libinput_device *device);
+};
+
+struct libinput_device_config {
+	struct libinput_device_config_tap *tap;
+	struct libinput_device_config_calibration *calibration;
+	struct libinput_device_config_send_events *sendevents;
+	struct libinput_device_config_accel *accel;
+	struct libinput_device_config_natural_scroll *natural_scroll;
+	struct libinput_device_config_left_handed *left_handed;
+	struct libinput_device_config_scroll_method *scroll_method;
+	struct libinput_device_config_click_method *click_method;
+	struct libinput_device_config_middle_emulation *middle_emulation;
+	struct libinput_device_config_dwt *dwt;
+	struct libinput_device_config_rotation *rotation;
+};
+
+struct libinput_device_group {
+	int refcount;
+	void *user_data;
+	char *identifier; /* unique identifier or NULL for singletons */
+
+	struct list link;
+};
+
+struct libinput_device {
+	struct libinput_seat *seat;
+	struct libinput_device_group *group;
+	struct list link;
+	struct list event_listeners;
+	void *user_data;
+	int refcount;
+	struct libinput_device_config config;
+};
+
+enum libinput_tablet_tool_axis {
+	LIBINPUT_TABLET_TOOL_AXIS_X = 1,
+	LIBINPUT_TABLET_TOOL_AXIS_Y = 2,
+	LIBINPUT_TABLET_TOOL_AXIS_DISTANCE = 3,
+	LIBINPUT_TABLET_TOOL_AXIS_PRESSURE = 4,
+	LIBINPUT_TABLET_TOOL_AXIS_TILT_X = 5,
+	LIBINPUT_TABLET_TOOL_AXIS_TILT_Y = 6,
+	LIBINPUT_TABLET_TOOL_AXIS_ROTATION_Z = 7,
+	LIBINPUT_TABLET_TOOL_AXIS_SLIDER = 8,
+	LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL = 9,
+};
+
+#define LIBINPUT_TABLET_TOOL_AXIS_MAX LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL
+
+struct tablet_axes {
+	struct device_coords point;
+	struct normalized_coords delta;
+	double distance;
+	double pressure;
+	struct tilt_degrees tilt;
+	double rotation;
+	double slider;
+	double wheel;
+	int wheel_discrete;
+};
+
+struct libinput_tablet_tool {
+	struct list link;
+	uint32_t serial;
+	uint32_t tool_id;
+	enum libinput_tablet_tool_type type;
+	unsigned char axis_caps[NCHARS(LIBINPUT_TABLET_TOOL_AXIS_MAX + 1)];
+	unsigned char buttons[NCHARS(KEY_MAX) + 1];
+	int refcount;
+	void *user_data;
+
+	/* The pressure threshold assumes a pressure_offset of 0 */
+	struct threshold pressure_threshold;
+	int pressure_offset; /* in device coordinates */
+	bool has_pressure_offset;
+};
+
+struct libinput_tablet_pad_mode_group {
+	struct libinput_device *device;
+	struct list link;
+	int refcount;
+	void *user_data;
+
+	unsigned int index;
+	unsigned int num_modes;
+	unsigned int current_mode;
+
+	uint32_t button_mask;
+	uint32_t ring_mask;
+	uint32_t strip_mask;
+
+	uint32_t toggle_button_mask;
+
+	void (*destroy)(struct libinput_tablet_pad_mode_group *group);
+};
+
+struct libinput_event {
+	enum libinput_event_type type;
+	struct libinput_device *device;
+};
+
+struct libinput_event_listener {
+	struct list link;
+	void (*notify_func)(uint64_t time, struct libinput_event *ev, void *notify_func_data);
+	void *notify_func_data;
+};
+
+typedef void (*libinput_source_dispatch_t)(void *data);
+
+#define log_debug(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
+#define log_info(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_INFO, __VA_ARGS__)
+#define log_error(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, __VA_ARGS__)
+#define log_bug_kernel(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "kernel bug: " __VA_ARGS__)
+#define log_bug_libinput(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "libinput bug: " __VA_ARGS__)
+#define log_bug_client(li_, ...) log_msg((li_), LIBINPUT_LOG_PRIORITY_ERROR, "client bug: " __VA_ARGS__)
+
+#define log_debug_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_DEBUG, __VA_ARGS__)
+#define log_info_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_INFO, __VA_ARGS__)
+#define log_error_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_ERROR, __VA_ARGS__)
+#define log_bug_kernel_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_ERROR, "kernel bug: " __VA_ARGS__)
+#define log_bug_libinput_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_ERROR, "libinput bug: " __VA_ARGS__)
+#define log_bug_client_ratelimit(li_, r_, ...) log_msg_ratelimit((li_), (r_), LIBINPUT_LOG_PRIORITY_ERROR, "client bug: " __VA_ARGS__)
+
+void
+log_msg_ratelimit(struct libinput *libinput,
+		  struct ratelimit *ratelimit,
+		  enum libinput_log_priority priority,
+		  const char *format, ...)
+	LIBINPUT_ATTRIBUTE_PRINTF(4, 5);
+
+void
+log_msg(struct libinput *libinput,
+	enum libinput_log_priority priority,
+	const char *format, ...)
+	LIBINPUT_ATTRIBUTE_PRINTF(3, 4);
+
+void
+log_msg_va(struct libinput *libinput,
+	   enum libinput_log_priority priority,
+	   const char *format,
+	   va_list args)
+	LIBINPUT_ATTRIBUTE_PRINTF(3, 0);
+
+int
+libinput_init(struct libinput *libinput,
+	      const struct libinput_interface *interface,
+	      const struct libinput_interface_backend *interface_backend,
+	      void *user_data);
+
+struct libinput_source *
+libinput_add_fd(struct libinput *libinput,
+		int fd,
+		libinput_source_dispatch_t dispatch,
+		void *data);
+
+void
+libinput_remove_source(struct libinput *libinput,
+		       struct libinput_source *source);
+
+int
+open_restricted(struct libinput *libinput,
+		const char *path, int flags);
+
+void
+close_restricted(struct libinput *libinput, int fd);
+
+bool
+ignore_litest_test_suite_device(struct udev_device *device);
+
+void
+libinput_seat_init(struct libinput_seat *seat,
+		   struct libinput *libinput,
+		   const char *physical_name,
+		   const char *logical_name,
+		   libinput_seat_destroy_func destroy);
+
+void
+libinput_device_init(struct libinput_device *device,
+		     struct libinput_seat *seat);
+
+struct libinput_device_group *
+libinput_device_group_create(struct libinput *libinput,
+			     const char *identifier);
+
+struct libinput_device_group *
+libinput_device_group_find_group(struct libinput *libinput,
+				 const char *identifier);
+
+void
+libinput_device_set_device_group(struct libinput_device *device,
+				 struct libinput_device_group *group);
+
+void
+libinput_device_init_event_listener(struct libinput_event_listener *listener);
+
+void
+libinput_device_add_event_listener(struct libinput_device *device,
+				   struct libinput_event_listener *listener,
+				   void (*notify_func)(
+						uint64_t time,
+						struct libinput_event *event,
+						void *notify_func_data),
+				   void *notify_func_data);
+
+void
+libinput_device_remove_event_listener(struct libinput_event_listener *listener);
+
+void
+notify_added_device(struct libinput_device *device);
+
+void
+notify_removed_device(struct libinput_device *device);
+
+void
+keyboard_notify_key(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t key,
+		    enum libinput_key_state state);
+
+void
+pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw);
+
+void
+pointer_notify_motion_absolute(struct libinput_device *device,
+			       uint64_t time,
+			       const struct device_coords *point);
+
+void
+pointer_notify_button(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state);
+
+void
+pointer_notify_axis(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t axes,
+		    enum libinput_pointer_axis_source source,
+		    const struct normalized_coords *delta,
+		    const struct discrete_coords *discrete);
+
+void
+touch_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			const struct device_coords *point);
+
+void
+touch_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  const struct device_coords *point);
+
+void
+touch_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot);
+
+void
+touch_notify_frame(struct libinput_device *device,
+		   uint64_t time);
+
+void
+gesture_notify_swipe(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel);
+
+void
+gesture_notify_swipe_end(struct libinput_device *device,
+			 uint64_t time,
+			 int finger_count,
+			 int cancelled);
+
+void
+gesture_notify_pinch(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+		     double scale,
+		     double angle);
+
+void
+gesture_notify_pinch_end(struct libinput_device *device,
+			 uint64_t time,
+			 int finger_count,
+			 double scale,
+			 int cancelled);
+
+void
+tablet_notify_axis(struct libinput_device *device,
+		   uint64_t time,
+		   struct libinput_tablet_tool *tool,
+		   enum libinput_tablet_tool_tip_state tip_state,
+		   unsigned char *changed_axes,
+		   const struct tablet_axes *axes);
+
+void
+tablet_notify_proximity(struct libinput_device *device,
+			uint64_t time,
+			struct libinput_tablet_tool *tool,
+			enum libinput_tablet_tool_proximity_state state,
+			unsigned char *changed_axes,
+			const struct tablet_axes *axes);
+
+void
+tablet_notify_tip(struct libinput_device *device,
+		  uint64_t time,
+		  struct libinput_tablet_tool *tool,
+		  enum libinput_tablet_tool_tip_state tip_state,
+		  unsigned char *changed_axes,
+		  const struct tablet_axes *axes);
+
+void
+tablet_notify_button(struct libinput_device *device,
+		     uint64_t time,
+		     struct libinput_tablet_tool *tool,
+		     enum libinput_tablet_tool_tip_state tip_state,
+		     const struct tablet_axes *axes,
+		     int32_t button,
+		     enum libinput_button_state state);
+
+void
+tablet_pad_notify_button(struct libinput_device *device,
+			 uint64_t time,
+			 int32_t button,
+			 enum libinput_button_state state,
+			 struct libinput_tablet_pad_mode_group *group);
+void
+tablet_pad_notify_ring(struct libinput_device *device,
+		       uint64_t time,
+		       unsigned int number,
+		       double value,
+		       enum libinput_tablet_pad_ring_axis_source source,
+		       struct libinput_tablet_pad_mode_group *group);
+void
+tablet_pad_notify_strip(struct libinput_device *device,
+			uint64_t time,
+			unsigned int number,
+			double value,
+			enum libinput_tablet_pad_strip_axis_source source,
+			struct libinput_tablet_pad_mode_group *group);
+void
+switch_notify_toggle(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_switch sw,
+		     enum libinput_switch_state state);
+
+static inline uint64_t
+libinput_now(struct libinput *libinput)
+{
+	struct timespec ts = { 0, 0 };
+
+	if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
+		log_error(libinput, "clock_gettime failed: %s\n", strerror(errno));
+		return 0;
+	}
+
+	return s2us(ts.tv_sec) + ns2us(ts.tv_nsec);
+}
+
+static inline struct device_float_coords
+device_delta(struct device_coords a, struct device_coords b)
+{
+	struct device_float_coords delta;
+
+	delta.x = a.x - b.x;
+	delta.y = a.y - b.y;
+
+	return delta;
+}
+
+static inline struct device_float_coords
+device_average(struct device_coords a, struct device_coords b)
+{
+	struct device_float_coords average;
+
+	average.x = (a.x + b.x) / 2.0;
+	average.y = (a.y + b.y) / 2.0;
+
+	return average;
+}
+
+static inline struct device_float_coords
+device_float_delta(struct device_float_coords a, struct device_float_coords b)
+{
+	struct device_float_coords delta;
+
+	delta.x = a.x - b.x;
+	delta.y = a.y - b.y;
+
+	return delta;
+}
+
+static inline struct device_float_coords
+device_float_average(struct device_float_coords a, struct device_float_coords b)
+{
+	struct device_float_coords average;
+
+	average.x = (a.x + b.x) / 2.0;
+	average.y = (a.y + b.y) / 2.0;
+
+	return average;
+}
+
+static inline bool
+device_float_is_zero(struct device_float_coords coords)
+{
+	return coords.x == 0.0 && coords.y == 0.0;
+}
+
+static inline double
+normalized_length(struct normalized_coords norm)
+{
+	return hypot(norm.x, norm.y);
+}
+
+static inline bool
+normalized_is_zero(struct normalized_coords norm)
+{
+	return norm.x == 0.0 && norm.y == 0.0;
+}
+
+static inline double
+length_in_mm(struct phys_coords mm)
+{
+	return hypot(mm.x, mm.y);
+}
+
+enum directions {
+	N  = 1 << 0,
+	NE = 1 << 1,
+	E  = 1 << 2,
+	SE = 1 << 3,
+	S  = 1 << 4,
+	SW = 1 << 5,
+	W  = 1 << 6,
+	NW = 1 << 7,
+	UNDEFINED_DIRECTION = 0xff
+};
+
+static inline uint32_t
+xy_get_direction(double x, double y)
+{
+	uint32_t dir = UNDEFINED_DIRECTION;
+	int d1, d2;
+	double r;
+
+	if (fabs(x) < 2.0 && fabs(y) < 2.0) {
+		if (x > 0.0 && y > 0.0)
+			dir = S | SE | E;
+		else if (x > 0.0 && y < 0.0)
+			dir = N | NE | E;
+		else if (x < 0.0 && y > 0.0)
+			dir = S | SW | W;
+		else if (x < 0.0 && y < 0.0)
+			dir = N | NW | W;
+		else if (x > 0.0)
+			dir = NE | E | SE;
+		else if (x < 0.0)
+			dir = NW | W | SW;
+		else if (y > 0.0)
+			dir = SE | S | SW;
+		else if (y < 0.0)
+			dir = NE | N | NW;
+	} else {
+		/* Calculate r within the interval  [0 to 8)
+		 *
+		 * r = [0 .. 2π] where 0 is North
+		 * d_f = r / 2π  ([0 .. 1))
+		 * d_8 = 8 * d_f
+		 */
+		r = atan2(y, x);
+		r = fmod(r + 2.5*M_PI, 2*M_PI);
+		r *= 4*M_1_PI;
+
+		/* Mark one or two close enough octants */
+		d1 = (int)(r + 0.9) % 8;
+		d2 = (int)(r + 0.1) % 8;
+
+		dir = (1 << d1) | (1 << d2);
+	}
+
+	return dir;
+}
+
+static inline uint32_t
+phys_get_direction(struct phys_coords mm)
+{
+	return xy_get_direction(mm.x, mm.y);
+}
+
+/**
+ * Get the direction for the given set of coordinates.
+ * assumption: coordinates are normalized to one axis resolution.
+ */
+static inline uint32_t
+device_float_get_direction(struct device_float_coords coords)
+{
+	return xy_get_direction(coords.x, coords.y);
+}
+#endif /* LIBINPUT_PRIVATE_H */
--- libinput-1.10.7.orig/src/libinput.c
+++ libinput-1.10.7/src/libinput.c
@@ -135,6 +135,9 @@ event_type_to_str(enum libinput_event_ty
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_BEGIN);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_UPDATE);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_END);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_TAP_BEGIN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_TAP_UPDATE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_TAP_END);
 	CASE_RETURN_STRING(LIBINPUT_EVENT_SWITCH_TOGGLE);
 	case LIBINPUT_EVENT_NONE:
 		abort();
@@ -398,7 +401,10 @@ libinput_event_get_gesture_event(struct
 			   LIBINPUT_EVENT_GESTURE_SWIPE_END,
 			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+         LIBINPUT_EVENT_GESTURE_PINCH_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return (struct libinput_event_gesture *) event;
 }
@@ -884,7 +890,10 @@ libinput_event_gesture_get_time(struct l
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return us2ms(event->time);
 }
@@ -900,7 +909,10 @@ libinput_event_gesture_get_time_usec(str
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->time;
 }
@@ -916,7 +928,10 @@ libinput_event_gesture_get_finger_count(
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->finger_count;
 }
@@ -928,7 +943,8 @@ libinput_event_gesture_get_cancelled(str
 			   event->base.type,
 			   0,
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->cancelled;
 }
@@ -944,7 +960,10 @@ libinput_event_gesture_get_dx(struct lib
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->delta.x;
 }
@@ -960,7 +979,10 @@ libinput_event_gesture_get_dy(struct lib
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->delta.y;
 }
@@ -977,7 +999,10 @@ libinput_event_gesture_get_dx_unaccelera
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->delta_unaccel.x;
 }
@@ -994,7 +1019,10 @@ libinput_event_gesture_get_dy_unaccelera
 			   LIBINPUT_EVENT_GESTURE_PINCH_END,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+         LIBINPUT_EVENT_GESTURE_SWIPE_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return event->delta_unaccel.y;
 }
@@ -2696,6 +2724,29 @@ gesture_notify_pinch_end(struct libinput
 }
 
 void
+gesture_notify_tap(struct libinput_device *device,
+                   uint64_t time,
+                   enum libinput_event_type type,
+                   int finger_count,
+                   const struct normalized_coords *delta,
+                   const struct normalized_coords *unaccel)
+{
+    gesture_notify(device, time, type, finger_count, 0,
+                   delta, unaccel, 0.0, 0.0);
+}
+
+void
+gesture_notify_tap_end(struct libinput_device *device,
+                       uint64_t time,
+                       int finger_count,
+                       int cancelled)
+{
+    const struct normalized_coords zero = { 0.0, 0.0 };
+    gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_TAP_END,
+                   finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+}
+
+void
 switch_notify_toggle(struct libinput_device *device,
 		     uint64_t time,
 		     enum libinput_switch sw,
@@ -3140,7 +3191,10 @@ libinput_event_gesture_get_base_event(st
 			   LIBINPUT_EVENT_GESTURE_SWIPE_END,
 			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
 			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
-			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+         LIBINPUT_EVENT_GESTURE_PINCH_END,
+         LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+         LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+         LIBINPUT_EVENT_GESTURE_TAP_END);
 
 	return &event->base;
 }
--- /dev/null
+++ libinput-1.10.7/src/libinput.c.orig
@@ -0,0 +1,4062 @@
+/*
+ * Copyright © 2013 Jonas Ådahl
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/epoll.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include "libinput.h"
+#include "libinput-private.h"
+#include "evdev.h"
+#include "timer.h"
+
+#define require_event_type(li_, type_, retval_, ...)	\
+	if (type_ == LIBINPUT_EVENT_NONE) abort(); \
+	if (!check_event_type(li_, __func__, type_, __VA_ARGS__, -1)) \
+		return retval_; \
+
+#define ASSERT_INT_SIZE(type_) \
+	static_assert(sizeof(type_) == sizeof(unsigned int), \
+		      "sizeof("  #type_ ") must be sizeof(uint)")
+
+ASSERT_INT_SIZE(enum libinput_log_priority);
+ASSERT_INT_SIZE(enum libinput_device_capability);
+ASSERT_INT_SIZE(enum libinput_key_state);
+ASSERT_INT_SIZE(enum libinput_led);
+ASSERT_INT_SIZE(enum libinput_button_state);
+ASSERT_INT_SIZE(enum libinput_pointer_axis);
+ASSERT_INT_SIZE(enum libinput_pointer_axis_source);
+ASSERT_INT_SIZE(enum libinput_tablet_pad_ring_axis_source);
+ASSERT_INT_SIZE(enum libinput_tablet_pad_strip_axis_source);
+ASSERT_INT_SIZE(enum libinput_tablet_tool_type);
+ASSERT_INT_SIZE(enum libinput_tablet_tool_proximity_state);
+ASSERT_INT_SIZE(enum libinput_tablet_tool_tip_state);
+ASSERT_INT_SIZE(enum libinput_switch_state);
+ASSERT_INT_SIZE(enum libinput_switch);
+ASSERT_INT_SIZE(enum libinput_event_type);
+ASSERT_INT_SIZE(enum libinput_config_status);
+ASSERT_INT_SIZE(enum libinput_config_tap_state);
+ASSERT_INT_SIZE(enum libinput_config_tap_button_map);
+ASSERT_INT_SIZE(enum libinput_config_drag_state);
+ASSERT_INT_SIZE(enum libinput_config_drag_lock_state);
+ASSERT_INT_SIZE(enum libinput_config_send_events_mode);
+ASSERT_INT_SIZE(enum libinput_config_accel_profile);
+ASSERT_INT_SIZE(enum libinput_config_click_method);
+ASSERT_INT_SIZE(enum libinput_config_middle_emulation_state);
+ASSERT_INT_SIZE(enum libinput_config_scroll_method);
+ASSERT_INT_SIZE(enum libinput_config_dwt_state);
+
+static inline bool
+check_event_type(struct libinput *libinput,
+		 const char *function_name,
+		 unsigned int type_in,
+		 ...)
+{
+	bool rc = false;
+	va_list args;
+	unsigned int type_permitted;
+
+	va_start(args, type_in);
+	type_permitted = va_arg(args, unsigned int);
+
+	while (type_permitted != (unsigned int)-1) {
+		if (type_permitted == type_in) {
+			rc = true;
+			break;
+		}
+		type_permitted = va_arg(args, unsigned int);
+	}
+
+	va_end(args);
+
+	if (!rc)
+		log_bug_client(libinput,
+			       "Invalid event type %d passed to %s()\n",
+			       type_in, function_name);
+
+	return rc;
+}
+
+static inline const char *
+event_type_to_str(enum libinput_event_type type)
+{
+	switch(type) {
+	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_ADDED);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_DEVICE_REMOVED);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_KEYBOARD_KEY);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_BUTTON);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_POINTER_AXIS);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_DOWN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_UP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_MOTION);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_CANCEL);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TOUCH_FRAME);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_AXIS);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_TIP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_PAD_RING);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_TABLET_PAD_STRIP);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_SWIPE_END);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_BEGIN);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_UPDATE);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_GESTURE_PINCH_END);
+	CASE_RETURN_STRING(LIBINPUT_EVENT_SWITCH_TOGGLE);
+	case LIBINPUT_EVENT_NONE:
+		abort();
+	}
+
+	return NULL;
+}
+
+struct libinput_source {
+	libinput_source_dispatch_t dispatch;
+	void *user_data;
+	int fd;
+	struct list link;
+};
+
+struct libinput_event_device_notify {
+	struct libinput_event base;
+};
+
+struct libinput_event_keyboard {
+	struct libinput_event base;
+	uint64_t time;
+	uint32_t key;
+	uint32_t seat_key_count;
+	enum libinput_key_state state;
+};
+
+struct libinput_event_pointer {
+	struct libinput_event base;
+	uint64_t time;
+	struct normalized_coords delta;
+	struct device_float_coords delta_raw;
+	struct device_coords absolute;
+	struct discrete_coords discrete;
+	uint32_t button;
+	uint32_t seat_button_count;
+	enum libinput_button_state state;
+	enum libinput_pointer_axis_source source;
+	uint32_t axes;
+};
+
+struct libinput_event_touch {
+	struct libinput_event base;
+	uint64_t time;
+	int32_t slot;
+	int32_t seat_slot;
+	struct device_coords point;
+};
+
+struct libinput_event_gesture {
+	struct libinput_event base;
+	uint64_t time;
+	int finger_count;
+	int cancelled;
+	struct normalized_coords delta;
+	struct normalized_coords delta_unaccel;
+	double scale;
+	double angle;
+};
+
+struct libinput_event_tablet_tool {
+	struct libinput_event base;
+	uint32_t button;
+	enum libinput_button_state state;
+	uint32_t seat_button_count;
+	uint64_t time;
+	struct tablet_axes axes;
+	unsigned char changed_axes[NCHARS(LIBINPUT_TABLET_TOOL_AXIS_MAX + 1)];
+	struct libinput_tablet_tool *tool;
+	enum libinput_tablet_tool_proximity_state proximity_state;
+	enum libinput_tablet_tool_tip_state tip_state;
+};
+
+struct libinput_event_tablet_pad {
+	struct libinput_event base;
+	unsigned int mode;
+	struct libinput_tablet_pad_mode_group *mode_group;
+	uint64_t time;
+	struct {
+		uint32_t number;
+		enum libinput_button_state state;
+	} button;
+	struct {
+		enum libinput_tablet_pad_ring_axis_source source;
+		double position;
+		int number;
+	} ring;
+	struct {
+		enum libinput_tablet_pad_strip_axis_source source;
+		double position;
+		int number;
+	} strip;
+};
+
+struct libinput_event_switch {
+	struct libinput_event base;
+	uint64_t time;
+	enum libinput_switch sw;
+	enum libinput_switch_state state;
+};
+
+LIBINPUT_ATTRIBUTE_PRINTF(3, 0)
+static void
+libinput_default_log_func(struct libinput *libinput,
+			  enum libinput_log_priority priority,
+			  const char *format, va_list args)
+{
+	const char *prefix;
+
+	switch(priority) {
+	case LIBINPUT_LOG_PRIORITY_DEBUG: prefix = "debug"; break;
+	case LIBINPUT_LOG_PRIORITY_INFO: prefix = "info"; break;
+	case LIBINPUT_LOG_PRIORITY_ERROR: prefix = "error"; break;
+	default: prefix="<invalid priority>"; break;
+	}
+
+	fprintf(stderr, "libinput %s: ", prefix);
+	vfprintf(stderr, format, args);
+}
+
+void
+log_msg_va(struct libinput *libinput,
+	   enum libinput_log_priority priority,
+	   const char *format,
+	   va_list args)
+{
+	if (libinput->log_handler &&
+	    libinput->log_priority <= priority)
+		libinput->log_handler(libinput, priority, format, args);
+}
+
+void
+log_msg(struct libinput *libinput,
+	enum libinput_log_priority priority,
+	const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+	log_msg_va(libinput, priority, format, args);
+	va_end(args);
+}
+
+void
+log_msg_ratelimit(struct libinput *libinput,
+		  struct ratelimit *ratelimit,
+		  enum libinput_log_priority priority,
+		  const char *format, ...)
+{
+	va_list args;
+	enum ratelimit_state state;
+
+	state = ratelimit_test(ratelimit);
+	if (state == RATELIMIT_EXCEEDED)
+		return;
+
+	va_start(args, format);
+	log_msg_va(libinput, priority, format, args);
+	va_end(args);
+
+	if (state == RATELIMIT_THRESHOLD)
+		log_msg(libinput,
+			priority,
+			"WARNING: log rate limit exceeded (%d msgs per %dms). Discarding future messages.\n",
+			ratelimit->burst,
+			us2ms(ratelimit->interval));
+}
+
+LIBINPUT_EXPORT void
+libinput_log_set_priority(struct libinput *libinput,
+			  enum libinput_log_priority priority)
+{
+	libinput->log_priority = priority;
+}
+
+LIBINPUT_EXPORT enum libinput_log_priority
+libinput_log_get_priority(const struct libinput *libinput)
+{
+	return libinput->log_priority;
+}
+
+LIBINPUT_EXPORT void
+libinput_log_set_handler(struct libinput *libinput,
+			 libinput_log_handler log_handler)
+{
+	libinput->log_handler = log_handler;
+}
+
+static void
+libinput_device_group_destroy(struct libinput_device_group *group);
+
+static void
+libinput_post_event(struct libinput *libinput,
+		    struct libinput_event *event);
+
+LIBINPUT_EXPORT enum libinput_event_type
+libinput_event_get_type(struct libinput_event *event)
+{
+	return event->type;
+}
+
+LIBINPUT_EXPORT struct libinput *
+libinput_event_get_context(struct libinput_event *event)
+{
+	return event->device->seat->libinput;
+}
+
+LIBINPUT_EXPORT struct libinput_device *
+libinput_event_get_device(struct libinput_event *event)
+{
+	return event->device;
+}
+
+LIBINPUT_EXPORT struct libinput_event_pointer *
+libinput_event_get_pointer_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	return (struct libinput_event_pointer *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_keyboard *
+libinput_event_get_keyboard_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return (struct libinput_event_keyboard *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_touch *
+libinput_event_get_touch_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL,
+			   LIBINPUT_EVENT_TOUCH_FRAME);
+	return (struct libinput_event_touch *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_gesture *
+libinput_event_get_gesture_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+
+	return (struct libinput_event_gesture *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_tablet_tool *
+libinput_event_get_tablet_tool_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+
+	return (struct libinput_event_tablet_tool *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_tablet_pad *
+libinput_event_get_tablet_pad_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return (struct libinput_event_tablet_pad *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_device_notify *
+libinput_event_get_device_notify_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_DEVICE_ADDED,
+			   LIBINPUT_EVENT_DEVICE_REMOVED);
+
+	return (struct libinput_event_device_notify *) event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_switch *
+libinput_event_get_switch_event(struct libinput_event *event)
+{
+	require_event_type(libinput_event_get_context(event),
+			   event->type,
+			   NULL,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return (struct libinput_event_switch *) event;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_keyboard_get_time(struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_keyboard_get_time_usec(struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_keyboard_get_key(struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return event->key;
+}
+
+LIBINPUT_EXPORT enum libinput_key_state
+libinput_event_keyboard_get_key_state(struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_keyboard_get_seat_key_count(
+	struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return event->seat_key_count;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_time(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_pointer_get_time_usec(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_dx(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION);
+
+	return event->delta.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_dy(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION);
+
+	return event->delta.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_dx_unaccelerated(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION);
+
+	return event->delta_raw.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_dy_unaccelerated(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION);
+
+	return event->delta_raw.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_absolute_x(struct libinput_event_pointer *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->absolute.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_absolute_y(struct libinput_event_pointer *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->absolute.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_absolute_x_transformed(
+	struct libinput_event_pointer *event,
+	uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
+
+	return evdev_device_transform_x(device, event->absolute.x, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_absolute_y_transformed(
+	struct libinput_event_pointer *event,
+	uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE);
+
+	return evdev_device_transform_y(device, event->absolute.y, height);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_button(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return event->button;
+}
+
+LIBINPUT_EXPORT enum libinput_button_state
+libinput_event_pointer_get_button_state(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_pointer_get_seat_button_count(
+	struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return event->seat_button_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_pointer_has_axis(struct libinput_event_pointer *event,
+				enum libinput_pointer_axis axis)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	switch (axis) {
+	case LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL:
+	case LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL:
+		return !!(event->axes & AS_MASK(axis));
+	}
+
+	return 0;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_axis_value(struct libinput_event_pointer *event,
+				      enum libinput_pointer_axis axis)
+{
+	struct libinput *libinput = event->base.device->seat->libinput;
+	double value = 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	if (!libinput_event_pointer_has_axis(event, axis)) {
+		log_bug_client(libinput, "value requested for unset axis\n");
+	} else {
+		switch (axis) {
+		case LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL:
+			value = event->delta.x;
+			break;
+		case LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL:
+			value = event->delta.y;
+			break;
+		}
+	}
+
+	return value;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_pointer_get_axis_value_discrete(struct libinput_event_pointer *event,
+					       enum libinput_pointer_axis axis)
+{
+	struct libinput *libinput = event->base.device->seat->libinput;
+	double value = 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	if (!libinput_event_pointer_has_axis(event, axis)) {
+		log_bug_client(libinput, "value requested for unset axis\n");
+	} else {
+		switch (axis) {
+		case LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL:
+			value = event->discrete.x;
+			break;
+		case LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL:
+			value = event->discrete.y;
+			break;
+		}
+	}
+	return value;
+}
+
+LIBINPUT_EXPORT enum libinput_pointer_axis_source
+libinput_event_pointer_get_axis_source(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	return event->source;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_touch_get_time(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL,
+			   LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_touch_get_time_usec(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL,
+			   LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL);
+
+	return event->slot;
+}
+
+LIBINPUT_EXPORT int32_t
+libinput_event_touch_get_seat_slot(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL);
+
+	return event->seat_slot;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_x(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x, event->point.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_x(device, event->point.x, width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_device_transform_y(device, event->point.y, height);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_touch_get_y(struct libinput_event_touch *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_MOTION);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y, event->point.y);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_gesture_get_time(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_gesture_get_time_usec(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_gesture_get_finger_count(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->finger_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_gesture_get_cancelled(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->cancelled;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_dx(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->delta.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_dy(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->delta.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_dx_unaccelerated(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->delta_unaccel.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_dy_unaccelerated(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END);
+
+	return event->delta_unaccel.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_scale(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+
+	return event->scale;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+
+	return event->angle;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_x_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_X);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_y_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_Y);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_pressure_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_PRESSURE);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_distance_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_DISTANCE);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_tilt_x_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_TILT_X);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_tilt_y_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_TILT_Y);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_rotation_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_ROTATION_Z);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_slider_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_SLIDER);
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_wheel_has_changed(
+				struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return bit_is_set(event->changed_axes,
+			  LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_x(struct libinput_event_tablet_tool *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return evdev_convert_to_mm(device->abs.absinfo_x,
+				   event->axes.point.x);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_y(struct libinput_event_tablet_tool *event)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return evdev_convert_to_mm(device->abs.absinfo_y,
+				   event->axes.point.y);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_dx(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.delta.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_dy(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.delta.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_pressure(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.pressure;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_distance(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.distance;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_tilt_x(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.tilt.x;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_tilt_y(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.tilt.y;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_rotation(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.rotation;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_slider_position(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.slider;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_wheel_delta(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.wheel;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_tablet_tool_get_wheel_delta_discrete(
+				      struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->axes.wheel_discrete;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_x_transformed(struct libinput_event_tablet_tool *event,
+					uint32_t width)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return evdev_device_transform_x(device,
+					event->axes.point.x,
+					width);
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_tool_get_y_transformed(struct libinput_event_tablet_tool *event,
+					uint32_t height)
+{
+	struct evdev_device *device = evdev_device(event->base.device);
+
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return evdev_device_transform_y(device,
+					event->axes.point.y,
+					height);
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_tool *
+libinput_event_tablet_tool_get_tool(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->tool;
+}
+
+LIBINPUT_EXPORT enum libinput_tablet_tool_proximity_state
+libinput_event_tablet_tool_get_proximity_state(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->proximity_state;
+}
+
+LIBINPUT_EXPORT enum libinput_tablet_tool_tip_state
+libinput_event_tablet_tool_get_tip_state(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->tip_state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_tablet_tool_get_time(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_tablet_tool_get_time_usec(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_tablet_tool_get_button(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+
+	return event->button;
+}
+
+LIBINPUT_EXPORT enum libinput_button_state
+libinput_event_tablet_tool_get_button_state(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_tablet_tool_get_seat_button_count(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+
+	return event->seat_button_count;
+}
+
+LIBINPUT_EXPORT enum libinput_tablet_tool_type
+libinput_tablet_tool_get_type(struct libinput_tablet_tool *tool)
+{
+	return tool->type;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_tablet_tool_get_tool_id(struct libinput_tablet_tool *tool)
+{
+	return tool->tool_id;
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_is_unique(struct libinput_tablet_tool *tool)
+{
+	return tool->serial != 0;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_tablet_tool_get_serial(struct libinput_tablet_tool *tool)
+{
+	return tool->serial;
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_pressure(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_PRESSURE);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_distance(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_DISTANCE);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_tilt(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_TILT_X);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_rotation(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_ROTATION_Z);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_slider(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_SLIDER);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_wheel(struct libinput_tablet_tool *tool)
+{
+	return bit_is_set(tool->axis_caps,
+			  LIBINPUT_TABLET_TOOL_AXIS_REL_WHEEL);
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_tool_has_button(struct libinput_tablet_tool *tool,
+				uint32_t code)
+{
+	if (NCHARS(code) > sizeof(tool->buttons))
+		return 0;
+
+	return bit_is_set(tool->buttons, code);
+}
+
+LIBINPUT_EXPORT void
+libinput_tablet_tool_set_user_data(struct libinput_tablet_tool *tool,
+				   void *user_data)
+{
+	tool->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_tablet_tool_get_user_data(struct libinput_tablet_tool *tool)
+{
+	return tool->user_data;
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_tool *
+libinput_tablet_tool_ref(struct libinput_tablet_tool *tool)
+{
+	tool->refcount++;
+	return tool;
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_tool *
+libinput_tablet_tool_unref(struct libinput_tablet_tool *tool)
+{
+	assert(tool->refcount > 0);
+
+	tool->refcount--;
+	if (tool->refcount > 0)
+		return tool;
+
+	list_remove(&tool->link);
+	free(tool);
+	return NULL;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_switch_get_base_event(struct libinput_event_switch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT enum libinput_switch
+libinput_event_switch_get_switch(struct libinput_event_switch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return event->sw;
+}
+
+LIBINPUT_EXPORT enum libinput_switch_state
+libinput_event_switch_get_switch_state(struct libinput_event_switch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_switch_get_time(struct libinput_event_switch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_switch_get_time_usec(struct libinput_event_switch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_SWITCH_TOGGLE);
+
+	return event->time;
+}
+
+struct libinput_source *
+libinput_add_fd(struct libinput *libinput,
+		int fd,
+		libinput_source_dispatch_t dispatch,
+		void *user_data)
+{
+	struct libinput_source *source;
+	struct epoll_event ep;
+
+	source = zalloc(sizeof *source);
+	source->dispatch = dispatch;
+	source->user_data = user_data;
+	source->fd = fd;
+
+	memset(&ep, 0, sizeof ep);
+	ep.events = EPOLLIN;
+	ep.data.ptr = source;
+
+	if (epoll_ctl(libinput->epoll_fd, EPOLL_CTL_ADD, fd, &ep) < 0) {
+		free(source);
+		return NULL;
+	}
+
+	return source;
+}
+
+void
+libinput_remove_source(struct libinput *libinput,
+		       struct libinput_source *source)
+{
+	epoll_ctl(libinput->epoll_fd, EPOLL_CTL_DEL, source->fd, NULL);
+	source->fd = -1;
+	list_insert(&libinput->source_destroy_list, &source->link);
+}
+
+int
+libinput_init(struct libinput *libinput,
+	      const struct libinput_interface *interface,
+	      const struct libinput_interface_backend *interface_backend,
+	      void *user_data)
+{
+	assert(interface->open_restricted != NULL);
+	assert(interface->close_restricted != NULL);
+
+	libinput->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
+	if (libinput->epoll_fd < 0)
+		return -1;
+
+	libinput->events_len = 4;
+	libinput->events = zalloc(libinput->events_len * sizeof(*libinput->events));
+	libinput->log_handler = libinput_default_log_func;
+	libinput->log_priority = LIBINPUT_LOG_PRIORITY_ERROR;
+	libinput->interface = interface;
+	libinput->interface_backend = interface_backend;
+	libinput->user_data = user_data;
+	libinput->refcount = 1;
+	list_init(&libinput->source_destroy_list);
+	list_init(&libinput->seat_list);
+	list_init(&libinput->device_group_list);
+	list_init(&libinput->tool_list);
+
+	if (libinput_timer_subsys_init(libinput) != 0) {
+		free(libinput->events);
+		close(libinput->epoll_fd);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+libinput_device_destroy(struct libinput_device *device);
+
+static void
+libinput_seat_destroy(struct libinput_seat *seat);
+
+static void
+libinput_drop_destroyed_sources(struct libinput *libinput)
+{
+	struct libinput_source *source, *next;
+
+	list_for_each_safe(source, next, &libinput->source_destroy_list, link)
+		free(source);
+	list_init(&libinput->source_destroy_list);
+}
+
+LIBINPUT_EXPORT struct libinput *
+libinput_ref(struct libinput *libinput)
+{
+	libinput->refcount++;
+	return libinput;
+}
+
+LIBINPUT_EXPORT struct libinput *
+libinput_unref(struct libinput *libinput)
+{
+	struct libinput_event *event;
+	struct libinput_device *device, *next_device;
+	struct libinput_seat *seat, *next_seat;
+	struct libinput_tablet_tool *tool, *next_tool;
+	struct libinput_device_group *group, *next_group;
+
+	if (libinput == NULL)
+		return NULL;
+
+	assert(libinput->refcount > 0);
+	libinput->refcount--;
+	if (libinput->refcount > 0)
+		return libinput;
+
+	libinput_suspend(libinput);
+
+	libinput->interface_backend->destroy(libinput);
+
+	while ((event = libinput_get_event(libinput)))
+	       libinput_event_destroy(event);
+
+	free(libinput->events);
+
+	list_for_each_safe(seat, next_seat, &libinput->seat_list, link) {
+		list_for_each_safe(device, next_device,
+				   &seat->devices_list,
+				   link)
+			libinput_device_destroy(device);
+
+		libinput_seat_destroy(seat);
+	}
+
+	list_for_each_safe(group,
+			   next_group,
+			   &libinput->device_group_list,
+			   link) {
+		libinput_device_group_destroy(group);
+	}
+
+	list_for_each_safe(tool, next_tool, &libinput->tool_list, link) {
+		libinput_tablet_tool_unref(tool);
+	}
+
+	libinput_timer_subsys_destroy(libinput);
+	libinput_drop_destroyed_sources(libinput);
+	close(libinput->epoll_fd);
+	free(libinput);
+
+	return NULL;
+}
+
+static void
+libinput_event_tablet_tool_destroy(struct libinput_event_tablet_tool *event)
+{
+	libinput_tablet_tool_unref(event->tool);
+}
+
+static void
+libinput_event_tablet_pad_destroy(struct libinput_event_tablet_pad *event)
+{
+	libinput_tablet_pad_mode_group_unref(event->mode_group);
+}
+
+LIBINPUT_EXPORT void
+libinput_event_destroy(struct libinput_event *event)
+{
+	if (event == NULL)
+		return;
+
+	switch(event->type) {
+	case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+	case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+	case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+		libinput_event_tablet_tool_destroy(
+		   libinput_event_get_tablet_tool_event(event));
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_RING:
+	case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+	case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+		libinput_event_tablet_pad_destroy(
+		   libinput_event_get_tablet_pad_event(event));
+		break;
+	default:
+		break;
+	}
+
+	if (event->device)
+		libinput_device_unref(event->device);
+
+	free(event);
+}
+
+int
+open_restricted(struct libinput *libinput,
+		const char *path, int flags)
+{
+	return libinput->interface->open_restricted(path,
+						    flags,
+						    libinput->user_data);
+}
+
+void
+close_restricted(struct libinput *libinput, int fd)
+{
+	return libinput->interface->close_restricted(fd, libinput->user_data);
+}
+
+bool
+ignore_litest_test_suite_device(struct udev_device *device)
+{
+	if (!getenv("LIBINPUT_RUNNING_TEST_SUITE") &&
+	    udev_device_get_property_value(device, "LIBINPUT_TEST_DEVICE"))
+		return true;
+
+	return false;
+}
+
+void
+libinput_seat_init(struct libinput_seat *seat,
+		   struct libinput *libinput,
+		   const char *physical_name,
+		   const char *logical_name,
+		   libinput_seat_destroy_func destroy)
+{
+	seat->refcount = 1;
+	seat->libinput = libinput;
+	seat->physical_name = safe_strdup(physical_name);
+	seat->logical_name = safe_strdup(logical_name);
+	seat->destroy = destroy;
+	list_init(&seat->devices_list);
+	list_insert(&libinput->seat_list, &seat->link);
+}
+
+LIBINPUT_EXPORT struct libinput_seat *
+libinput_seat_ref(struct libinput_seat *seat)
+{
+	seat->refcount++;
+	return seat;
+}
+
+static void
+libinput_seat_destroy(struct libinput_seat *seat)
+{
+	list_remove(&seat->link);
+	free(seat->logical_name);
+	free(seat->physical_name);
+	seat->destroy(seat);
+}
+
+LIBINPUT_EXPORT struct libinput_seat *
+libinput_seat_unref(struct libinput_seat *seat)
+{
+	assert(seat->refcount > 0);
+	seat->refcount--;
+	if (seat->refcount == 0) {
+		libinput_seat_destroy(seat);
+		return NULL;
+	} else {
+		return seat;
+	}
+}
+
+LIBINPUT_EXPORT void
+libinput_seat_set_user_data(struct libinput_seat *seat, void *user_data)
+{
+	seat->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_seat_get_user_data(struct libinput_seat *seat)
+{
+	return seat->user_data;
+}
+
+LIBINPUT_EXPORT struct libinput *
+libinput_seat_get_context(struct libinput_seat *seat)
+{
+	return seat->libinput;
+}
+
+LIBINPUT_EXPORT const char *
+libinput_seat_get_physical_name(struct libinput_seat *seat)
+{
+	return seat->physical_name;
+}
+
+LIBINPUT_EXPORT const char *
+libinput_seat_get_logical_name(struct libinput_seat *seat)
+{
+	return seat->logical_name;
+}
+
+void
+libinput_device_init(struct libinput_device *device,
+		     struct libinput_seat *seat)
+{
+	device->seat = seat;
+	device->refcount = 1;
+	list_init(&device->event_listeners);
+}
+
+LIBINPUT_EXPORT struct libinput_device *
+libinput_device_ref(struct libinput_device *device)
+{
+	device->refcount++;
+	return device;
+}
+
+static void
+libinput_device_destroy(struct libinput_device *device)
+{
+	assert(list_empty(&device->event_listeners));
+	evdev_device_destroy(evdev_device(device));
+}
+
+LIBINPUT_EXPORT struct libinput_device *
+libinput_device_unref(struct libinput_device *device)
+{
+	assert(device->refcount > 0);
+	device->refcount--;
+	if (device->refcount == 0) {
+		libinput_device_destroy(device);
+		return NULL;
+	} else {
+		return device;
+	}
+}
+
+LIBINPUT_EXPORT int
+libinput_get_fd(struct libinput *libinput)
+{
+	return libinput->epoll_fd;
+}
+
+LIBINPUT_EXPORT int
+libinput_dispatch(struct libinput *libinput)
+{
+	struct libinput_source *source;
+	struct epoll_event ep[32];
+	int i, count;
+
+	count = epoll_wait(libinput->epoll_fd, ep, ARRAY_LENGTH(ep), 0);
+	if (count < 0)
+		return -errno;
+
+	for (i = 0; i < count; ++i) {
+		source = ep[i].data.ptr;
+		if (source->fd == -1)
+			continue;
+
+		source->dispatch(source->user_data);
+	}
+
+	libinput_drop_destroyed_sources(libinput);
+
+	return 0;
+}
+
+void
+libinput_device_init_event_listener(struct libinput_event_listener *listener)
+{
+	list_init(&listener->link);
+}
+
+void
+libinput_device_add_event_listener(struct libinput_device *device,
+				   struct libinput_event_listener *listener,
+				   void (*notify_func)(
+						uint64_t time,
+						struct libinput_event *event,
+						void *notify_func_data),
+				   void *notify_func_data)
+{
+	listener->notify_func = notify_func;
+	listener->notify_func_data = notify_func_data;
+	list_insert(&device->event_listeners, &listener->link);
+}
+
+void
+libinput_device_remove_event_listener(struct libinput_event_listener *listener)
+{
+	list_remove(&listener->link);
+}
+
+static uint32_t
+update_seat_key_count(struct libinput_seat *seat,
+		      int32_t key,
+		      enum libinput_key_state state)
+{
+	assert(key >= 0 && key <= KEY_MAX);
+
+	switch (state) {
+	case LIBINPUT_KEY_STATE_PRESSED:
+		return ++seat->button_count[key];
+	case LIBINPUT_KEY_STATE_RELEASED:
+		/* We might not have received the first PRESSED event. */
+		if (seat->button_count[key] == 0)
+			return 0;
+
+		return --seat->button_count[key];
+	}
+
+	return 0;
+}
+
+static uint32_t
+update_seat_button_count(struct libinput_seat *seat,
+			 int32_t button,
+			 enum libinput_button_state state)
+{
+	assert(button >= 0 && button <= KEY_MAX);
+
+	switch (state) {
+	case LIBINPUT_BUTTON_STATE_PRESSED:
+		return ++seat->button_count[button];
+	case LIBINPUT_BUTTON_STATE_RELEASED:
+		/* We might not have received the first PRESSED event. */
+		if (seat->button_count[button] == 0)
+			return 0;
+
+		return --seat->button_count[button];
+	}
+
+	return 0;
+}
+
+static void
+init_event_base(struct libinput_event *event,
+		struct libinput_device *device,
+		enum libinput_event_type type)
+{
+	event->type = type;
+	event->device = device;
+}
+
+static void
+post_base_event(struct libinput_device *device,
+		enum libinput_event_type type,
+		struct libinput_event *event)
+{
+	struct libinput *libinput = device->seat->libinput;
+	init_event_base(event, device, type);
+	libinput_post_event(libinput, event);
+}
+
+static void
+post_device_event(struct libinput_device *device,
+		  uint64_t time,
+		  enum libinput_event_type type,
+		  struct libinput_event *event)
+{
+	struct libinput_event_listener *listener, *tmp;
+#if 0
+	struct libinput *libinput = device->seat->libinput;
+
+	if (libinput->last_event_time > time) {
+		log_bug_libinput(device->seat->libinput,
+				 "out-of-order timestamps for %s time %" PRIu64 "\n",
+				 event_type_to_str(type),
+				 time);
+	}
+	libinput->last_event_time = time;
+#endif
+
+	init_event_base(event, device, type);
+
+	list_for_each_safe(listener, tmp, &device->event_listeners, link)
+		listener->notify_func(time, event, listener->notify_func_data);
+
+	libinput_post_event(device->seat->libinput, event);
+}
+
+void
+notify_added_device(struct libinput_device *device)
+{
+	struct libinput_event_device_notify *added_device_event;
+
+	added_device_event = zalloc(sizeof *added_device_event);
+
+	post_base_event(device,
+			LIBINPUT_EVENT_DEVICE_ADDED,
+			&added_device_event->base);
+}
+
+void
+notify_removed_device(struct libinput_device *device)
+{
+	struct libinput_event_device_notify *removed_device_event;
+
+	removed_device_event = zalloc(sizeof *removed_device_event);
+
+	post_base_event(device,
+			LIBINPUT_EVENT_DEVICE_REMOVED,
+			&removed_device_event->base);
+}
+
+static inline bool
+device_has_cap(struct libinput_device *device,
+	       enum libinput_device_capability cap)
+{
+	const char *capability;
+
+	if (libinput_device_has_capability(device, cap))
+		return true;
+
+	switch (cap) {
+	case LIBINPUT_DEVICE_CAP_POINTER:
+		capability = "CAP_POINTER";
+		break;
+	case LIBINPUT_DEVICE_CAP_KEYBOARD:
+		capability = "CAP_KEYBOARD";
+		break;
+	case LIBINPUT_DEVICE_CAP_TOUCH:
+		capability = "CAP_TOUCH";
+		break;
+	case LIBINPUT_DEVICE_CAP_GESTURE:
+		capability = "CAP_GESTURE";
+		break;
+	case LIBINPUT_DEVICE_CAP_TABLET_TOOL:
+		capability = "CAP_TABLET_TOOL";
+		break;
+	case LIBINPUT_DEVICE_CAP_TABLET_PAD:
+		capability = "CAP_TABLET_PAD";
+		break;
+	case LIBINPUT_DEVICE_CAP_SWITCH:
+		capability = "CAP_SWITCH";
+		break;
+	}
+
+	log_bug_libinput(device->seat->libinput,
+			 "Event for missing capability %s on device \"%s\"\n",
+			 capability,
+			 libinput_device_get_name(device));
+
+	return false;
+}
+
+void
+keyboard_notify_key(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t key,
+		    enum libinput_key_state state)
+{
+	struct libinput_event_keyboard *key_event;
+	uint32_t seat_key_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_KEYBOARD))
+		return;
+
+	key_event = zalloc(sizeof *key_event);
+
+	seat_key_count = update_seat_key_count(device->seat, key, state);
+
+	*key_event = (struct libinput_event_keyboard) {
+		.time = time,
+		.key = key,
+		.state = state,
+		.seat_key_count = seat_key_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_KEYBOARD_KEY,
+			  &key_event->base);
+}
+
+void
+pointer_notify_motion(struct libinput_device *device,
+		      uint64_t time,
+		      const struct normalized_coords *delta,
+		      const struct device_float_coords *raw)
+{
+	struct libinput_event_pointer *motion_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	motion_event = zalloc(sizeof *motion_event);
+
+	*motion_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.delta_raw = *raw,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_MOTION,
+			  &motion_event->base);
+}
+
+void
+pointer_notify_motion_absolute(struct libinput_device *device,
+			       uint64_t time,
+			       const struct device_coords *point)
+{
+	struct libinput_event_pointer *motion_absolute_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	motion_absolute_event = zalloc(sizeof *motion_absolute_event);
+
+	*motion_absolute_event = (struct libinput_event_pointer) {
+		.time = time,
+		.absolute = *point,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+			  &motion_absolute_event->base);
+}
+
+void
+pointer_notify_button(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t button,
+		      enum libinput_button_state state)
+{
+	struct libinput_event_pointer *button_event;
+	int32_t seat_button_count;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_pointer) {
+		.time = time,
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_BUTTON,
+			  &button_event->base);
+}
+
+void
+pointer_notify_axis(struct libinput_device *device,
+		    uint64_t time,
+		    uint32_t axes,
+		    enum libinput_pointer_axis_source source,
+		    const struct normalized_coords *delta,
+		    const struct discrete_coords *discrete)
+{
+	struct libinput_event_pointer *axis_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_POINTER))
+		return;
+
+	axis_event = zalloc(sizeof *axis_event);
+
+	*axis_event = (struct libinput_event_pointer) {
+		.time = time,
+		.delta = *delta,
+		.source = source,
+		.axes = axes,
+		.discrete = *discrete,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_POINTER_AXIS,
+			  &axis_event->base);
+}
+
+void
+touch_notify_touch_down(struct libinput_device *device,
+			uint64_t time,
+			int32_t slot,
+			int32_t seat_slot,
+			const struct device_coords *point)
+{
+	struct libinput_event_touch *touch_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_TOUCH))
+		return;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCH_DOWN,
+			  &touch_event->base);
+}
+
+void
+touch_notify_touch_motion(struct libinput_device *device,
+			  uint64_t time,
+			  int32_t slot,
+			  int32_t seat_slot,
+			  const struct device_coords *point)
+{
+	struct libinput_event_touch *touch_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_TOUCH))
+		return;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+		.point = *point,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCH_MOTION,
+			  &touch_event->base);
+}
+
+void
+touch_notify_touch_up(struct libinput_device *device,
+		      uint64_t time,
+		      int32_t slot,
+		      int32_t seat_slot)
+{
+	struct libinput_event_touch *touch_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_TOUCH))
+		return;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+		.slot = slot,
+		.seat_slot = seat_slot,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCH_UP,
+			  &touch_event->base);
+}
+
+void
+touch_notify_frame(struct libinput_device *device,
+		   uint64_t time)
+{
+	struct libinput_event_touch *touch_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_TOUCH))
+		return;
+
+	touch_event = zalloc(sizeof *touch_event);
+
+	*touch_event = (struct libinput_event_touch) {
+		.time = time,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_TOUCH_FRAME,
+			  &touch_event->base);
+}
+
+void
+tablet_notify_axis(struct libinput_device *device,
+		   uint64_t time,
+		   struct libinput_tablet_tool *tool,
+		   enum libinput_tablet_tool_tip_state tip_state,
+		   unsigned char *changed_axes,
+		   const struct tablet_axes *axes)
+{
+	struct libinput_event_tablet_tool *axis_event;
+
+	axis_event = zalloc(sizeof *axis_event);
+
+	*axis_event = (struct libinput_event_tablet_tool) {
+		.time = time,
+		.tool = libinput_tablet_tool_ref(tool),
+		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
+		.tip_state = tip_state,
+		.axes = *axes,
+	};
+
+	memcpy(axis_event->changed_axes,
+	       changed_axes,
+	       sizeof(axis_event->changed_axes));
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			  &axis_event->base);
+}
+
+void
+tablet_notify_proximity(struct libinput_device *device,
+			uint64_t time,
+			struct libinput_tablet_tool *tool,
+			enum libinput_tablet_tool_proximity_state proximity_state,
+			unsigned char *changed_axes,
+			const struct tablet_axes *axes)
+{
+	struct libinput_event_tablet_tool *proximity_event;
+
+	proximity_event = zalloc(sizeof *proximity_event);
+
+	*proximity_event = (struct libinput_event_tablet_tool) {
+		.time = time,
+		.tool = libinput_tablet_tool_ref(tool),
+		.tip_state = LIBINPUT_TABLET_TOOL_TIP_UP,
+		.proximity_state = proximity_state,
+		.axes = *axes,
+	};
+	memcpy(proximity_event->changed_axes,
+	       changed_axes,
+	       sizeof(proximity_event->changed_axes));
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+			  &proximity_event->base);
+}
+
+void
+tablet_notify_tip(struct libinput_device *device,
+		  uint64_t time,
+		  struct libinput_tablet_tool *tool,
+		  enum libinput_tablet_tool_tip_state tip_state,
+		  unsigned char *changed_axes,
+		  const struct tablet_axes *axes)
+{
+	struct libinput_event_tablet_tool *tip_event;
+
+	tip_event = zalloc(sizeof *tip_event);
+
+	*tip_event = (struct libinput_event_tablet_tool) {
+		.time = time,
+		.tool = libinput_tablet_tool_ref(tool),
+		.tip_state = tip_state,
+		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
+		.axes = *axes,
+	};
+	memcpy(tip_event->changed_axes,
+	       changed_axes,
+	       sizeof(tip_event->changed_axes));
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			  &tip_event->base);
+}
+
+void
+tablet_notify_button(struct libinput_device *device,
+		     uint64_t time,
+		     struct libinput_tablet_tool *tool,
+		     enum libinput_tablet_tool_tip_state tip_state,
+		     const struct tablet_axes *axes,
+		     int32_t button,
+		     enum libinput_button_state state)
+{
+	struct libinput_event_tablet_tool *button_event;
+	int32_t seat_button_count;
+
+	button_event = zalloc(sizeof *button_event);
+
+	seat_button_count = update_seat_button_count(device->seat,
+						     button,
+						     state);
+
+	*button_event = (struct libinput_event_tablet_tool) {
+		.time = time,
+		.tool = libinput_tablet_tool_ref(tool),
+		.button = button,
+		.state = state,
+		.seat_button_count = seat_button_count,
+		.proximity_state = LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN,
+		.tip_state = tip_state,
+		.axes = *axes,
+	};
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+			  &button_event->base);
+}
+
+void
+tablet_pad_notify_button(struct libinput_device *device,
+			 uint64_t time,
+			 int32_t button,
+			 enum libinput_button_state state,
+			 struct libinput_tablet_pad_mode_group *group)
+{
+	struct libinput_event_tablet_pad *button_event;
+	unsigned int mode;
+
+	button_event = zalloc(sizeof *button_event);
+
+	mode = libinput_tablet_pad_mode_group_get_mode(group);
+
+	*button_event = (struct libinput_event_tablet_pad) {
+		.time = time,
+		.button.number = button,
+		.button.state = state,
+		.mode_group = libinput_tablet_pad_mode_group_ref(group),
+		.mode = mode,
+	};
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_PAD_BUTTON,
+			  &button_event->base);
+}
+
+void
+tablet_pad_notify_ring(struct libinput_device *device,
+		       uint64_t time,
+		       unsigned int number,
+		       double value,
+		       enum libinput_tablet_pad_ring_axis_source source,
+		       struct libinput_tablet_pad_mode_group *group)
+{
+	struct libinput_event_tablet_pad *ring_event;
+	unsigned int mode;
+
+	ring_event = zalloc(sizeof *ring_event);
+
+	mode = libinput_tablet_pad_mode_group_get_mode(group);
+
+	*ring_event = (struct libinput_event_tablet_pad) {
+		.time = time,
+		.ring.number = number,
+		.ring.position = value,
+		.ring.source = source,
+		.mode_group = libinput_tablet_pad_mode_group_ref(group),
+		.mode = mode,
+	};
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_PAD_RING,
+			  &ring_event->base);
+}
+
+void
+tablet_pad_notify_strip(struct libinput_device *device,
+			uint64_t time,
+			unsigned int number,
+			double value,
+			enum libinput_tablet_pad_strip_axis_source source,
+			struct libinput_tablet_pad_mode_group *group)
+{
+	struct libinput_event_tablet_pad *strip_event;
+	unsigned int mode;
+
+	strip_event = zalloc(sizeof *strip_event);
+
+	mode = libinput_tablet_pad_mode_group_get_mode(group);
+
+	*strip_event = (struct libinput_event_tablet_pad) {
+		.time = time,
+		.strip.number = number,
+		.strip.position = value,
+		.strip.source = source,
+		.mode_group = libinput_tablet_pad_mode_group_ref(group),
+		.mode = mode,
+	};
+
+	post_device_event(device,
+			  time,
+			  LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			  &strip_event->base);
+}
+
+static void
+gesture_notify(struct libinput_device *device,
+	       uint64_t time,
+	       enum libinput_event_type type,
+	       int finger_count,
+	       int cancelled,
+	       const struct normalized_coords *delta,
+	       const struct normalized_coords *unaccel,
+	       double scale,
+	       double angle)
+{
+	struct libinput_event_gesture *gesture_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_GESTURE))
+		return;
+
+	gesture_event = zalloc(sizeof *gesture_event);
+
+	*gesture_event = (struct libinput_event_gesture) {
+		.time = time,
+		.finger_count = finger_count,
+		.cancelled = cancelled,
+		.delta = *delta,
+		.delta_unaccel = *unaccel,
+		.scale = scale,
+		.angle = angle,
+	};
+
+	post_device_event(device, time, type,
+			  &gesture_event->base);
+}
+
+void
+gesture_notify_swipe(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel)
+{
+	gesture_notify(device, time, type, finger_count, 0, delta, unaccel,
+		       0.0, 0.0);
+}
+
+void
+gesture_notify_swipe_end(struct libinput_device *device,
+			 uint64_t time,
+			 int finger_count,
+			 int cancelled)
+{
+	const struct normalized_coords zero = { 0.0, 0.0 };
+
+	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_SWIPE_END,
+		       finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+}
+
+void
+gesture_notify_pinch(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_event_type type,
+		     int finger_count,
+		     const struct normalized_coords *delta,
+		     const struct normalized_coords *unaccel,
+		     double scale,
+		     double angle)
+{
+	gesture_notify(device, time, type, finger_count, 0,
+		       delta, unaccel, scale, angle);
+}
+
+void
+gesture_notify_pinch_end(struct libinput_device *device,
+			 uint64_t time,
+			 int finger_count,
+			 double scale,
+			 int cancelled)
+{
+	const struct normalized_coords zero = { 0.0, 0.0 };
+
+	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_PINCH_END,
+		       finger_count, cancelled, &zero, &zero, scale, 0.0);
+}
+
+void
+switch_notify_toggle(struct libinput_device *device,
+		     uint64_t time,
+		     enum libinput_switch sw,
+		     enum libinput_switch_state state)
+{
+	struct libinput_event_switch *switch_event;
+
+	if (!device_has_cap(device, LIBINPUT_DEVICE_CAP_SWITCH))
+		return;
+
+	switch_event = zalloc(sizeof *switch_event);
+
+	*switch_event = (struct libinput_event_switch) {
+		.time = time,
+		.sw = sw,
+		.state = state,
+	};
+
+	post_device_event(device, time,
+			  LIBINPUT_EVENT_SWITCH_TOGGLE,
+			  &switch_event->base);
+}
+
+static void
+libinput_post_event(struct libinput *libinput,
+		    struct libinput_event *event)
+{
+	struct libinput_event **events = libinput->events;
+	size_t events_len = libinput->events_len;
+	size_t events_count = libinput->events_count;
+	size_t move_len;
+	size_t new_out;
+
+#if 0
+	log_debug(libinput, "Queuing %s\n", event_type_to_str(event->type));
+#endif
+
+	events_count++;
+	if (events_count > events_len) {
+		events_len *= 2;
+		events = realloc(events, events_len * sizeof *events);
+		if (!events) {
+			log_error(libinput,
+				  "Failed to reallocate event ring buffer. "
+				  "Events may be discarded\n");
+			return;
+		}
+
+		if (libinput->events_count > 0 && libinput->events_in == 0) {
+			libinput->events_in = libinput->events_len;
+		} else if (libinput->events_count > 0 &&
+			   libinput->events_out >= libinput->events_in) {
+			move_len = libinput->events_len - libinput->events_out;
+			new_out = events_len - move_len;
+			memmove(events + new_out,
+				events + libinput->events_out,
+				move_len * sizeof *events);
+			libinput->events_out = new_out;
+		}
+
+		libinput->events = events;
+		libinput->events_len = events_len;
+	}
+
+	if (event->device)
+		libinput_device_ref(event->device);
+
+	libinput->events_count = events_count;
+	events[libinput->events_in] = event;
+	libinput->events_in = (libinput->events_in + 1) % libinput->events_len;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_get_event(struct libinput *libinput)
+{
+	struct libinput_event *event;
+
+	if (libinput->events_count == 0)
+		return NULL;
+
+	event = libinput->events[libinput->events_out];
+	libinput->events_out =
+		(libinput->events_out + 1) % libinput->events_len;
+	libinput->events_count--;
+
+	return event;
+}
+
+LIBINPUT_EXPORT enum libinput_event_type
+libinput_next_event_type(struct libinput *libinput)
+{
+	struct libinput_event *event;
+
+	if (libinput->events_count == 0)
+		return LIBINPUT_EVENT_NONE;
+
+	event = libinput->events[libinput->events_out];
+	return event->type;
+}
+
+LIBINPUT_EXPORT void
+libinput_set_user_data(struct libinput *libinput,
+		       void *user_data)
+{
+	libinput->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_get_user_data(struct libinput *libinput)
+{
+	return libinput->user_data;
+}
+
+LIBINPUT_EXPORT int
+libinput_resume(struct libinput *libinput)
+{
+	return libinput->interface_backend->resume(libinput);
+}
+
+LIBINPUT_EXPORT void
+libinput_suspend(struct libinput *libinput)
+{
+	libinput->interface_backend->suspend(libinput);
+}
+
+LIBINPUT_EXPORT void
+libinput_device_set_user_data(struct libinput_device *device, void *user_data)
+{
+	device->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_device_get_user_data(struct libinput_device *device)
+{
+	return device->user_data;
+}
+
+LIBINPUT_EXPORT struct libinput *
+libinput_device_get_context(struct libinput_device *device)
+{
+	return libinput_seat_get_context(device->seat);
+}
+
+LIBINPUT_EXPORT struct libinput_device_group *
+libinput_device_get_device_group(struct libinput_device *device)
+{
+	return device->group;
+}
+
+LIBINPUT_EXPORT const char *
+libinput_device_get_sysname(struct libinput_device *device)
+{
+	return evdev_device_get_sysname((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT const char *
+libinput_device_get_name(struct libinput_device *device)
+{
+	return evdev_device_get_name((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_product(struct libinput_device *device)
+{
+	return evdev_device_get_id_product((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_get_id_vendor(struct libinput_device *device)
+{
+	return evdev_device_get_id_vendor((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT const char *
+libinput_device_get_output_name(struct libinput_device *device)
+{
+	return evdev_device_get_output((struct evdev_device *) device);
+}
+
+LIBINPUT_EXPORT struct libinput_seat *
+libinput_device_get_seat(struct libinput_device *device)
+{
+	return device->seat;
+}
+
+LIBINPUT_EXPORT int
+libinput_device_set_seat_logical_name(struct libinput_device *device,
+				      const char *name)
+{
+	struct libinput *libinput = device->seat->libinput;
+
+	if (name == NULL)
+		return -1;
+
+	return libinput->interface_backend->device_change_seat(device,
+							       name);
+}
+
+LIBINPUT_EXPORT struct udev_device *
+libinput_device_get_udev_device(struct libinput_device *device)
+{
+	return evdev_device_get_udev_device((struct evdev_device *)device);
+}
+
+LIBINPUT_EXPORT void
+libinput_device_led_update(struct libinput_device *device,
+			   enum libinput_led leds)
+{
+	evdev_device_led_update((struct evdev_device *) device, leds);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_has_capability(struct libinput_device *device,
+			       enum libinput_device_capability capability)
+{
+	return evdev_device_has_capability((struct evdev_device *) device,
+					   capability);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_get_size(struct libinput_device *device,
+			 double *width,
+			 double *height)
+{
+	return evdev_device_get_size((struct evdev_device *)device,
+				     width,
+				     height);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_pointer_has_button(struct libinput_device *device, uint32_t code)
+{
+	return evdev_device_has_button((struct evdev_device *)device, code);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_keyboard_has_key(struct libinput_device *device, uint32_t code)
+{
+	return evdev_device_has_key((struct evdev_device *)device, code);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_switch_has_switch(struct libinput_device *device,
+				  enum libinput_switch sw)
+{
+	return evdev_device_has_switch((struct evdev_device *)device, sw);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_tablet_pad_get_num_buttons(struct libinput_device *device)
+{
+	return evdev_device_tablet_pad_get_num_buttons((struct evdev_device *)device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_tablet_pad_get_num_rings(struct libinput_device *device)
+{
+	return evdev_device_tablet_pad_get_num_rings((struct evdev_device *)device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_tablet_pad_get_num_strips(struct libinput_device *device)
+{
+	return evdev_device_tablet_pad_get_num_strips((struct evdev_device *)device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_tablet_pad_get_num_mode_groups(struct libinput_device *device)
+{
+	return evdev_device_tablet_pad_get_num_mode_groups((struct evdev_device *)device);
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_pad_mode_group*
+libinput_device_tablet_pad_get_mode_group(struct libinput_device *device,
+					  unsigned int index)
+{
+	return evdev_device_tablet_pad_get_mode_group((struct evdev_device *)device,
+						      index);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_tablet_pad_mode_group_get_num_modes(
+				     struct libinput_tablet_pad_mode_group *group)
+{
+	return group->num_modes;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_tablet_pad_mode_group_get_mode(struct libinput_tablet_pad_mode_group *group)
+{
+	return group->current_mode;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_tablet_pad_mode_group_get_index(struct libinput_tablet_pad_mode_group *group)
+{
+	return group->index;
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_pad_mode_group_has_button(struct libinput_tablet_pad_mode_group *group,
+					  unsigned int button)
+{
+	if ((int)button >=
+	    libinput_device_tablet_pad_get_num_buttons(group->device))
+		return 0;
+
+	return !!(group->button_mask & (1 << button));
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_pad_mode_group_has_ring(struct libinput_tablet_pad_mode_group *group,
+					unsigned int ring)
+{
+	if ((int)ring >=
+	    libinput_device_tablet_pad_get_num_rings(group->device))
+		return 0;
+
+	return !!(group->ring_mask & (1 << ring));
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_pad_mode_group_has_strip(struct libinput_tablet_pad_mode_group *group,
+					 unsigned int strip)
+{
+	if ((int)strip >=
+	    libinput_device_tablet_pad_get_num_strips(group->device))
+		return 0;
+
+	return !!(group->strip_mask & (1 << strip));
+}
+
+LIBINPUT_EXPORT int
+libinput_tablet_pad_mode_group_button_is_toggle(struct libinput_tablet_pad_mode_group *group,
+						unsigned int button)
+{
+	if ((int)button >=
+	    libinput_device_tablet_pad_get_num_buttons(group->device))
+		return 0;
+
+	return !!(group->toggle_button_mask & (1 << button));
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_pad_mode_group *
+libinput_tablet_pad_mode_group_ref(
+			struct libinput_tablet_pad_mode_group *group)
+{
+	group->refcount++;
+	return group;
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_pad_mode_group *
+libinput_tablet_pad_mode_group_unref(
+			struct libinput_tablet_pad_mode_group *group)
+{
+	assert(group->refcount > 0);
+
+	group->refcount--;
+	if (group->refcount > 0)
+		return group;
+
+	list_remove(&group->link);
+	group->destroy(group);
+	return NULL;
+}
+
+LIBINPUT_EXPORT void
+libinput_tablet_pad_mode_group_set_user_data(
+			struct libinput_tablet_pad_mode_group *group,
+			void *user_data)
+{
+	group->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_tablet_pad_mode_group_get_user_data(
+			struct libinput_tablet_pad_mode_group *group)
+{
+	return group->user_data;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_device_notify_get_base_event(struct libinput_event_device_notify *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_DEVICE_ADDED,
+			   LIBINPUT_EVENT_DEVICE_REMOVED);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_keyboard_get_base_event(struct libinput_event_keyboard *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_KEYBOARD_KEY);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_pointer_get_base_event(struct libinput_event_pointer *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_POINTER_MOTION,
+			   LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+			   LIBINPUT_EVENT_POINTER_BUTTON,
+			   LIBINPUT_EVENT_POINTER_AXIS);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_touch_get_base_event(struct libinput_event_touch *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TOUCH_DOWN,
+			   LIBINPUT_EVENT_TOUCH_UP,
+			   LIBINPUT_EVENT_TOUCH_MOTION,
+			   LIBINPUT_EVENT_TOUCH_CANCEL,
+			   LIBINPUT_EVENT_TOUCH_FRAME);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_gesture_get_base_event(struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_END,
+			   LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+			   LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+			   LIBINPUT_EVENT_GESTURE_PINCH_END);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_tablet_tool_get_base_event(struct libinput_event_tablet_tool *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+			   LIBINPUT_EVENT_TABLET_TOOL_TIP,
+			   LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+			   LIBINPUT_EVENT_TABLET_TOOL_BUTTON);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_pad_get_ring_position(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_TABLET_PAD_RING);
+
+	return event->ring.position;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_event_tablet_pad_get_ring_number(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_RING);
+
+	return event->ring.number;
+}
+
+LIBINPUT_EXPORT enum libinput_tablet_pad_ring_axis_source
+libinput_event_tablet_pad_get_ring_source(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN,
+			   LIBINPUT_EVENT_TABLET_PAD_RING);
+
+	return event->ring.source;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_tablet_pad_get_strip_position(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0.0,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP);
+
+	return event->strip.position;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_event_tablet_pad_get_strip_number(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP);
+
+	return event->strip.number;
+}
+
+LIBINPUT_EXPORT enum libinput_tablet_pad_strip_axis_source
+libinput_event_tablet_pad_get_strip_source(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP);
+
+	return event->strip.source;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_tablet_pad_get_button_number(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return event->button.number;
+}
+
+LIBINPUT_EXPORT enum libinput_button_state
+libinput_event_tablet_pad_get_button_state(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   LIBINPUT_BUTTON_STATE_RELEASED,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return event->button.state;
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_event_tablet_pad_get_mode(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return event->mode;
+}
+
+LIBINPUT_EXPORT struct libinput_tablet_pad_mode_group *
+libinput_event_tablet_pad_get_mode_group(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return event->mode_group;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_tablet_pad_get_time(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return us2ms(event->time);
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_tablet_pad_get_time_usec(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   0,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return event->time;
+}
+
+LIBINPUT_EXPORT struct libinput_event *
+libinput_event_tablet_pad_get_base_event(struct libinput_event_tablet_pad *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_TABLET_PAD_RING,
+			   LIBINPUT_EVENT_TABLET_PAD_STRIP,
+			   LIBINPUT_EVENT_TABLET_PAD_BUTTON);
+
+	return &event->base;
+}
+
+LIBINPUT_EXPORT struct libinput_device_group *
+libinput_device_group_ref(struct libinput_device_group *group)
+{
+	group->refcount++;
+	return group;
+}
+
+struct libinput_device_group *
+libinput_device_group_create(struct libinput *libinput,
+			     const char *identifier)
+{
+	struct libinput_device_group *group;
+
+	group = zalloc(sizeof *group);
+	group->refcount = 1;
+	group->identifier = safe_strdup(identifier);
+
+	list_init(&group->link);
+	list_insert(&libinput->device_group_list, &group->link);
+
+	return group;
+}
+
+struct libinput_device_group *
+libinput_device_group_find_group(struct libinput *libinput,
+				 const char *identifier)
+{
+	struct libinput_device_group *g = NULL;
+
+	list_for_each(g, &libinput->device_group_list, link) {
+		if (identifier && g->identifier &&
+		    streq(g->identifier, identifier)) {
+			return g;
+		}
+	}
+
+	return NULL;
+}
+
+void
+libinput_device_set_device_group(struct libinput_device *device,
+				 struct libinput_device_group *group)
+{
+	device->group = group;
+	libinput_device_group_ref(group);
+}
+
+static void
+libinput_device_group_destroy(struct libinput_device_group *group)
+{
+	list_remove(&group->link);
+	free(group->identifier);
+	free(group);
+}
+
+LIBINPUT_EXPORT struct libinput_device_group *
+libinput_device_group_unref(struct libinput_device_group *group)
+{
+	assert(group->refcount > 0);
+	group->refcount--;
+	if (group->refcount == 0) {
+		libinput_device_group_destroy(group);
+		return NULL;
+	} else {
+		return group;
+	}
+}
+
+LIBINPUT_EXPORT void
+libinput_device_group_set_user_data(struct libinput_device_group *group,
+				    void *user_data)
+{
+	group->user_data = user_data;
+}
+
+LIBINPUT_EXPORT void *
+libinput_device_group_get_user_data(struct libinput_device_group *group)
+{
+	return group->user_data;
+}
+
+LIBINPUT_EXPORT const char *
+libinput_config_status_to_str(enum libinput_config_status status)
+{
+	const char *str = NULL;
+
+	switch(status) {
+	case LIBINPUT_CONFIG_STATUS_SUCCESS:
+		str = "Success";
+		break;
+	case LIBINPUT_CONFIG_STATUS_UNSUPPORTED:
+		str = "Unsupported configuration option";
+		break;
+	case LIBINPUT_CONFIG_STATUS_INVALID:
+		str = "Invalid argument range";
+		break;
+	}
+
+	return str;
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_tap_get_finger_count(struct libinput_device *device)
+{
+	return device->config.tap ? device->config.tap->count(device) : 0;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_tap_set_enabled(struct libinput_device *device,
+				       enum libinput_config_tap_state enable)
+{
+	if (enable != LIBINPUT_CONFIG_TAP_ENABLED &&
+	    enable != LIBINPUT_CONFIG_TAP_DISABLED)
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return enable ? LIBINPUT_CONFIG_STATUS_UNSUPPORTED :
+				LIBINPUT_CONFIG_STATUS_SUCCESS;
+
+	return device->config.tap->set_enabled(device, enable);
+
+}
+
+LIBINPUT_EXPORT enum libinput_config_tap_state
+libinput_device_config_tap_get_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_TAP_DISABLED;
+
+	return device->config.tap->get_enabled(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_tap_state
+libinput_device_config_tap_get_default_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_TAP_DISABLED;
+
+	return device->config.tap->get_default(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_tap_set_button_map(struct libinput_device *device,
+					    enum libinput_config_tap_button_map map)
+{
+	switch (map) {
+	case LIBINPUT_CONFIG_TAP_MAP_LRM:
+	case LIBINPUT_CONFIG_TAP_MAP_LMR:
+		break;
+	default:
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+	}
+
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.tap->set_map(device, map);
+}
+
+LIBINPUT_EXPORT enum libinput_config_tap_button_map
+libinput_device_config_tap_get_button_map(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_TAP_MAP_LRM;
+
+	return device->config.tap->get_map(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_tap_button_map
+libinput_device_config_tap_get_default_button_map(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_TAP_MAP_LRM;
+
+	return device->config.tap->get_default_map(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_tap_set_drag_enabled(struct libinput_device *device,
+					    enum libinput_config_drag_state enable)
+{
+	if (enable != LIBINPUT_CONFIG_DRAG_ENABLED &&
+	    enable != LIBINPUT_CONFIG_DRAG_DISABLED)
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return enable ? LIBINPUT_CONFIG_STATUS_UNSUPPORTED :
+				LIBINPUT_CONFIG_STATUS_SUCCESS;
+
+	return device->config.tap->set_drag_enabled(device, enable);
+}
+
+LIBINPUT_EXPORT enum libinput_config_drag_state
+libinput_device_config_tap_get_drag_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_DRAG_DISABLED;
+
+	return device->config.tap->get_drag_enabled(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_drag_state
+libinput_device_config_tap_get_default_drag_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_DRAG_DISABLED;
+
+	return device->config.tap->get_default_drag_enabled(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_tap_set_drag_lock_enabled(struct libinput_device *device,
+						 enum libinput_config_drag_lock_state enable)
+{
+	if (enable != LIBINPUT_CONFIG_DRAG_LOCK_ENABLED &&
+	    enable != LIBINPUT_CONFIG_DRAG_LOCK_DISABLED)
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return enable ? LIBINPUT_CONFIG_STATUS_UNSUPPORTED :
+				LIBINPUT_CONFIG_STATUS_SUCCESS;
+
+	return device->config.tap->set_draglock_enabled(device, enable);
+}
+
+LIBINPUT_EXPORT enum libinput_config_drag_lock_state
+libinput_device_config_tap_get_drag_lock_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_DRAG_LOCK_DISABLED;
+
+	return device->config.tap->get_draglock_enabled(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_drag_lock_state
+libinput_device_config_tap_get_default_drag_lock_enabled(struct libinput_device *device)
+{
+	if (libinput_device_config_tap_get_finger_count(device) == 0)
+		return LIBINPUT_CONFIG_DRAG_LOCK_DISABLED;
+
+	return device->config.tap->get_default_draglock_enabled(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_calibration_has_matrix(struct libinput_device *device)
+{
+	return device->config.calibration ?
+		device->config.calibration->has_matrix(device) : 0;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_calibration_set_matrix(struct libinput_device *device,
+					      const float matrix[6])
+{
+	if (!libinput_device_config_calibration_has_matrix(device))
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.calibration->set_matrix(device, matrix);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_calibration_get_matrix(struct libinput_device *device,
+					      float matrix[6])
+{
+	if (!libinput_device_config_calibration_has_matrix(device))
+		return 0;
+
+	return device->config.calibration->get_matrix(device, matrix);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_calibration_get_default_matrix(struct libinput_device *device,
+						      float matrix[6])
+{
+	if (!libinput_device_config_calibration_has_matrix(device))
+		return 0;
+
+	return device->config.calibration->get_default_matrix(device, matrix);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_send_events_get_modes(struct libinput_device *device)
+{
+	uint32_t modes = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+
+	if (device->config.sendevents)
+		modes |= device->config.sendevents->get_modes(device);
+
+	return modes;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_send_events_set_mode(struct libinput_device *device,
+					    uint32_t mode)
+{
+	if ((libinput_device_config_send_events_get_modes(device) & mode) != mode)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	if (device->config.sendevents)
+		return device->config.sendevents->set_mode(device, mode);
+	else /* mode must be _ENABLED to get here */
+		return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_send_events_get_mode(struct libinput_device *device)
+{
+	if (device->config.sendevents)
+		return device->config.sendevents->get_mode(device);
+	else
+		return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_send_events_get_default_mode(struct libinput_device *device)
+{
+	return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_accel_is_available(struct libinput_device *device)
+{
+	return device->config.accel ?
+		device->config.accel->available(device) : 0;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_accel_set_speed(struct libinput_device *device,
+				       double speed)
+{
+	/* Need the negation in case speed is NaN */
+	if (!(speed >= -1.0 && speed <= 1.0))
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	if (!libinput_device_config_accel_is_available(device))
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.accel->set_speed(device, speed);
+}
+LIBINPUT_EXPORT double
+libinput_device_config_accel_get_speed(struct libinput_device *device)
+{
+	if (!libinput_device_config_accel_is_available(device))
+		return 0;
+
+	return device->config.accel->get_speed(device);
+}
+
+LIBINPUT_EXPORT double
+libinput_device_config_accel_get_default_speed(struct libinput_device *device)
+{
+	if (!libinput_device_config_accel_is_available(device))
+		return 0;
+
+	return device->config.accel->get_default_speed(device);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_accel_get_profiles(struct libinput_device *device)
+{
+	if (!libinput_device_config_accel_is_available(device))
+		return 0;
+
+	return device->config.accel->get_profiles(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_accel_profile
+libinput_device_config_accel_get_profile(struct libinput_device *device)
+{
+	if (!libinput_device_config_accel_is_available(device))
+		return LIBINPUT_CONFIG_ACCEL_PROFILE_NONE;
+
+	return device->config.accel->get_profile(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_accel_profile
+libinput_device_config_accel_get_default_profile(struct libinput_device *device)
+{
+	if (!libinput_device_config_accel_is_available(device))
+		return LIBINPUT_CONFIG_ACCEL_PROFILE_NONE;
+
+	return device->config.accel->get_default_profile(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_accel_set_profile(struct libinput_device *device,
+					 enum libinput_config_accel_profile profile)
+{
+	switch (profile) {
+	case LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT:
+	case LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE:
+		break;
+	default:
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+	}
+
+	if (!libinput_device_config_accel_is_available(device) ||
+	    (libinput_device_config_accel_get_profiles(device) & profile) == 0)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.accel->set_profile(device, profile);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_scroll_has_natural_scroll(struct libinput_device *device)
+{
+	if (!device->config.natural_scroll)
+		return 0;
+
+	return device->config.natural_scroll->has(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_scroll_set_natural_scroll_enabled(struct libinput_device *device,
+							 int enabled)
+{
+	if (!libinput_device_config_scroll_has_natural_scroll(device))
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.natural_scroll->set_enabled(device, enabled);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_scroll_get_natural_scroll_enabled(struct libinput_device *device)
+{
+	if (!device->config.natural_scroll)
+		return 0;
+
+	return device->config.natural_scroll->get_enabled(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_scroll_get_default_natural_scroll_enabled(struct libinput_device *device)
+{
+	if (!device->config.natural_scroll)
+		return 0;
+
+	return device->config.natural_scroll->get_default_enabled(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_left_handed_is_available(struct libinput_device *device)
+{
+	if (!device->config.left_handed)
+		return 0;
+
+	return device->config.left_handed->has(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_left_handed_set(struct libinput_device *device,
+				       int left_handed)
+{
+	if (!libinput_device_config_left_handed_is_available(device))
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	return device->config.left_handed->set(device, left_handed);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_left_handed_get(struct libinput_device *device)
+{
+	if (!libinput_device_config_left_handed_is_available(device))
+		return 0;
+
+	return device->config.left_handed->get(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_left_handed_get_default(struct libinput_device *device)
+{
+	if (!libinput_device_config_left_handed_is_available(device))
+		return 0;
+
+	return device->config.left_handed->get_default(device);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_click_get_methods(struct libinput_device *device)
+{
+	if (device->config.click_method)
+		return device->config.click_method->get_methods(device);
+	else
+		return 0;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_click_set_method(struct libinput_device *device,
+					enum libinput_config_click_method method)
+{
+	/* Check method is a single valid method */
+	switch (method) {
+	case LIBINPUT_CONFIG_CLICK_METHOD_NONE:
+	case LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS:
+	case LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER:
+		break;
+	default:
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+	}
+
+	if ((libinput_device_config_click_get_methods(device) & method) != method)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	if (device->config.click_method)
+		return device->config.click_method->set_method(device, method);
+	else /* method must be _NONE to get here */
+		return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+LIBINPUT_EXPORT enum libinput_config_click_method
+libinput_device_config_click_get_method(struct libinput_device *device)
+{
+	if (device->config.click_method)
+		return device->config.click_method->get_method(device);
+	else
+		return LIBINPUT_CONFIG_CLICK_METHOD_NONE;
+}
+
+LIBINPUT_EXPORT enum libinput_config_click_method
+libinput_device_config_click_get_default_method(struct libinput_device *device)
+{
+	if (device->config.click_method)
+		return device->config.click_method->get_default_method(device);
+	else
+		return LIBINPUT_CONFIG_CLICK_METHOD_NONE;
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_middle_emulation_is_available(
+		struct libinput_device *device)
+{
+	if (device->config.middle_emulation)
+		return device->config.middle_emulation->available(device);
+	else
+		return LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_middle_emulation_set_enabled(
+		struct libinput_device *device,
+		enum libinput_config_middle_emulation_state enable)
+{
+	int available =
+		libinput_device_config_middle_emulation_is_available(device);
+
+	switch (enable) {
+	case LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED:
+		if (!available)
+			return LIBINPUT_CONFIG_STATUS_SUCCESS;
+		break;
+	case LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED:
+		if (!available)
+			return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+		break;
+	default:
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+	}
+
+	return device->config.middle_emulation->set(device, enable);
+}
+
+LIBINPUT_EXPORT enum libinput_config_middle_emulation_state
+libinput_device_config_middle_emulation_get_enabled(
+		struct libinput_device *device)
+{
+	if (!libinput_device_config_middle_emulation_is_available(device))
+		return LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED;
+
+	return device->config.middle_emulation->get(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_middle_emulation_state
+libinput_device_config_middle_emulation_get_default_enabled(
+		struct libinput_device *device)
+{
+	if (!libinput_device_config_middle_emulation_is_available(device))
+		return LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED;
+
+	return device->config.middle_emulation->get_default(device);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_scroll_get_methods(struct libinput_device *device)
+{
+	if (device->config.scroll_method)
+		return device->config.scroll_method->get_methods(device);
+	else
+		return 0;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_scroll_set_method(struct libinput_device *device,
+					 enum libinput_config_scroll_method method)
+{
+	/* Check method is a single valid method */
+	switch (method) {
+	case LIBINPUT_CONFIG_SCROLL_NO_SCROLL:
+	case LIBINPUT_CONFIG_SCROLL_2FG:
+	case LIBINPUT_CONFIG_SCROLL_EDGE:
+	case LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN:
+		break;
+	default:
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+	}
+
+	if ((libinput_device_config_scroll_get_methods(device) & method) != method)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	if (device->config.scroll_method)
+		return device->config.scroll_method->set_method(device, method);
+	else /* method must be _NO_SCROLL to get here */
+		return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+LIBINPUT_EXPORT enum libinput_config_scroll_method
+libinput_device_config_scroll_get_method(struct libinput_device *device)
+{
+	if (device->config.scroll_method)
+		return device->config.scroll_method->get_method(device);
+	else
+		return LIBINPUT_CONFIG_SCROLL_NO_SCROLL;
+}
+
+LIBINPUT_EXPORT enum libinput_config_scroll_method
+libinput_device_config_scroll_get_default_method(struct libinput_device *device)
+{
+	if (device->config.scroll_method)
+		return device->config.scroll_method->get_default_method(device);
+	else
+		return LIBINPUT_CONFIG_SCROLL_NO_SCROLL;
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_scroll_set_button(struct libinput_device *device,
+					 uint32_t button)
+{
+	if ((libinput_device_config_scroll_get_methods(device) &
+	     LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN) == 0)
+		return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+
+	if (button && !libinput_device_pointer_has_button(device, button))
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	return device->config.scroll_method->set_button(device, button);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_scroll_get_button(struct libinput_device *device)
+{
+	if ((libinput_device_config_scroll_get_methods(device) &
+	     LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN) == 0)
+		return 0;
+
+	return device->config.scroll_method->get_button(device);
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_device_config_scroll_get_default_button(struct libinput_device *device)
+{
+	if ((libinput_device_config_scroll_get_methods(device) &
+	     LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN) == 0)
+		return 0;
+
+	return device->config.scroll_method->get_default_button(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_dwt_is_available(struct libinput_device *device)
+{
+	if (!device->config.dwt)
+		return 0;
+
+	return device->config.dwt->is_available(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_dwt_set_enabled(struct libinput_device *device,
+				       enum libinput_config_dwt_state enable)
+{
+	if (enable != LIBINPUT_CONFIG_DWT_ENABLED &&
+	    enable != LIBINPUT_CONFIG_DWT_DISABLED)
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	if (!libinput_device_config_dwt_is_available(device))
+		return enable ? LIBINPUT_CONFIG_STATUS_UNSUPPORTED :
+				LIBINPUT_CONFIG_STATUS_SUCCESS;
+
+	return device->config.dwt->set_enabled(device, enable);
+}
+
+LIBINPUT_EXPORT enum libinput_config_dwt_state
+libinput_device_config_dwt_get_enabled(struct libinput_device *device)
+{
+	if (!libinput_device_config_dwt_is_available(device))
+		return LIBINPUT_CONFIG_DWT_DISABLED;
+
+	return device->config.dwt->get_enabled(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_dwt_state
+libinput_device_config_dwt_get_default_enabled(struct libinput_device *device)
+{
+	if (!libinput_device_config_dwt_is_available(device))
+		return LIBINPUT_CONFIG_DWT_DISABLED;
+
+	return device->config.dwt->get_default_enabled(device);
+}
+
+LIBINPUT_EXPORT int
+libinput_device_config_rotation_is_available(struct libinput_device *device)
+{
+	if (!device->config.rotation)
+		return 0;
+
+	return device->config.rotation->is_available(device);
+}
+
+LIBINPUT_EXPORT enum libinput_config_status
+libinput_device_config_rotation_set_angle(struct libinput_device *device,
+					  unsigned int degrees_cw)
+{
+	if (!libinput_device_config_rotation_is_available(device))
+		return degrees_cw ? LIBINPUT_CONFIG_STATUS_UNSUPPORTED :
+				    LIBINPUT_CONFIG_STATUS_SUCCESS;
+
+	if (degrees_cw >= 360 || degrees_cw % 90)
+		return LIBINPUT_CONFIG_STATUS_INVALID;
+
+	return device->config.rotation->set_angle(device, degrees_cw);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_config_rotation_get_angle(struct libinput_device *device)
+{
+	if (!libinput_device_config_rotation_is_available(device))
+		return 0;
+
+	return device->config.rotation->get_angle(device);
+}
+
+LIBINPUT_EXPORT unsigned int
+libinput_device_config_rotation_get_default_angle(struct libinput_device *device)
+{
+	if (!libinput_device_config_rotation_is_available(device))
+		return 0;
+
+	return device->config.rotation->get_default_angle(device);
+}
--- libinput-1.10.7.orig/src/libinput.h
+++ libinput-1.10.7/src/libinput.h
@@ -806,6 +806,9 @@ enum libinput_event_type {
 	LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
 	LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
 	LIBINPUT_EVENT_GESTURE_PINCH_END,
+	LIBINPUT_EVENT_GESTURE_TAP_BEGIN,
+	LIBINPUT_EVENT_GESTURE_TAP_UPDATE,
+	LIBINPUT_EVENT_GESTURE_TAP_END,
 
 	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
 };
--- /dev/null
+++ libinput-1.10.7/src/libinput.h.orig
@@ -0,0 +1,5364 @@
+/*
+ * Copyright © 2013 Jonas Ådahl
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBINPUT_H
+#define LIBINPUT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdarg.h>
+#include <libudev.h>
+
+#define LIBINPUT_ATTRIBUTE_PRINTF(_format, _args) \
+	__attribute__ ((format (printf, _format, _args)))
+#define LIBINPUT_ATTRIBUTE_DEPRECATED __attribute__ ((deprecated))
+
+/**
+ * @ingroup base
+ * @struct libinput
+ *
+ * A handle for accessing libinput. This struct is refcounted, use
+ * libinput_ref() and libinput_unref().
+ */
+struct libinput;
+
+/**
+ * @ingroup device
+ * @struct libinput_device
+ *
+ * A base handle for accessing libinput devices. This struct is
+ * refcounted, use libinput_device_ref() and libinput_device_unref().
+ */
+struct libinput_device;
+
+/**
+ * @ingroup device
+ * @struct libinput_device_group
+ *
+ * A base handle for accessing libinput device groups. This struct is
+ * refcounted, use libinput_device_group_ref() and
+ * libinput_device_group_unref().
+ */
+struct libinput_device_group;
+
+/**
+ * @ingroup seat
+ * @struct libinput_seat
+ *
+ * The base handle for accessing libinput seats. This struct is
+ * refcounted, use libinput_seat_ref() and libinput_seat_unref().
+ */
+struct libinput_seat;
+
+/**
+ * @ingroup device
+ * @struct libinput_tablet_tool
+ *
+ * An object representing a tool being used by a device with the @ref
+ * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+ *
+ * Tablet events generated by such a device are bound to a specific tool
+ * rather than coming from the device directly. Depending on the hardware it
+ * is possible to track the same physical tool across multiple
+ * struct libinput_device devices, see @ref tablet-serial-numbers.
+ *
+ * This struct is refcounted, use libinput_tablet_tool_ref() and
+ * libinput_tablet_tool_unref().
+ */
+struct libinput_tablet_tool;
+
+/**
+ * @ingroup event
+ * @struct libinput_event
+ *
+ * The base event type. Use libinput_event_get_pointer_event() or similar to
+ * get the actual event type.
+ *
+ * @warning Unlike other structs events are considered transient and
+ * <b>not</b> refcounted.
+ */
+struct libinput_event;
+
+/**
+ * @ingroup event
+ * @struct libinput_event_device_notify
+ *
+ * An event notifying the caller of a device being added or removed.
+ */
+struct libinput_event_device_notify;
+
+/**
+ * @ingroup event_keyboard
+ * @struct libinput_event_keyboard
+ *
+ * A keyboard event representing a key press/release.
+ */
+struct libinput_event_keyboard;
+
+/**
+ * @ingroup event_pointer
+ * @struct libinput_event_pointer
+ *
+ * A pointer event representing relative or absolute pointer movement,
+ * a button press/release or scroll axis events.
+ */
+struct libinput_event_pointer;
+
+/**
+ * @ingroup event_touch
+ * @struct libinput_event_touch
+ *
+ * Touch event representing a touch down, move or up, as well as a touch
+ * cancel and touch frame events. Valid event types for this event are @ref
+ * LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_MOTION, @ref
+ * LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_CANCEL and @ref
+ * LIBINPUT_EVENT_TOUCH_FRAME.
+ */
+struct libinput_event_touch;
+
+/**
+ * @ingroup event_tablet
+ * @struct libinput_event_tablet_tool
+ *
+ * Tablet tool event representing an axis update, button press, or tool
+ * update. Valid event types for this event are @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY and @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ */
+struct libinput_event_tablet_tool;
+
+/**
+ * @ingroup event_tablet_pad
+ * @struct libinput_event_tablet_pad
+ *
+ * Tablet pad event representing a button press, or ring/strip update on
+ * the tablet pad itself. Valid event types for this event are @ref
+ * LIBINPUT_EVENT_TABLET_PAD_BUTTON, @ref LIBINPUT_EVENT_TABLET_PAD_RING and
+ * @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.
+ */
+struct libinput_event_tablet_pad;
+
+/**
+ * @ingroup base
+ *
+ * Log priority for internal logging messages.
+ */
+enum libinput_log_priority {
+	LIBINPUT_LOG_PRIORITY_DEBUG = 10,
+	LIBINPUT_LOG_PRIORITY_INFO = 20,
+	LIBINPUT_LOG_PRIORITY_ERROR = 30,
+};
+
+/**
+ * @ingroup device
+ *
+ * Capabilities on a device. A device may have one or more capabilities
+ * at a time, capabilities remain static for the lifetime of the device.
+ */
+enum libinput_device_capability {
+	LIBINPUT_DEVICE_CAP_KEYBOARD = 0,
+	LIBINPUT_DEVICE_CAP_POINTER = 1,
+	LIBINPUT_DEVICE_CAP_TOUCH = 2,
+	LIBINPUT_DEVICE_CAP_TABLET_TOOL = 3,
+	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
+	LIBINPUT_DEVICE_CAP_GESTURE = 5,
+	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+};
+
+/**
+ * @ingroup device
+ *
+ * Logical state of a key. Note that the logical state may not represent
+ * the physical state of the key.
+ */
+enum libinput_key_state {
+	LIBINPUT_KEY_STATE_RELEASED = 0,
+	LIBINPUT_KEY_STATE_PRESSED = 1
+};
+
+/**
+ * @ingroup device
+ *
+ * Mask reflecting LEDs on a device.
+ */
+enum libinput_led {
+	LIBINPUT_LED_NUM_LOCK = (1 << 0),
+	LIBINPUT_LED_CAPS_LOCK = (1 << 1),
+	LIBINPUT_LED_SCROLL_LOCK = (1 << 2)
+};
+
+/**
+ * @ingroup device
+ *
+ * Logical state of a physical button. Note that the logical state may not
+ * represent the physical state of the button.
+ */
+enum libinput_button_state {
+	LIBINPUT_BUTTON_STATE_RELEASED = 0,
+	LIBINPUT_BUTTON_STATE_PRESSED = 1
+};
+
+/**
+ * @ingroup device
+ *
+ * Axes on a device with the capability @ref LIBINPUT_DEVICE_CAP_POINTER
+ * that are not x or y coordinates.
+ *
+ * The two scroll axes @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
+ * @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL are engaged separately,
+ * depending on the device. libinput provides some scroll direction locking
+ * but it is up to the caller to determine which axis is needed and
+ * appropriate in the current interaction
+ */
+enum libinput_pointer_axis {
+	LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL = 0,
+	LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL = 1,
+};
+
+/**
+ * @ingroup device
+ *
+ * The source for a libinput_pointer_axis event. See
+ * libinput_event_pointer_get_axis_source() for details.
+ */
+enum libinput_pointer_axis_source {
+	/**
+	 * The event is caused by the rotation of a wheel.
+	 */
+	LIBINPUT_POINTER_AXIS_SOURCE_WHEEL = 1,
+	/**
+	 * The event is caused by the movement of one or more fingers on a
+	 * device.
+	 */
+	LIBINPUT_POINTER_AXIS_SOURCE_FINGER,
+	/**
+	 * The event is caused by the motion of some device.
+	 */
+	LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS,
+	/**
+	 * The event is caused by the tilting of a mouse wheel rather than
+	 * its rotation. This method is commonly used on mice without
+	 * separate horizontal scroll wheels.
+	 */
+	LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT,
+};
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * The source for a @ref LIBINPUT_EVENT_TABLET_PAD_RING event. See
+ * libinput_event_tablet_pad_get_ring_source() for details.
+ */
+enum libinput_tablet_pad_ring_axis_source {
+	LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN = 1,
+	/**
+	 * The event is caused by the movement of one or more fingers on
+	 * the ring.
+	 */
+	LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER,
+};
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * The source for a @ref LIBINPUT_EVENT_TABLET_PAD_STRIP event. See
+ * libinput_event_tablet_pad_get_strip_source() for details.
+ */
+enum libinput_tablet_pad_strip_axis_source {
+	LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN = 1,
+	/**
+	 * The event is caused by the movement of one or more fingers on
+	 * the strip.
+	 */
+	LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER,
+};
+
+/**
+ * @ingroup device
+ *
+ * Available tool types for a device with the @ref
+ * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. The tool type defines the default
+ * usage of the tool as advertised by the manufacturer. Multiple different
+ * physical tools may share the same tool type, e.g. a Wacom Classic Pen,
+ * Wacom Pro Pen and a Wacom Grip Pen are all of type @ref
+ * LIBINPUT_TABLET_TOOL_TYPE_PEN.
+ * Use libinput_tablet_tool_get_tool_id() to get a specific model where applicable.
+ *
+ * Note that on some device, the eraser tool is on the tail end of a pen
+ * device. On other devices, e.g. MS Surface 3, the eraser is the pen tip
+ * while a button is held down.
+ *
+ * @note The @ref libinput_tablet_tool_type can only describe the default physical
+ * type of the device. For devices with adjustable physical properties
+ * the tool type remains the same, i.e. putting a Wacom stroke nib into a
+ * classic pen leaves the tool type as @ref LIBINPUT_TABLET_TOOL_TYPE_PEN.
+ */
+enum libinput_tablet_tool_type {
+	LIBINPUT_TABLET_TOOL_TYPE_PEN = 1,	/**< A generic pen */
+	LIBINPUT_TABLET_TOOL_TYPE_ERASER,	/**< Eraser */
+	LIBINPUT_TABLET_TOOL_TYPE_BRUSH,	/**< A paintbrush-like tool */
+	LIBINPUT_TABLET_TOOL_TYPE_PENCIL,	/**< Physical drawing tool, e.g.
+					             Wacom Inking Pen */
+	LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH,	/**< An airbrush-like tool */
+	LIBINPUT_TABLET_TOOL_TYPE_MOUSE,	/**< A mouse bound to the tablet */
+	LIBINPUT_TABLET_TOOL_TYPE_LENS,		/**< A mouse tool with a lens */
+};
+
+/**
+ * @ingroup device
+ *
+ * The state of proximity for a tool on a device. The device must have the @ref
+ * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+ *
+ * The proximity of a tool is a binary state signalling whether the tool is
+ * within a detectable distance of the tablet device. A tool that is out of
+ * proximity cannot generate events.
+ *
+ * On some hardware a tool goes out of proximity when it ceases to touch the
+ * surface. On other hardware, the tool is still detectable within a short
+ * distance (a few cm) off the surface.
+ */
+enum libinput_tablet_tool_proximity_state {
+	LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT = 0,
+	LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN = 1,
+};
+
+/**
+ * @ingroup device
+ *
+ * The tip contact state for a tool on a device. The device must have
+ * the @ref LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+ *
+ * The tip contact state of a tool is a binary state signalling whether the tool is
+ * touching the surface of the tablet device.
+ */
+enum libinput_tablet_tool_tip_state {
+	LIBINPUT_TABLET_TOOL_TIP_UP = 0,
+	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
+};
+
+/**
+ * @defgroup tablet_pad_modes Tablet pad modes
+ *
+ * Handling the virtual mode groups of buttons, strips and rings on tablet
+ * pad devices. See @ref tablet-pad-modes for details.
+ */
+
+/**
+ * @ingroup tablet_pad_modes
+ * @struct libinput_tablet_pad_mode_group
+ *
+ * A mode on a tablet pad is a virtual grouping of functionality, usually
+ * based on some visual feedback like LEDs on the pad. The set of buttons,
+ * rings and strips that share the same mode are a "mode group". Whenever
+ * the mode changes, all buttons, rings and strips within this mode group
+ * are affected. See @ref tablet-pad-modes for detail.
+ *
+ * Most tablets only have a single mode group, some tablets provide multiple
+ * mode groups through independent banks of LEDs (e.g. the Wacom Cintiq
+ * 24HD). libinput guarantees that at least one mode group is always
+ * available.
+ *
+ * This struct is refcounted, use libinput_tablet_pad_mode_group_ref() and
+ * libinput_tablet_pad_mode_group_unref().
+ */
+struct libinput_tablet_pad_mode_group;
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Most devices only provide a single mode group, however devices such as
+ * the Wacom Cintiq 22HD provide two mode groups. If multiple mode groups
+ * are available, a caller should use
+ * libinput_tablet_pad_mode_group_has_button(),
+ * libinput_tablet_pad_mode_group_has_ring() and
+ * libinput_tablet_pad_mode_group_has_strip() to associate each button,
+ * ring and strip with the correct mode group.
+ *
+ * @return the number of mode groups available on this device
+ */
+int
+libinput_device_tablet_pad_get_num_mode_groups(struct libinput_device *device);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * The returned mode group is not refcounted and may become invalid after
+ * the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
+ * libinput_tablet_pad_mode_group_unref() to continue using the handle
+ * outside of the immediate scope.
+ *
+ * While at least one reference is kept by the caller, the returned mode
+ * group will be identical for each subsequent call of this function with
+ * the same index and that same struct is returned from
+ * libinput_event_tablet_pad_get_mode_group(), provided the event was
+ * generated by this mode group.
+ *
+ * @param device A device with the @ref LIBINPUT_DEVICE_CAP_TABLET_PAD
+ * capability
+ * @param index A mode group index
+ * @return the mode group with the given index or NULL if an invalid index
+ * is given.
+ */
+struct libinput_tablet_pad_mode_group*
+libinput_device_tablet_pad_get_mode_group(struct libinput_device *device,
+					  unsigned int index);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * The returned number is the same index as passed to
+ * libinput_device_tablet_pad_get_mode_group(). For tablets with only one
+ * mode this number is always 0.
+ *
+ * @param group A previously obtained mode group
+ * @return the numeric index this mode group represents, starting at 0
+ */
+unsigned int
+libinput_tablet_pad_mode_group_get_index(struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Query the mode group for the number of available modes. The number of
+ * modes is usually decided by the number of physical LEDs available on the
+ * device. Different mode groups may have a different number of modes. Use
+ * libinput_tablet_pad_mode_group_get_mode() to get the currently active
+ * mode.
+ *
+ * libinput guarantees that at least one mode is available. A device without
+ * mode switching capability has a single mode group and a single mode.
+ *
+ * @param group A previously obtained mode group
+ * @return the number of modes available in this mode group
+ */
+unsigned int
+libinput_tablet_pad_mode_group_get_num_modes(struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Return the current mode this mode group is in. Note that the returned
+ * mode is the mode valid as of completing the last libinput_dispatch().
+ * The returned mode may thus be different than the mode returned by
+ * libinput_event_tablet_pad_get_mode().
+ *
+ * For example, if the mode was toggled three times between the call to
+ * libinput_dispatch(), this function returns the third mode but the events
+ * in the event queue will return the modes 1, 2 and 3, respectively.
+ *
+ * @param group A previously obtained mode group
+ * @return the numeric index of the current mode in this group, starting at 0
+ *
+ * @see libinput_event_tablet_pad_get_mode
+ */
+unsigned int
+libinput_tablet_pad_mode_group_get_mode(struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Devices without mode switching capabilities return true for every button.
+ *
+ * @param group A previously obtained mode group
+ * @param button A button index, starting at 0
+ * @return true if the given button index is part of this mode group or
+ * false otherwise
+ */
+int
+libinput_tablet_pad_mode_group_has_button(struct libinput_tablet_pad_mode_group *group,
+					  unsigned int button);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Devices without mode switching capabilities return true for every ring.
+ *
+ * @param group A previously obtained mode group
+ * @param ring A ring index, starting at 0
+ * @return true if the given ring index is part of this mode group or
+ * false otherwise
+ */
+int
+libinput_tablet_pad_mode_group_has_ring(struct libinput_tablet_pad_mode_group *group,
+					  unsigned int ring);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Devices without mode switching capabilities return true for every strip.
+ *
+ * @param group A previously obtained mode group
+ * @param strip A strip index, starting at 0
+ * @return true if the given strip index is part of this mode group or
+ * false otherwise
+ */
+int
+libinput_tablet_pad_mode_group_has_strip(struct libinput_tablet_pad_mode_group *group,
+					  unsigned int strip);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * The toggle button in a mode group is the button assigned to cycle to or
+ * directly assign a new mode when pressed. Not all devices have a toggle
+ * button and some devices may have more than one toggle button. For
+ * example, the Wacom Cintiq 24HD has six toggle buttons in two groups, each
+ * directly selecting one of the three modes per group.
+ *
+ * Devices without mode switching capabilities return false for every button.
+ *
+ * @param group A previously obtained mode group
+ * @param button A button index, starting at 0
+ * @retval non-zero if the button is a mode toggle button for this group, or
+ * zero otherwise
+ */
+int
+libinput_tablet_pad_mode_group_button_is_toggle(struct libinput_tablet_pad_mode_group *group,
+						unsigned int button);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Increase the refcount of the mode group. A mode group will be
+ * freed whenever the refcount reaches 0.
+ *
+ * @param group A previously obtained mode group
+ * @return The passed mode group
+ */
+struct libinput_tablet_pad_mode_group *
+libinput_tablet_pad_mode_group_ref(
+			struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Decrease the refcount of the mode group. A mode group will be
+ * freed whenever the refcount reaches 0.
+ *
+ * @param group A previously obtained mode group
+ * @return NULL if the group was destroyed, otherwise the passed mode group
+ */
+struct libinput_tablet_pad_mode_group *
+libinput_tablet_pad_mode_group_unref(
+			struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Set caller-specific data associated with this mode group. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param group A previously obtained mode group
+ * @param user_data Caller-specific data pointer
+ * @see libinput_tablet_pad_mode_group_get_user_data
+ *
+ */
+void
+libinput_tablet_pad_mode_group_set_user_data(
+			struct libinput_tablet_pad_mode_group *group,
+			void *user_data);
+
+/**
+ * @ingroup tablet_pad_modes
+ *
+ * Get the caller-specific data associated with this mode group, if any.
+ *
+ * @param group A previously obtained mode group
+ * @return Caller-specific data pointer or NULL if none was set
+ * @see libinput_tablet_pad_mode_group_set_user_data
+ */
+void *
+libinput_tablet_pad_mode_group_get_user_data(
+			struct libinput_tablet_pad_mode_group *group);
+
+/**
+ * @ingroup device
+ *
+ * The state of a switch. The default state of a switch is @ref
+ * LIBINPUT_SWITCH_STATE_OFF and no event is sent to confirm a switch in the
+ * off position. If a switch is logically on during initialization, libinput
+ * sends an event of type @ref LIBINPUT_EVENT_SWITCH_TOGGLE with a state
+ * @ref LIBINPUT_SWITCH_STATE_ON.
+ */
+enum libinput_switch_state {
+	LIBINPUT_SWITCH_STATE_OFF = 0,
+	LIBINPUT_SWITCH_STATE_ON = 1,
+};
+
+/**
+ * @ingroup device
+ *
+ * The type of a switch.
+ */
+enum libinput_switch {
+	/**
+	 * The laptop lid was closed when the switch state is @ref
+	 * LIBINPUT_SWITCH_STATE_ON, or was opened when it is @ref
+	 * LIBINPUT_SWITCH_STATE_OFF.
+	 */
+	LIBINPUT_SWITCH_LID = 1,
+
+	/**
+	 * This switch indicates whether the device is in normal laptop mode
+	 * or behaves like a tablet-like device where the primary
+	 * interaction is usually a touch screen. When in tablet mode, the
+	 * keyboard and touchpad are usually inaccessible.
+	 *
+	 * If the switch is in state @ref LIBINPUT_SWITCH_STATE_OFF, the
+	 * device is in laptop mode. If the switch is in state @ref
+	 * LIBINPUT_SWITCH_STATE_ON, the device is in tablet mode and the
+	 * keyboard or touchpad may not be  accessible.
+	 *
+	 * It is up to the caller to identify which devices are inaccessible
+	 * in tablet mode.
+	 */
+	LIBINPUT_SWITCH_TABLET_MODE,
+};
+
+/**
+ * @ingroup event_switch
+ * @struct libinput_event_switch
+ *
+ * A switch event representing a changed state in a switch.
+ */
+struct libinput_event_switch;
+
+/**
+ * @ingroup base
+ *
+ * Event type for events returned by libinput_get_event().
+ */
+enum libinput_event_type {
+	/**
+	 * This is not a real event type, and is only used to tell the user that
+	 * no new event is available in the queue. See
+	 * libinput_next_event_type().
+	 */
+	LIBINPUT_EVENT_NONE = 0,
+
+	/**
+	 * Signals that a device has been added to the context. The device will
+	 * not be read until the next time the user calls libinput_dispatch()
+	 * and data is available.
+	 *
+	 * This allows setting up initial device configuration before any events
+	 * are created.
+	 */
+	LIBINPUT_EVENT_DEVICE_ADDED,
+
+	/**
+	 * Signals that a device has been removed. No more events from the
+	 * associated device will be in the queue or be queued after this event.
+	 */
+	LIBINPUT_EVENT_DEVICE_REMOVED,
+
+	LIBINPUT_EVENT_KEYBOARD_KEY = 300,
+
+	LIBINPUT_EVENT_POINTER_MOTION = 400,
+	LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE,
+	LIBINPUT_EVENT_POINTER_BUTTON,
+	LIBINPUT_EVENT_POINTER_AXIS,
+
+	LIBINPUT_EVENT_TOUCH_DOWN = 500,
+	LIBINPUT_EVENT_TOUCH_UP,
+	LIBINPUT_EVENT_TOUCH_MOTION,
+	LIBINPUT_EVENT_TOUCH_CANCEL,
+	/**
+	 * Signals the end of a set of touchpoints at one device sample
+	 * time. This event has no coordinate information attached.
+	 */
+	LIBINPUT_EVENT_TOUCH_FRAME,
+
+	/**
+	 * One or more axes have changed state on a device with the @ref
+	 * LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. This event is only sent
+	 * when the tool is in proximity, see @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY for details.
+	 *
+	 * The proximity event contains the initial state of the axis as the
+	 * tool comes into proximity. An event of type @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_AXIS is only sent when an axis value
+	 * changes from this initial state. It is possible for a tool to
+	 * enter and leave proximity without sending an event of type @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_AXIS.
+	 *
+	 * An event of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS is sent
+	 * when the tip state does not change. See the documentation for
+	 * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP for more details.
+	 */
+	LIBINPUT_EVENT_TABLET_TOOL_AXIS = 600,
+	/**
+	 * Signals that a tool has come in or out of proximity of a device with
+	 * the @ref LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+	 *
+	 * Proximity events contain each of the current values for each axis,
+	 * and these values may be extracted from them in the same way they are
+	 * with @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS events.
+	 *
+	 * Some tools may always be in proximity. For these tools, events of
+	 * type @ref LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN are sent only once after @ref
+	 * LIBINPUT_EVENT_DEVICE_ADDED, and events of type @ref
+	 * LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT are sent only once before @ref
+	 * LIBINPUT_EVENT_DEVICE_REMOVED.
+	 *
+	 * If the tool that comes into proximity supports x/y coordinates,
+	 * libinput guarantees that both x and y are set in the proximity
+	 * event.
+	 *
+	 * When a tool goes out of proximity, the value of every axis should be
+	 * assumed to have an undefined state and any buttons that are currently held
+	 * down on the stylus are marked as released. Button release events for
+	 * each button that was held down on the stylus are sent before the
+	 * proximity out event.
+	 */
+	LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+	/**
+	 * Signals that a tool has come in contact with the surface of a
+	 * device with the @ref LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+	 *
+	 * On devices without distance proximity detection, the @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_TIP is sent immediately after @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY for the tip down event, and
+	 * immediately before for the tip up event.
+	 *
+	 * The decision when a tip touches the surface is device-dependent
+	 * and may be derived from pressure data or other means. If the tip
+	 * state is changed by axes changing state, the
+	 * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP event includes the changed
+	 * axes and no additional axis event is sent for this state change.
+	 * In other words, a caller must look at both @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_AXIS and @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_TIP events to know the current state
+	 * of the axes.
+	 *
+	 * If a button state change occurs at the same time as a tip state
+	 * change, the order of events is device-dependent.
+	 */
+	LIBINPUT_EVENT_TABLET_TOOL_TIP,
+	/**
+	 * Signals that a tool has changed a logical button state on a
+	 * device with the @ref LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
+	 *
+	 * Button state changes occur on their own and do not include axis
+	 * state changes. If button and axis state changes occur within the
+	 * same logical hardware event, the order of the @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_BUTTON and @ref
+	 * LIBINPUT_EVENT_TABLET_TOOL_AXIS event is device-specific.
+	 *
+	 * This event is not to be confused with the button events emitted
+	 * by the tablet pad. See @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON.
+	 *
+	 * @see LIBINPUT_EVENT_TABLET_BUTTON
+	 */
+	LIBINPUT_EVENT_TABLET_TOOL_BUTTON,
+
+	/**
+	 * A button pressed on a device with the @ref
+	 * LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
+	 *
+	 * This event is not to be confused with the button events emitted
+	 * by tools on a tablet. See @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+	 */
+	LIBINPUT_EVENT_TABLET_PAD_BUTTON = 700,
+	/**
+	 * A status change on a tablet ring with the
+	 * LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
+	 */
+	LIBINPUT_EVENT_TABLET_PAD_RING,
+
+	/**
+	 * A status change on a strip on a device with the @ref
+	 * LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
+	 */
+	LIBINPUT_EVENT_TABLET_PAD_STRIP,
+
+	LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN = 800,
+	LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
+	LIBINPUT_EVENT_GESTURE_SWIPE_END,
+	LIBINPUT_EVENT_GESTURE_PINCH_BEGIN,
+	LIBINPUT_EVENT_GESTURE_PINCH_UPDATE,
+	LIBINPUT_EVENT_GESTURE_PINCH_END,
+
+	LIBINPUT_EVENT_SWITCH_TOGGLE = 900,
+};
+
+/**
+ * @defgroup event Accessing and destruction of events
+ */
+
+/**
+ * @ingroup event
+ *
+ * Destroy the event, freeing all associated resources. Resources obtained
+ * from this event must be considered invalid after this call.
+ *
+ * @warning Unlike other structs events are considered transient and
+ * <b>not</b> refcounted. Calling libinput_event_destroy() <b>will</b>
+ * destroy the event.
+ *
+ * @param event An event retrieved by libinput_get_event().
+ */
+void
+libinput_event_destroy(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Get the type of the event.
+ *
+ * @param event An event retrieved by libinput_get_event().
+ */
+enum libinput_event_type
+libinput_event_get_type(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Get the libinput context from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput context for this event.
+ */
+struct libinput *
+libinput_event_get_context(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the device associated with this event. For device added/removed
+ * events this is the device added or removed. For all other device events,
+ * this is the device that generated the event.
+ *
+ * This device is not refcounted and its lifetime is that of the event. Use
+ * libinput_device_ref() before using the device outside of this scope.
+ *
+ * @return The device associated with this event
+ */
+
+struct libinput_device *
+libinput_event_get_device(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the pointer event that is this input event. If the event type does
+ * not match the pointer event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_pointer_get_base_event().
+ *
+ * @return A pointer event, or NULL for other events
+ */
+struct libinput_event_pointer *
+libinput_event_get_pointer_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the keyboard event that is this input event. If the event type does
+ * not match the keyboard event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_keyboard_get_base_event().
+ *
+ * @return A keyboard event, or NULL for other events
+ */
+struct libinput_event_keyboard *
+libinput_event_get_keyboard_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the touch event that is this input event. If the event type does
+ * not match the touch event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_touch_get_base_event().
+ *
+ * @return A touch event, or NULL for other events
+ */
+struct libinput_event_touch *
+libinput_event_get_touch_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the gesture event that is this input event. If the event type does
+ * not match the gesture event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_gesture_get_base_event().
+ *
+ * @return A gesture event, or NULL for other events
+ */
+struct libinput_event_gesture *
+libinput_event_get_gesture_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the tablet tool event that is this input event. If the event type
+ * does not match the tablet tool event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_tablet_tool_get_base_event().
+ *
+ * @return A tablet tool event, or NULL for other events
+ */
+struct libinput_event_tablet_tool *
+libinput_event_get_tablet_tool_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the tablet pad event that is this input event. If the event type does not
+ * match the tablet pad event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_tablet_pad_get_base_event().
+ *
+ * @return A tablet pad event, or NULL for other events
+ */
+struct libinput_event_tablet_pad *
+libinput_event_get_tablet_pad_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the switch event that is this input event. If the event type does
+ * not match the switch event types, this function returns NULL.
+ *
+ * The inverse of this function is libinput_event_switch_get_base_event().
+ *
+ * @return A switch event, or NULL for other events
+ */
+struct libinput_event_switch *
+libinput_event_get_switch_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * Return the device event that is this input event. If the event type does
+ * not match the device event types, this function returns NULL.
+ *
+ * The inverse of this function is
+ * libinput_event_device_notify_get_base_event().
+ *
+ * @return A device event, or NULL for other events
+ */
+struct libinput_event_device_notify *
+libinput_event_get_device_notify_event(struct libinput_event *event);
+
+/**
+ * @ingroup event
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_device_notify_get_base_event(struct libinput_event_device_notify *event);
+
+/**
+ * @defgroup event_keyboard Keyboard events
+ *
+ * Key events are generated when a key changes its logical state, usually by
+ * being pressed or released.
+ */
+
+/**
+ * @ingroup event_keyboard
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_keyboard_get_time(struct libinput_event_keyboard *event);
+
+/**
+ * @ingroup event_keyboard
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_keyboard_get_time_usec(struct libinput_event_keyboard *event);
+
+/**
+ * @ingroup event_keyboard
+ *
+ * @return The keycode that triggered this key event
+ */
+uint32_t
+libinput_event_keyboard_get_key(struct libinput_event_keyboard *event);
+
+/**
+ * @ingroup event_keyboard
+ *
+ * @return The state change of the key
+ */
+enum libinput_key_state
+libinput_event_keyboard_get_key_state(struct libinput_event_keyboard *event);
+
+/**
+ * @ingroup event_keyboard
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_keyboard_get_base_event(struct libinput_event_keyboard *event);
+
+/**
+ * @ingroup event_keyboard
+ *
+ * For the key of a @ref LIBINPUT_EVENT_KEYBOARD_KEY event, return the total number
+ * of keys pressed on all devices on the associated seat after the event was
+ * triggered.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_KEYBOARD_KEY. For other events, this function returns 0.
+ *
+ * @return The seat wide pressed key count for the key of this event
+ */
+uint32_t
+libinput_event_keyboard_get_seat_key_count(
+	struct libinput_event_keyboard *event);
+
+/**
+ * @defgroup event_pointer Pointer events
+ *
+ * Pointer events reflect motion, button and scroll events, as well as
+ * events from other axes.
+ */
+
+/**
+ * @ingroup event_pointer
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_pointer_get_time(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_pointer_get_time_usec(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the delta between the last event and the current event. For pointer
+ * events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
+ * function returns 0.
+ *
+ * If a device employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * Relative motion deltas are to be interpreted as pixel movement of a
+ * standardized mouse. See @ref motion_normalization for more details.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION.
+ *
+ * @return The relative x movement since the last event
+ */
+double
+libinput_event_pointer_get_dx(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the delta between the last event and the current event. For pointer
+ * events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
+ * function returns 0.
+ *
+ * If a device employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * Relative motion deltas are to be interpreted as pixel movement of a
+ * standardized mouse. See @ref motion_normalization for more details.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION.
+ *
+ * @return The relative y movement since the last event
+ */
+double
+libinput_event_pointer_get_dy(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the relative delta of the unaccelerated motion vector of the
+ * current event. For pointer events that are not of type @ref
+ * LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
+ *
+ * Relative unaccelerated motion deltas are raw device coordinates.
+ * Note that these coordinates are subject to the device's native
+ * resolution. Touchpad coordinates represent raw device coordinates in the
+ * X resolution of the touchpad. See @ref motion_normalization for more
+ * details.
+ *
+ * Any rotation applied to the device also applies to unaccelerated motion
+ * (see libinput_device_config_rotation_set_angle()).
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION.
+ *
+ * @return The unaccelerated relative x movement since the last event
+ */
+double
+libinput_event_pointer_get_dx_unaccelerated(
+	struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the relative delta of the unaccelerated motion vector of the
+ * current event. For pointer events that are not of type @ref
+ * LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
+ *
+ * Relative unaccelerated motion deltas are raw device coordinates.
+ * Note that these coordinates are subject to the device's native
+ * resolution. Touchpad coordinates represent raw device coordinates in the
+ * X resolution of the touchpad. See @ref motion_normalization for more
+ * details.
+ *
+ * Any rotation applied to the device also applies to unaccelerated motion
+ * (see libinput_device_config_rotation_set_angle()).
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION.
+ *
+ * @return The unaccelerated relative y movement since the last event
+ */
+double
+libinput_event_pointer_get_dy_unaccelerated(
+	struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the current absolute x coordinate of the pointer event, in mm from
+ * the top left corner of the device. To get the corresponding output screen
+ * coordinate, use libinput_event_pointer_get_absolute_x_transformed().
+ *
+ * For pointer events that are not of type
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
+ *
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_pointer_get_absolute_x(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the current absolute y coordinate of the pointer event, in mm from
+ * the top left corner of the device. To get the corresponding output screen
+ * coordinate, use libinput_event_pointer_get_absolute_y_transformed().
+ *
+ * For pointer events that are not of type
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
+ *
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_pointer_get_absolute_y(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the current absolute x coordinate of the pointer event, transformed to
+ * screen coordinates.
+ *
+ * For pointer events that are not of type
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this
+ * function is undefined.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
+ *
+ * @param event The libinput pointer event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_pointer_get_absolute_x_transformed(
+	struct libinput_event_pointer *event,
+	uint32_t width);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the current absolute y coordinate of the pointer event, transformed to
+ * screen coordinates.
+ *
+ * For pointer events that are not of type
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this function is
+ * undefined.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
+ *
+ * @param event The libinput pointer event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_pointer_get_absolute_y_transformed(
+	struct libinput_event_pointer *event,
+	uint32_t height);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the button that triggered this event.
+ * For pointer events that are not of type @ref
+ * LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON.
+ *
+ * @return The button triggering this event
+ */
+uint32_t
+libinput_event_pointer_get_button(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the button state that triggered this event.
+ * For pointer events that are not of type @ref
+ * LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON.
+ *
+ * @return The button state triggering this event
+ */
+enum libinput_button_state
+libinput_event_pointer_get_button_state(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
+ * total number of buttons pressed on all devices on the associated seat
+ * after the event was triggered.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @return The seat wide pressed button count for the key of this event
+ */
+uint32_t
+libinput_event_pointer_get_seat_button_count(
+	struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Check if the event has a valid value for the given axis.
+ *
+ * If this function returns non-zero for an axis and
+ * libinput_event_pointer_get_axis_value() returns a value of 0, the event
+ * is a scroll stop event.
+ *
+ * For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_AXIS.
+ *
+ * @return Non-zero if this event contains a value for this axis
+ */
+int
+libinput_event_pointer_has_axis(struct libinput_event_pointer *event,
+				enum libinput_pointer_axis axis);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the axis value of the given axis. The interpretation of the value
+ * depends on the axis. For the two scrolling axes
+ * @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
+ * @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL, the value of the event is in
+ * relative scroll units, with the positive direction being down or right,
+ * respectively. For the interpretation of the value, see
+ * libinput_event_pointer_get_axis_source().
+ *
+ * If libinput_event_pointer_has_axis() returns 0 for an axis, this function
+ * returns 0 for that axis.
+ *
+ * For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_AXIS.
+ *
+ * @return The axis value of this event
+ *
+ * @see libinput_event_pointer_get_axis_value_discrete
+ */
+double
+libinput_event_pointer_get_axis_value(struct libinput_event_pointer *event,
+				      enum libinput_pointer_axis axis);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the source for a given axis event. Axis events (scroll events) can
+ * be caused by a hardware item such as a scroll wheel or emulated from
+ * other input sources, such as two-finger or edge scrolling on a
+ * touchpad.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_FINGER, libinput
+ * guarantees that a scroll sequence is terminated with a scroll value of 0.
+ * A caller may use this information to decide on whether kinetic scrolling
+ * should be triggered on this scroll sequence.
+ * The coordinate system is identical to the cursor movement, i.e. a
+ * scroll value of 1 represents the equivalent relative motion of 1.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, no terminating
+ * event is guaranteed (though it may happen).
+ * Scrolling is in discrete steps, the value is the angle the wheel moved
+ * in degrees. The default is 15 degrees per wheel click, but some mice may
+ * have differently grained wheels. It is up to the caller how to interpret
+ * such different step sizes.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS, no
+ * terminating event is guaranteed (though it may happen).
+ * The coordinate system is identical to the cursor movement, i.e. a
+ * scroll value of 1 represents the equivalent relative motion of 1.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT, no
+ * terminating event is guaranteed (though it may happen).
+ * Scrolling is in discrete steps and there is no physical equivalent for
+ * the value returned here. For backwards compatibility, the value returned
+ * by this function is identical to a single mouse wheel rotation by this
+ * device (see the documentation for @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL
+ * above). Callers should not use this value but instead exclusively refer
+ * to the value returned by libinput_event_pointer_get_axis_value_discrete().
+ *
+ * For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
+ * this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_POINTER_AXIS.
+ *
+ * @return The source for this axis event
+ */
+enum libinput_pointer_axis_source
+libinput_event_pointer_get_axis_source(struct libinput_event_pointer *event);
+
+/**
+ * @ingroup event_pointer
+ *
+ * Return the axis value in discrete steps for a given axis event. How a
+ * value translates into a discrete step depends on the source.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, the discrete
+ * value correspond to the number of physical mouse wheel clicks.
+ *
+ * If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS or @ref
+ * LIBINPUT_POINTER_AXIS_SOURCE_FINGER, the discrete value is always 0.
+ *
+ * @return The discrete value for the given event.
+ *
+ * @see libinput_event_pointer_get_axis_value
+ */
+double
+libinput_event_pointer_get_axis_value_discrete(struct libinput_event_pointer *event,
+					       enum libinput_pointer_axis axis);
+
+/**
+ * @ingroup event_pointer
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_pointer_get_base_event(struct libinput_event_pointer *event);
+
+/**
+ * @defgroup event_touch Touch events
+ *
+ * Events from absolute touch devices.
+ */
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_touch_get_time(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_touch_get_time_usec(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the slot of this touch event. See the kernel's multitouch
+ * protocol B documentation for more information.
+ *
+ * If the touch event has no assigned slot, for example if it is from a
+ * single touch device, this function returns -1.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
+ * LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
+ * @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
+ *
+ * @return The slot of this touch event
+ */
+int32_t
+libinput_event_touch_get_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Get the seat slot of the touch event. A seat slot is a non-negative seat
+ * wide unique identifier of an active touch point.
+ *
+ * Events from single touch devices will be represented as one individual
+ * touch point per device.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
+ * LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
+ * @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
+ *
+ * @return The seat slot of the touch event
+ */
+int32_t
+libinput_event_touch_get_seat_slot(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touch event, in mm from
+ * the top left corner of the device. To get the corresponding output screen
+ * coordinate, use libinput_event_touch_get_x_transformed().
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION.
+ *
+ * @param event The libinput touch event
+ * @return The current absolute x coordinate
+ */
+double
+libinput_event_touch_get_x(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touch event, in mm from
+ * the top left corner of the device. To get the corresponding output screen
+ * coordinate, use libinput_event_touch_get_y_transformed().
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION.
+ *
+ * @param event The libinput touch event
+ * @return The current absolute y coordinate
+ */
+double
+libinput_event_touch_get_y(struct libinput_event_touch *event);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute x coordinate of the touch event, transformed to
+ * screen coordinates.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION.
+ *
+ * @param event The libinput touch event
+ * @param width The current output screen width
+ * @return The current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_x_transformed(struct libinput_event_touch *event,
+				       uint32_t width);
+
+/**
+ * @ingroup event_touch
+ *
+ * Return the current absolute y coordinate of the touch event, transformed to
+ * screen coordinates.
+ *
+ * For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events of type
+ * other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
+ * LIBINPUT_EVENT_TOUCH_MOTION.
+ *
+ * @param event The libinput touch event
+ * @param height The current output screen height
+ * @return The current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_touch_get_y_transformed(struct libinput_event_touch *event,
+				       uint32_t height);
+
+/**
+ * @ingroup event_touch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_touch_get_base_event(struct libinput_event_touch *event);
+
+/**
+ * @defgroup event_gesture Gesture events
+ *
+ * Gesture events are generated when a gesture is recognized on a touchpad.
+ *
+ * Gesture sequences always start with a LIBINPUT_EVENT_GESTURE_FOO_START
+ * event. All following gesture events will be of the
+ * LIBINPUT_EVENT_GESTURE_FOO_UPDATE type until a
+ * LIBINPUT_EVENT_GESTURE_FOO_END is generated which signals the end of the
+ * gesture.
+ *
+ * See @ref gestures for more information on gesture handling.
+ */
+
+/**
+ * @ingroup event_gesture
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_gesture_get_time(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_gesture_get_time_usec(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_gesture_get_base_event(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the number of fingers used for a gesture. This can be used e.g.
+ * to differentiate between 3 or 4 finger swipes.
+ *
+ * This function can be called on all gesture events and the returned finger
+ * count value will not change during a sequence.
+ *
+ * @return the number of fingers used for a gesture
+ */
+int
+libinput_event_gesture_get_finger_count(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return if the gesture ended normally, or if it was cancelled.
+ * For gesture events that are not of type
+ * @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_END.
+ *
+ * @return 0 or 1, with 1 indicating that the gesture was cancelled.
+ */
+int
+libinput_event_gesture_get_cancelled(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the delta between the last event and the current event. For gesture
+ * events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
+ *
+ * If a device employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * Relative motion deltas are normalized to represent those of a device with
+ * 1000dpi resolution. See @ref motion_normalization for more details.
+ *
+ * @return the relative x movement since the last event
+ */
+double
+libinput_event_gesture_get_dx(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the delta between the last event and the current event. For gesture
+ * events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
+ *
+ * If a device employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * Relative motion deltas are normalized to represent those of a device with
+ * 1000dpi resolution. See @ref motion_normalization for more details.
+ *
+ * @return the relative y movement since the last event
+ */
+double
+libinput_event_gesture_get_dy(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the relative delta of the unaccelerated motion vector of the
+ * current event. For gesture events that are not of type
+ * @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
+ *
+ * Relative unaccelerated motion deltas are normalized to represent those of a
+ * device with 1000dpi resolution. See @ref motion_normalization for more
+ * details. Note that unaccelerated events are not equivalent to 'raw' events
+ * as read from the device.
+ *
+ * Any rotation applied to the device also applies to gesture motion
+ * (see libinput_device_config_rotation_set_angle()).
+ *
+ * @return the unaccelerated relative x movement since the last event
+ */
+double
+libinput_event_gesture_get_dx_unaccelerated(
+	struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the relative delta of the unaccelerated motion vector of the
+ * current event. For gesture events that are not of type
+ * @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
+ *
+ * Relative unaccelerated motion deltas are normalized to represent those of a
+ * device with 1000dpi resolution. See @ref motion_normalization for more
+ * details. Note that unaccelerated events are not equivalent to 'raw' events
+ * as read from the device.
+ *
+ * Any rotation applied to the device also applies to gesture motion
+ * (see libinput_device_config_rotation_set_angle()).
+ *
+ * @return the unaccelerated relative y movement since the last event
+ */
+double
+libinput_event_gesture_get_dy_unaccelerated(
+	struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the absolute scale of a pinch gesture, the scale is the division
+ * of the current distance between the fingers and the distance at the start
+ * of the gesture. The scale begins at 1.0, and if e.g. the fingers moved
+ * together by 50% then the scale will become 0.5, if they move twice as far
+ * apart as initially the scale becomes 2.0, etc.
+ *
+ * For gesture events that are of type @ref
+ * LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, this function returns 1.0.
+ *
+ * For gesture events that are of type @ref
+ * LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns the scale value
+ * of the most recent @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event (if
+ * any) or 1.0 otherwise.
+ *
+ * For all other events this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, @ref
+ * LIBINPUT_EVENT_GESTURE_PINCH_END or
+ * @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE.
+ *
+ * @return the absolute scale of a pinch gesture
+ */
+double
+libinput_event_gesture_get_scale(struct libinput_event_gesture *event);
+
+/**
+ * @ingroup event_gesture
+ *
+ * Return the angle delta in degrees between the last and the current @ref
+ * LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event. For gesture events that
+ * are not of type @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this
+ * function returns 0.
+ *
+ * The angle delta is defined as the change in angle of the line formed by
+ * the 2 fingers of a pinch gesture. Clockwise rotation is represented
+ * by a positive delta, counter-clockwise by a negative delta. If e.g. the
+ * fingers are on the 12 and 6 location of a clock face plate and they move
+ * to the 1 resp. 7 location in a single event then the angle delta is
+ * 30 degrees.
+ *
+ * If more than two fingers are present, the angle represents the rotation
+ * around the center of gravity. The calculation of the center of gravity is
+ * implementation-dependent.
+ *
+ * @return the angle delta since the last event
+ */
+double
+libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
+
+/**
+ * @defgroup event_tablet Tablet events
+ *
+ * Events that come from tools on tablet devices. For events from the pad,
+ * see @ref event_tablet_pad.
+ *
+ * Events from tablet devices are exposed by two interfaces, tools and pads.
+ * Tool events originate (usually) from a stylus-like device, pad events
+ * reflect any events originating from the physical tablet itself.
+ *
+ * Note that many tablets support touch events. These are exposed through
+ * the @ref LIBINPUT_DEVICE_CAP_POINTER interface (for external touchpad-like
+ * devices such as the Wacom Intuos series) or @ref
+ * LIBINPUT_DEVICE_CAP_TOUCH interface (for built-in touchscreen-like
+ * devices such as the Wacom Cintiq series).
+ */
+
+/**
+ * @ingroup event_tablet
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_tablet_tool_get_base_event(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the x axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_x_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the y axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_y_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the pressure axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_pressure_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the distance axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ * For tablet tool events of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
+ * this function always returns 1.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_distance_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the tilt x axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_tilt_x_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the tilt y axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_tilt_y_has_changed(
+				struct libinput_event_tablet_tool *event);
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the z-rotation axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_rotation_has_changed(
+				struct libinput_event_tablet_tool *event);
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the slider axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_slider_has_changed(
+				struct libinput_event_tablet_tool *event);
+/**
+ * @ingroup event_tablet
+ *
+ * Check if the wheel axis was updated in this event.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other
+ * than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
+ * LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return 1 if the axis was updated or 0 otherwise
+ */
+int
+libinput_event_tablet_tool_wheel_has_changed(
+				struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the X coordinate of the tablet tool, in mm from the top left
+ * corner of the tablet in its current logical orientation. Use
+ * libinput_event_tablet_tool_get_x_transformed() for transforming the axis
+ * value into a different coordinate space.
+ *
+ * @note On some devices, returned value may be negative or larger than the
+ * width of the device. See @ref tablet-bounds for more details.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_x(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the Y coordinate of the tablet tool, in mm from the top left
+ * corner of the tablet in its current logical orientation. Use
+ * libinput_event_tablet_tool_get_y_transformed() for transforming the axis
+ * value into a different coordinate space.
+ *
+ * @note On some devices, returned value may be negative or larger than the
+ * width of the device. See @ref tablet-bounds for more details.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_y(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the delta between the last event and the current event.
+ * If the tool employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * This value is in screen coordinate space, the delta is to be interpreted
+ * like the return value of libinput_event_pointer_get_dx().
+ * See @ref tablet-relative-motion for more details.
+ *
+ * @param event The libinput tablet event
+ * @return The relative x movement since the last event
+ */
+double
+libinput_event_tablet_tool_get_dx(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the delta between the last event and the current event.
+ * If the tool employs pointer acceleration, the delta returned by this
+ * function is the accelerated delta.
+ *
+ * This value is in screen coordinate space, the delta is to be interpreted
+ * like the return value of libinput_event_pointer_get_dx().
+ * See @ref tablet-relative-motion for more details.
+ *
+ * @param event The libinput tablet event
+ * @return The relative y movement since the last event
+ */
+double
+libinput_event_tablet_tool_get_dy(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current pressure being applied on the tool in use, normalized
+ * to the range [0, 1].
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_pressure(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current distance from the tablet's sensor, normalized to the
+ * range [0, 1].
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_distance(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current tilt along the X axis of the tablet's current logical
+ * orientation, in degrees off the tablet's z axis. That is, if the tool is
+ * perfectly orthogonal to the tablet, the tilt angle is 0. When the top
+ * tilts towards the logical top/left of the tablet, the x/y tilt angles are
+ * negative, if the top tilts towards the logical bottom/right of the
+ * tablet, the x/y tilt angles are positive.
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the axis in degrees
+ */
+double
+libinput_event_tablet_tool_get_tilt_x(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current tilt along the Y axis of the tablet's current logical
+ * orientation, in degrees off the tablet's z axis. That is, if the tool is
+ * perfectly orthogonal to the tablet, the tilt angle is 0. When the top
+ * tilts towards the logical top/left of the tablet, the x/y tilt angles are
+ * negative, if the top tilts towards the logical bottom/right of the
+ * tablet, the x/y tilt angles are positive.
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis in degrees
+ */
+double
+libinput_event_tablet_tool_get_tilt_y(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current z rotation of the tool in degrees, clockwise from the
+ * tool's logical neutral position.
+ *
+ * For tools of type @ref LIBINPUT_TABLET_TOOL_TYPE_MOUSE and @ref
+ * LIBINPUT_TABLET_TOOL_TYPE_LENS the logical neutral position is
+ * pointing to the current logical north of the tablet. For tools of type @ref
+ * LIBINPUT_TABLET_TOOL_TYPE_BRUSH, the logical neutral position is with the
+ * buttons pointing up.
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_rotation(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the current position of the slider on the tool, normalized to the
+ * range [-1, 1]. The logical zero is the neutral position of the slider, or
+ * the logical center of the axis. This axis is available on e.g. the Wacom
+ * Airbrush.
+ *
+ * If this axis does not exist on the current tool, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return The current value of the the axis
+ */
+double
+libinput_event_tablet_tool_get_slider_position(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the delta for the wheel in degrees.
+ *
+ * @param event The libinput tablet tool event
+ * @return The delta of the wheel, in degrees, compared to the last event
+ *
+ * @see libinput_event_tablet_tool_get_wheel_delta_discrete
+ */
+double
+libinput_event_tablet_tool_get_wheel_delta(
+				   struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the delta for the wheel in discrete steps (e.g. wheel clicks).
+
+ * @param event The libinput tablet tool event
+ * @return The delta of the wheel, in discrete steps, compared to the last event
+ *
+ * @see libinput_event_tablet_tool_get_wheel_delta_discrete
+ */
+int
+libinput_event_tablet_tool_get_wheel_delta_discrete(
+				    struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the current absolute x coordinate of the tablet tool event,
+ * transformed to screen coordinates.
+ *
+ * @note This function may be called for a specific axis even if
+ * libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
+ * libinput always includes all device axes in the event.
+ *
+ * @note On some devices, returned value may be negative or larger than the
+ * width of the device. See @ref tablet-bounds for more details.
+ *
+ * @param event The libinput tablet tool event
+ * @param width The current output screen width
+ * @return the current absolute x coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_tablet_tool_get_x_transformed(struct libinput_event_tablet_tool *event,
+					     uint32_t width);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the current absolute y coordinate of the tablet tool event,
+ * transformed to screen coordinates.
+ *
+ * @note This function may be called for a specific axis even if
+ * libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
+ * libinput always includes all device axes in the event.
+ *
+ * @note On some devices, returned value may be negative or larger than the
+ * width of the device. See @ref tablet-bounds for more details.
+ *
+ * @param event The libinput tablet tool event
+ * @param height The current output screen height
+ * @return the current absolute y coordinate transformed to a screen coordinate
+ */
+double
+libinput_event_tablet_tool_get_y_transformed(struct libinput_event_tablet_tool *event,
+					     uint32_t height);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the tool that was in use during this event.
+ *
+ * The returned tablet tool is not refcounted and may become invalid after
+ * the next call to libinput. Use libinput_tablet_tool_ref() and
+ * libinput_tablet_tool_unref() to continue using the handle outside of the
+ * immediate scope.
+ *
+ * If the caller holds at least one reference, this struct is used
+ * whenever the tools enters proximity again.
+  *
+ * @note Physical tool tracking requires hardware support. If unavailable,
+ * libinput creates one tool per type per tablet. See @ref
+ * tablet-serial-numbers for more details.
+ *
+ * @param event The libinput tablet tool event
+ * @return The new tool triggering this event
+ */
+struct libinput_tablet_tool *
+libinput_event_tablet_tool_get_tool(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the new proximity state of a tool from a proximity event.
+ * Used to check whether or not a tool came in or out of proximity during an
+ * event of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY.
+ *
+ * See @ref tablet-fake-proximity for recommendations on proximity handling.
+ *
+ * @param event The libinput tablet tool event
+ * @return The new proximity state of the tool from the event.
+ */
+enum libinput_tablet_tool_proximity_state
+libinput_event_tablet_tool_get_proximity_state(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Returns the new tip state of a tool from a tip event.
+ * Used to check whether or not a tool came in contact with the tablet
+ * surface or left contact with the tablet surface during an
+ * event of type @ref LIBINPUT_EVENT_TABLET_TOOL_TIP.
+ *
+ * @param event The libinput tablet tool event
+ * @return The new tip state of the tool from the event.
+ */
+enum libinput_tablet_tool_tip_state
+libinput_event_tablet_tool_get_tip_state(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the button that triggered this event.  For events that are not of
+ * type @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return the button triggering this event
+ */
+uint32_t
+libinput_event_tablet_tool_get_button(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the button state of the event.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
+ *
+ * @param event The libinput tablet tool event
+ * @return the button state triggering this event
+ */
+enum libinput_button_state
+libinput_event_tablet_tool_get_button_state(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * For the button of a @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON event, return the total
+ * number of buttons pressed on all devices on the associated seat after the
+ * the event was triggered.
+ *
+ " @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON. For other events, this function returns 0.
+ *
+ * @param event The libinput tablet tool event
+ * @return the seat wide pressed button count for the key of this event
+ */
+uint32_t
+libinput_event_tablet_tool_get_seat_button_count(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput tablet tool event
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_tablet_tool_get_time(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput tablet tool event
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_tablet_tool_get_time_usec(struct libinput_event_tablet_tool *event);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the tool type for a tool object, see @ref
+ * tablet-tool-types for details.
+ *
+ * @param tool The libinput tool
+ * @return The tool type for this tool object
+ *
+ * @see libinput_tablet_tool_get_tool_id
+ */
+enum libinput_tablet_tool_type
+libinput_tablet_tool_get_type(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the tool ID for a tool object. If nonzero, this number identifies
+ * the specific type of the tool with more precision than the type returned in
+ * libinput_tablet_tool_get_type(), see @ref tablet-tool-types. Not all
+ * tablets support a tool ID.
+ *
+ * Tablets known to support tool IDs include the Wacom Intuos 3, 4, 5, Wacom
+ * Cintiq and Wacom Intuos Pro series.
+ *
+ * @param tool The libinput tool
+ * @return The tool ID for this tool object or 0 if none is provided
+ *
+ * @see libinput_tablet_tool_get_type
+ */
+uint64_t
+libinput_tablet_tool_get_tool_id(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Increment the reference count of the tool by one. A tool is destroyed
+ * whenever the reference count reaches 0. See libinput_tablet_tool_unref().
+ *
+ * @param tool The tool to increment the ref count of
+ * @return The passed tool
+ *
+ * @see libinput_tablet_tool_unref
+ */
+struct libinput_tablet_tool *
+libinput_tablet_tool_ref(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Decrement the reference count of the tool by one. When the reference
+ * count of the tool reaches 0, the memory allocated for the tool will be
+ * freed.
+ *
+ * @param tool The tool to decrement the ref count of
+ * @return NULL if the tool was destroyed otherwise the passed tool
+ *
+ * @see libinput_tablet_tool_ref
+ */
+struct libinput_tablet_tool *
+libinput_tablet_tool_unref(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool supports pressure.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_pressure(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool supports distance.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_distance(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool supports tilt.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_tilt(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool supports z-rotation.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_rotation(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool has a slider axis.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_slider(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return whether the tablet tool has a relative wheel.
+ *
+ * @param tool The tool to check the axis capabilities of
+ * @return Nonzero if the axis is available, zero otherwise.
+ */
+int
+libinput_tablet_tool_has_wheel(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Check if a tablet tool has a button with the
+ * passed-in code (see linux/input.h).
+ *
+ * @param tool A tablet tool
+ * @param code button code to check for
+ *
+ * @return 1 if the tool supports this button code, 0 if it does not
+ */
+int
+libinput_tablet_tool_has_button(struct libinput_tablet_tool *tool,
+				uint32_t code);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return nonzero if the physical tool can be uniquely identified by
+ * libinput, or nonzero otherwise. If a tool can be uniquely identified,
+ * keeping a reference to the tool allows tracking the tool across
+ * proximity out sequences and across compatible tablets.
+ * See @ref tablet-serial-numbers for more details.
+ *
+ * @param tool A tablet tool
+ * @return 1 if the tool can be uniquely identified, 0 otherwise.
+ *
+ * @see libinput_tablet_tool_get_serial
+ */
+int
+libinput_tablet_tool_is_unique(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the serial number of a tool. If the tool does not report a serial
+ * number, this function returns zero. See @ref tablet-serial-numbers for
+ * details.
+ *
+ * @param tool The libinput tool
+ * @return The tool serial number
+ *
+ * @see libinput_tablet_tool_is_unique
+ */
+uint64_t
+libinput_tablet_tool_get_serial(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Return the user data associated with a tool object. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param tool The libinput tool
+ * @return The user data associated with the tool object
+ */
+void *
+libinput_tablet_tool_get_user_data(struct libinput_tablet_tool *tool);
+
+/**
+ * @ingroup event_tablet
+ *
+ * Set the user data associated with a tool object, if any.
+ *
+ * @param tool The libinput tool
+ * @param user_data The user data to associate with the tool object
+ */
+void
+libinput_tablet_tool_set_user_data(struct libinput_tablet_tool *tool,
+				   void *user_data);
+
+/**
+ * @defgroup event_tablet_pad Tablet pad events
+ *
+ * Events that come from the pad of tablet devices.  For events from the
+ * tablet tools, see @ref event_tablet.
+ */
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_tablet_pad_get_base_event(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the current position of the ring, in degrees counterclockwise
+ * from the northern-most point of the ring in the tablet's current logical
+ * orientation.
+ *
+ * If the source is @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER,
+ * libinput sends a terminating event with a ring value of -1 when the
+ * finger is lifted from the ring. A caller may use this information to e.g.
+ * determine if kinetic scrolling should be triggered.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The current value of the the axis
+ * @retval -1 The finger was lifted
+ */
+double
+libinput_event_tablet_pad_get_ring_position(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the number of the ring that has changed state, with 0 being the
+ * first ring. On tablets with only one ring, this function always returns
+ * 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The index of the ring that changed state
+ */
+unsigned int
+libinput_event_tablet_pad_get_ring_number(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the source of the interaction with the ring. If the source is
+ * @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER, libinput sends a ring
+ * position value of -1 to terminate the current interaction.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The source of the ring interaction
+ */
+enum libinput_tablet_pad_ring_axis_source
+libinput_event_tablet_pad_get_ring_source(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the current position of the strip, normalized to the range
+ * [0, 1], with 0 being the top/left-most point in the tablet's current
+ * logical orientation.
+ *
+ * If the source is @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER,
+ * libinput sends a terminating event with a ring value of -1 when the
+ * finger is lifted from the ring. A caller may use this information to e.g.
+ * determine if kinetic scrolling should be triggered.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The current value of the the axis
+ * @retval -1 The finger was lifted
+ */
+double
+libinput_event_tablet_pad_get_strip_position(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the number of the strip that has changed state, with 0 being the
+ * first strip. On tablets with only one strip, this function always returns
+ * 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The index of the strip that changed state
+ */
+unsigned int
+libinput_event_tablet_pad_get_strip_number(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the source of the interaction with the strip. If the source is
+ * @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER, libinput sends a strip
+ * position value of -1 to terminate the current interaction.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return The source of the strip interaction
+ */
+enum libinput_tablet_pad_strip_axis_source
+libinput_event_tablet_pad_get_strip_source(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Return the button number that triggered this event, starting at 0.
+ * For events that are not of type @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON,
+ * this function returns 0.
+ *
+ * Note that the number returned is a generic sequential button number and
+ * not a semantic button code as defined in linux/input.h.
+ * See @ref tablet-pad-buttons for more details.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return the button triggering this event
+ */
+uint32_t
+libinput_event_tablet_pad_get_button_number(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Return the button state of the event.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
+ * returns 0.
+ *
+ * @param event The libinput tablet pad event
+ * @return the button state triggering this event
+ */
+enum libinput_button_state
+libinput_event_tablet_pad_get_button_state(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the mode the button, ring, or strip that triggered this event is
+ * in, at the time of the event.
+ *
+ * The mode is a virtual grouping of functionality, usually based on some
+ * visual feedback like LEDs on the pad. See @ref tablet-pad-modes for
+ * details. Mode indices start at 0, a device that does not support modes
+ * always returns 0.
+ *
+ * Mode switching is controlled by libinput and more than one mode may exist
+ * on the tablet. This function returns the mode that this event's button,
+ * ring or strip is logically in. If the button is a mode toggle button
+ * and the button event caused a new mode to be toggled, the mode returned
+ * is the new mode the button is in.
+ *
+ * Note that the returned mode is the mode valid as of the time of the
+ * event. The returned mode may thus be different to the mode returned by
+ * libinput_tablet_pad_mode_group_get_mode(). See
+ * libinput_tablet_pad_mode_group_get_mode() for details.
+ *
+ * @param event The libinput tablet pad event
+ * @return the 0-indexed mode of this button, ring or strip at the time of
+ * the event
+ *
+ * @see libinput_tablet_pad_mode_group_get_mode
+ */
+unsigned int
+libinput_event_tablet_pad_get_mode(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * Returns the mode group that the button, ring, or strip that triggered
+ * this event is considered in. The mode is a virtual grouping of
+ * functionality, usually based on some visual feedback like LEDs on the
+ * pad. See @ref tablet-pad-modes for details.
+ *
+ * The returned mode group is not refcounted and may become invalid after
+ * the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
+ * libinput_tablet_pad_mode_group_unref() to continue using the handle
+ * outside of the immediate scope.
+ *
+ * @param event The libinput tablet pad event
+ * @return the mode group of the button, ring or strip that caused this event
+ *
+ * @see libinput_device_tablet_pad_get_mode_group
+ */
+struct libinput_tablet_pad_mode_group *
+libinput_event_tablet_pad_get_mode_group(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput tablet pad event
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_tablet_pad_get_time(struct libinput_event_tablet_pad *event);
+
+/**
+ * @ingroup event_tablet_pad
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput tablet pad event
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_tablet_pad_get_time_usec(struct libinput_event_tablet_pad *event);
+
+/**
+ * @defgroup event_switch Switch events
+ *
+ * Events that come from switch devices.
+ */
+
+/**
+ * @ingroup event_switch
+ *
+ * Return the switch that triggered this event.
+ * For pointer events that are not of type @ref
+ * LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
+ *
+ * @param event The libinput switch event
+ * @return The switch triggering this event
+ */
+enum libinput_switch
+libinput_event_switch_get_switch(struct libinput_event_switch *event);
+
+/**
+ * @ingroup event_switch
+ *
+ * Return the switch state that triggered this event.
+ * For switch events that are not of type @ref
+ * LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
+ *
+ * @note It is an application bug to call this function for events other than
+ * @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
+ *
+ * @param event The libinput switch event
+ * @return The switch state triggering this event
+ */
+enum libinput_switch_state
+libinput_event_switch_get_switch_state(struct libinput_event_switch *event);
+
+/**
+ * @ingroup event_switch
+ *
+ * @return The generic libinput_event of this event
+ */
+struct libinput_event *
+libinput_event_switch_get_base_event(struct libinput_event_switch *event);
+
+/**
+ * @ingroup event_switch
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput switch event
+ * @return The event time for this event
+ */
+uint32_t
+libinput_event_switch_get_time(struct libinput_event_switch *event);
+
+/**
+ * @ingroup event_switch
+ *
+ * @note Timestamps may not always increase. See @ref event_timestamps for
+ * details.
+ *
+ * @param event The libinput switch event
+ * @return The event time for this event in microseconds
+ */
+uint64_t
+libinput_event_switch_get_time_usec(struct libinput_event_switch *event);
+
+/**
+ * @defgroup base Initialization and manipulation of libinput contexts
+ */
+
+/**
+ * @ingroup base
+ * @struct libinput_interface
+ *
+ * libinput does not open file descriptors to devices directly, instead
+ * open_restricted() and close_restricted() are called for each path that
+ * must be opened.
+ *
+ * @see libinput_udev_create_context
+ * @see libinput_path_create_context
+ */
+struct libinput_interface {
+	/**
+	 * Open the device at the given path with the flags provided and
+	 * return the fd.
+	 *
+	 * @param path The device path to open
+	 * @param flags Flags as defined by open(2)
+	 * @param user_data The user_data provided in
+	 * libinput_udev_create_context()
+	 *
+	 * @return The file descriptor, or a negative errno on failure.
+	 */
+	int (*open_restricted)(const char *path, int flags, void *user_data);
+	/**
+	 * Close the file descriptor.
+	 *
+	 * @param fd The file descriptor to close
+	 * @param user_data The user_data provided in
+	 * libinput_udev_create_context()
+	 */
+	void (*close_restricted)(int fd, void *user_data);
+};
+
+/**
+ * @ingroup base
+ *
+ * Create a new libinput context from udev. This context is inactive until
+ * assigned a seat ID with libinput_udev_assign_seat().
+ *
+ * @param interface The callback interface
+ * @param user_data Caller-specific data passed to the various callback
+ * interfaces.
+ * @param udev An already initialized udev context
+ *
+ * @return An initialized, but inactive libinput context or NULL on error
+ */
+struct libinput *
+libinput_udev_create_context(const struct libinput_interface *interface,
+			     void *user_data,
+			     struct udev *udev);
+
+/**
+ * @ingroup base
+ *
+ * Assign a seat to this libinput context. New devices or the removal of
+ * existing devices will appear as events during libinput_dispatch().
+ *
+ * libinput_udev_assign_seat() succeeds even if no input devices are currently
+ * available on this seat, or if devices are available but fail to open in
+ * @ref libinput_interface::open_restricted. Devices that do not have the
+ * minimum capabilities to be recognized as pointer, keyboard or touch
+ * device are ignored. Such devices and those that failed to open
+ * ignored until the next call to libinput_resume().
+ *
+ * This function may only be called once per context.
+ *
+ * @param libinput A libinput context initialized with
+ * libinput_udev_create_context()
+ * @param seat_id A seat identifier. This string must not be NULL.
+ *
+ * @return 0 on success or -1 on failure.
+ */
+int
+libinput_udev_assign_seat(struct libinput *libinput,
+			  const char *seat_id);
+
+/**
+ * @ingroup base
+ *
+ * Create a new libinput context that requires the caller to manually add or
+ * remove devices with libinput_path_add_device() and
+ * libinput_path_remove_device().
+ *
+ * The context is fully initialized but will not generate events until at
+ * least one device has been added.
+ *
+ * The reference count of the context is initialized to 1. See @ref
+ * libinput_unref.
+ *
+ * @param interface The callback interface
+ * @param user_data Caller-specific data passed to the various callback
+ * interfaces.
+ *
+ * @return An initialized, empty libinput context.
+ */
+struct libinput *
+libinput_path_create_context(const struct libinput_interface *interface,
+			     void *user_data);
+
+/**
+ * @ingroup base
+ *
+ * Add a device to a libinput context initialized with
+ * libinput_path_create_context(). If successful, the device will be
+ * added to the internal list and re-opened on libinput_resume(). The device
+ * can be removed with libinput_path_remove_device().
+ *
+ * If the device was successfully initialized, it is returned in the device
+ * argument. The lifetime of the returned device pointer is limited until
+ * the next libinput_dispatch(), use libinput_device_ref() to keep a permanent
+ * reference.
+ *
+ * @param libinput A previously initialized libinput context
+ * @param path Path to an input device
+ * @return The newly initiated device on success, or NULL on failure.
+ *
+ * @note It is an application bug to call this function on a libinput
+ * context initialized with libinput_udev_create_context().
+ */
+struct libinput_device *
+libinput_path_add_device(struct libinput *libinput,
+			 const char *path);
+
+/**
+ * @ingroup base
+ *
+ * Remove a device from a libinput context initialized with
+ * libinput_path_create_context() or added to such a context with
+ * libinput_path_add_device().
+ *
+ * Events already processed from this input device are kept in the queue,
+ * the @ref LIBINPUT_EVENT_DEVICE_REMOVED event marks the end of events for
+ * this device.
+ *
+ * If no matching device exists, this function does nothing.
+ *
+ * @param device A libinput device
+ *
+ * @note It is an application bug to call this function on a libinput
+ * context initialized with libinput_udev_create_context().
+ */
+void
+libinput_path_remove_device(struct libinput_device *device);
+
+/**
+ * @ingroup base
+ *
+ * libinput keeps a single file descriptor for all events. Call into
+ * libinput_dispatch() if any events become available on this fd.
+ *
+ * @return The file descriptor used to notify of pending events.
+ */
+int
+libinput_get_fd(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Main event dispatchment function. Reads events of the file descriptors
+ * and processes them internally. Use libinput_get_event() to retrieve the
+ * events.
+ *
+ * Dispatching does not necessarily queue libinput events. This function
+ * should be called immediately once data is available on the file
+ * descriptor returned by libinput_get_fd(). libinput has a number of
+ * timing-sensitive features (e.g. tap-to-click), any delay in calling
+ * libinput_dispatch() may prevent these features from working correctly.
+ *
+ * @param libinput A previously initialized libinput context
+ *
+ * @return 0 on success, or a negative errno on failure
+ */
+int
+libinput_dispatch(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Retrieve the next event from libinput's internal event queue.
+ *
+ * After handling the retrieved event, the caller must destroy it using
+ * libinput_event_destroy().
+ *
+ * @param libinput A previously initialized libinput context
+ * @return The next available event, or NULL if no event is available.
+ */
+struct libinput_event *
+libinput_get_event(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Return the type of the next event in the internal queue. This function
+ * does not pop the event off the queue and the next call to
+ * libinput_get_event() returns that event.
+ *
+ * @param libinput A previously initialized libinput context
+ * @return The event type of the next available event or @ref
+ * LIBINPUT_EVENT_NONE if no event is available.
+ */
+enum libinput_event_type
+libinput_next_event_type(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Set caller-specific data associated with this context. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param libinput A previously initialized libinput context
+ * @param user_data Caller-specific data passed to the various callback
+ * interfaces.
+ */
+void
+libinput_set_user_data(struct libinput *libinput,
+		       void *user_data);
+
+/**
+ * @ingroup base
+ *
+ * Get the caller-specific data associated with this context, if any.
+ *
+ * @param libinput A previously initialized libinput context
+ * @return The caller-specific data previously assigned in
+ * libinput_create_udev().
+ */
+void *
+libinput_get_user_data(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Resume a suspended libinput context. This re-enables device
+ * monitoring and adds existing devices.
+ *
+ * @param libinput A previously initialized libinput context
+ * @see libinput_suspend
+ *
+ * @return 0 on success or -1 on failure
+ */
+int
+libinput_resume(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Suspend monitoring for new devices and close existing devices.
+ * This all but terminates libinput but does keep the context
+ * valid to be resumed with libinput_resume().
+ *
+ * @param libinput A previously initialized libinput context
+ */
+void
+libinput_suspend(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Add a reference to the context. A context is destroyed whenever the
+ * reference count reaches 0. See @ref libinput_unref.
+ *
+ * @param libinput A previously initialized valid libinput context
+ * @return The passed libinput context
+ */
+struct libinput *
+libinput_ref(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Dereference the libinput context. After this, the context may have been
+ * destroyed, if the last reference was dereferenced. If so, the context is
+ * invalid and may not be interacted with.
+ *
+ * @bug When the refcount reaches zero, libinput_unref() releases resources
+ * even if a caller still holds refcounted references to related resources
+ * (e.g. a libinput_device). When libinput_unref() returns
+ * NULL, the caller must consider any resources related to that context
+ * invalid. See https://bugs.freedesktop.org/show_bug.cgi?id=91872.
+ *
+ * Example code:
+ * @code
+ * li = libinput_path_create_context(&interface, NULL);
+ * device = libinput_path_add_device(li, "/dev/input/event0");
+ * // get extra reference to device
+ * libinput_device_ref(device);
+ *
+ * // refcount reaches 0, so *all* resources are cleaned up,
+ * // including device
+ * libinput_unref(li);
+ *
+ * // INCORRECT: device has been cleaned up and must not be used
+ * // li = libinput_device_get_context(device);
+ * @endcode
+ *
+ * @param libinput A previously initialized libinput context
+ * @return NULL if context was destroyed otherwise the passed context
+ */
+struct libinput *
+libinput_unref(struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Set the log priority for the libinput context. Messages with priorities
+ * equal to or higher than the argument will be printed to the context's
+ * log handler.
+ *
+ * The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
+ *
+ * @param libinput A previously initialized libinput context
+ * @param priority The minimum priority of log messages to print.
+ *
+ * @see libinput_log_set_handler
+ * @see libinput_log_get_priority
+ */
+void
+libinput_log_set_priority(struct libinput *libinput,
+			  enum libinput_log_priority priority);
+
+/**
+ * @ingroup base
+ *
+ * Get the context's log priority. Messages with priorities equal to or
+ * higher than the argument will be printed to the current log handler.
+ *
+ * The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
+ *
+ * @param libinput A previously initialized libinput context
+ * @return The minimum priority of log messages to print.
+ *
+ * @see libinput_log_set_handler
+ * @see libinput_log_set_priority
+ */
+enum libinput_log_priority
+libinput_log_get_priority(const struct libinput *libinput);
+
+/**
+ * @ingroup base
+ *
+ * Log handler type for custom logging.
+ *
+ * @param libinput The libinput context
+ * @param priority The priority of the current message
+ * @param format Message format in printf-style
+ * @param args Message arguments
+ *
+ * @see libinput_log_set_priority
+ * @see libinput_log_get_priority
+ * @see libinput_log_set_handler
+ */
+typedef void (*libinput_log_handler)(struct libinput *libinput,
+				     enum libinput_log_priority priority,
+				     const char *format, va_list args)
+	   LIBINPUT_ATTRIBUTE_PRINTF(3, 0);
+
+/**
+ * @ingroup base
+ *
+ * Set the context's log handler. Messages with priorities equal to or
+ * higher than the context's log priority will be passed to the given
+ * log handler.
+ *
+ * The default log handler prints to stderr.
+ *
+ * @param libinput A previously initialized libinput context
+ * @param log_handler The log handler for library messages.
+ *
+ * @see libinput_log_set_priority
+ * @see libinput_log_get_priority
+ */
+void
+libinput_log_set_handler(struct libinput *libinput,
+			 libinput_log_handler log_handler);
+
+/**
+ * @defgroup seat Initialization and manipulation of seats
+ *
+ * A seat has two identifiers, the physical name and the logical name. A
+ * device is always assigned to exactly one seat. It may change to a
+ * different logical seat but it cannot change physical seats. See @ref
+ * seats for details.
+ */
+
+/**
+ * @ingroup seat
+ *
+ * Increase the refcount of the seat. A seat will be freed whenever the
+ * refcount reaches 0. This may happen during libinput_dispatch() if the
+ * seat was removed from the system. A caller must ensure to reference
+ * the seat correctly to avoid dangling pointers.
+ *
+ * @param seat A previously obtained seat
+ * @return The passed seat
+ */
+struct libinput_seat *
+libinput_seat_ref(struct libinput_seat *seat);
+
+/**
+ * @ingroup seat
+ *
+ * Decrease the refcount of the seat. A seat will be freed whenever the
+ * refcount reaches 0. This may happen during libinput_dispatch() if the
+ * seat was removed from the system. A caller must ensure to reference
+ * the seat correctly to avoid dangling pointers.
+ *
+ * @param seat A previously obtained seat
+ * @return NULL if seat was destroyed, otherwise the passed seat
+ */
+struct libinput_seat *
+libinput_seat_unref(struct libinput_seat *seat);
+
+/**
+ * @ingroup seat
+ *
+ * Set caller-specific data associated with this seat. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param seat A previously obtained seat
+ * @param user_data Caller-specific data pointer
+ * @see libinput_seat_get_user_data
+ */
+void
+libinput_seat_set_user_data(struct libinput_seat *seat, void *user_data);
+
+/**
+ * @ingroup seat
+ *
+ * Get the caller-specific data associated with this seat, if any.
+ *
+ * @param seat A previously obtained seat
+ * @return Caller-specific data pointer or NULL if none was set
+ * @see libinput_seat_set_user_data
+ */
+void *
+libinput_seat_get_user_data(struct libinput_seat *seat);
+
+/**
+ * @ingroup seat
+ *
+ * Get the libinput context from the seat.
+ *
+ * @param seat A previously obtained seat
+ * @return The libinput context for this seat.
+ */
+struct libinput *
+libinput_seat_get_context(struct libinput_seat *seat);
+
+/**
+ * @ingroup seat
+ *
+ * Return the physical name of the seat. For libinput contexts created from
+ * udev, this is always the same value as passed into
+ * libinput_udev_assign_seat() and all seats from that context will have
+ * the same physical name.
+ *
+ * The physical name of the seat is one that is usually set by the system or
+ * lower levels of the stack. In most cases, this is the base filter for
+ * devices - devices assigned to seats outside the current seat will not
+ * be available to the caller.
+ *
+ * @param seat A previously obtained seat
+ * @return The physical name of this seat
+ */
+const char *
+libinput_seat_get_physical_name(struct libinput_seat *seat);
+
+/**
+ * @ingroup seat
+ *
+ * Return the logical name of the seat. This is an identifier to group sets
+ * of devices within the compositor.
+ *
+ * @param seat A previously obtained seat
+ * @return The logical name of this seat
+ */
+const char *
+libinput_seat_get_logical_name(struct libinput_seat *seat);
+
+/**
+ * @defgroup device Initialization and manipulation of input devices
+ */
+
+/**
+ * @ingroup device
+ *
+ * Increase the refcount of the input device. An input device will be freed
+ * whenever the refcount reaches 0. This may happen during
+ * libinput_dispatch() if the device was removed from the system. A caller
+ * must ensure to reference the device correctly to avoid dangling pointers.
+ *
+ * @param device A previously obtained device
+ * @return The passed device
+ */
+struct libinput_device *
+libinput_device_ref(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Decrease the refcount of the input device. An input device will be freed
+ * whenever the refcount reaches 0. This may happen during libinput_dispatch
+ * if the device was removed from the system. A caller must ensure to
+ * reference the device correctly to avoid dangling pointers.
+ *
+ * @param device A previously obtained device
+ * @return NULL if the device was destroyed, otherwise the passed device
+ */
+struct libinput_device *
+libinput_device_unref(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Set caller-specific data associated with this input device. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param device A previously obtained device
+ * @param user_data Caller-specific data pointer
+ * @see libinput_device_get_user_data
+ */
+void
+libinput_device_set_user_data(struct libinput_device *device, void *user_data);
+
+/**
+ * @ingroup device
+ *
+ * Get the caller-specific data associated with this input device, if any.
+ *
+ * @param device A previously obtained device
+ * @return Caller-specific data pointer or NULL if none was set
+ * @see libinput_device_set_user_data
+ */
+void *
+libinput_device_get_user_data(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the libinput context from the device.
+ *
+ * @param device A previously obtained device
+ * @return The libinput context for this device.
+ */
+struct libinput *
+libinput_device_get_context(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the device group this device is assigned to. Some physical
+ * devices like graphics tablets are represented by multiple kernel
+ * devices and thus by multiple struct @ref libinput_device.
+ *
+ * libinput assigns these devices to the same @ref libinput_device_group
+ * allowing the caller to identify such devices and adjust configuration
+ * settings accordingly. For example, setting a tablet to left-handed often
+ * means turning it upside down. A touch device on the same tablet would
+ * need to be turned upside down too to work correctly.
+ *
+ * All devices are part of a device group though for most devices the group
+ * will be a singleton. A device is assigned to a device group on @ref
+ * LIBINPUT_EVENT_DEVICE_ADDED and removed from that group on @ref
+ * LIBINPUT_EVENT_DEVICE_REMOVED. It is up to the caller to track how many
+ * devices are in each device group.
+ *
+ * @dot
+ * digraph groups_libinput {
+ *   rankdir="TB";
+ *   node [
+ *     shape="box";
+ *   ]
+ *
+ *   mouse [ label="mouse"; URL="\ref libinput_device"];
+ *   kbd [ label="keyboard"; URL="\ref libinput_device"];
+ *
+ *   pen [ label="tablet pen"; URL="\ref libinput_device"];
+ *   touch [ label="tablet touch"; URL="\ref libinput_device"];
+ *   pad [ label="tablet pad"; URL="\ref libinput_device"];
+ *
+ *   group1 [ label="group 1"; URL="\ref libinput_device_group"];
+ *   group2 [ label="group 2"; URL="\ref libinput_device_group"];
+ *   group3 [ label="group 3"; URL="\ref libinput_device_group"];
+ *
+ *   mouse -> group1
+ *   kbd -> group2
+ *
+ *   pen -> group3;
+ *   touch -> group3;
+ *   pad -> group3;
+ * }
+ * @enddot
+ *
+ * Device groups do not get re-used once the last device in the group was
+ * removed, i.e. unplugging and re-plugging a physical device with grouped
+ * devices will return a different device group after every unplug.
+ *
+ * The returned device group is not refcounted and may become invalid after
+ * the next call to libinput. Use libinput_device_group_ref() and
+ * libinput_device_group_unref() to continue using the handle outside of the
+ * immediate scope.
+ *
+ * Device groups are assigned based on the <b>LIBINPUT_DEVICE_GROUP</b> udev
+ * property, see @ref udev_config.
+ *
+ * @return The device group this device belongs to
+ */
+struct libinput_device_group *
+libinput_device_get_device_group(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the system name of the device.
+ *
+ * To get the descriptive device name, use libinput_device_get_name().
+ *
+ * @param device A previously obtained device
+ * @return System name of the device
+ *
+ */
+const char *
+libinput_device_get_sysname(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * The descriptive device name as advertised by the kernel and/or the
+ * hardware itself. To get the sysname for this device, use
+ * libinput_device_get_sysname().
+ *
+ * The lifetime of the returned string is tied to the struct
+ * libinput_device. The string may be the empty string but is never NULL.
+ *
+ * @param device A previously obtained device
+ * @return The device name
+ */
+const char *
+libinput_device_get_name(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the product ID for this device.
+ *
+ * @param device A previously obtained device
+ * @return The product ID of this device
+ */
+unsigned int
+libinput_device_get_id_product(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the vendor ID for this device.
+ *
+ * @param device A previously obtained device
+ * @return The vendor ID of this device
+ */
+unsigned int
+libinput_device_get_id_vendor(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * A device may be mapped to a single output, or all available outputs. If a
+ * device is mapped to a single output only, a relative device may not move
+ * beyond the boundaries of this output. An absolute device has its input
+ * coordinates mapped to the extents of this output.
+ *
+ * @note <b>Use of this function is discouraged.</b> Its return value is not
+ * precisely defined and may not be understood by the caller or may be
+ * insufficient to map the device. Instead, the system configuration could
+ * set a udev property the caller understands and interprets correctly. The
+ * caller could then obtain device with libinput_device_get_udev_device()
+ * and query it for this property. For more complex cases, the caller
+ * must implement monitor-to-device association heuristics.
+ *
+ * @return The name of the output this device is mapped to, or NULL if no
+ * output is set
+ */
+const char *
+libinput_device_get_output_name(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Get the seat associated with this input device, see @ref seats for
+ * details.
+ *
+ * A seat can be uniquely identified by the physical and logical seat name.
+ * There will ever be only one seat instance with a given physical and logical
+ * seat name pair at any given time, but if no external reference is kept, it
+ * may be destroyed if no device belonging to it is left.
+ *
+ * The returned seat is not refcounted and may become invalid after
+ * the next call to libinput. Use libinput_seat_ref() and
+ * libinput_seat_unref() to continue using the handle outside of the
+ * immediate scope.
+ *
+ * @param device A previously obtained device
+ * @return The seat this input device belongs to
+ */
+struct libinput_seat *
+libinput_device_get_seat(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Change the logical seat associated with this device by removing the
+ * device and adding it to the new seat.
+ *
+ * This command is identical to physically unplugging the device, then
+ * re-plugging it as a member of the new seat. libinput will generate a
+ * @ref LIBINPUT_EVENT_DEVICE_REMOVED event and this @ref libinput_device is
+ * considered removed from the context; it will not generate further events
+ * and will be freed when the refcount reaches zero.
+ * A @ref LIBINPUT_EVENT_DEVICE_ADDED event is generated with a new @ref
+ * libinput_device handle. It is the caller's responsibility to update
+ * references to the new device accordingly.
+ *
+ * If the logical seat name already exists in the device's physical seat,
+ * the device is added to this seat. Otherwise, a new seat is created.
+ *
+ * @note This change applies to this device until removal or @ref
+ * libinput_suspend(), whichever happens earlier.
+ *
+ * @param device A previously obtained device
+ * @param name The new logical seat name
+ * @return 0 on success, non-zero on error
+ */
+int
+libinput_device_set_seat_logical_name(struct libinput_device *device,
+				      const char *name);
+
+/**
+ * @ingroup device
+ *
+ * Return a udev handle to the device that is this libinput device, if any.
+ * The returned handle has a refcount of at least 1, the caller must call
+ * <i>udev_device_unref()</i> once to release the associated resources.
+ * See the [libudev documentation]
+ * (http://www.freedesktop.org/software/systemd/libudev/) for details.
+ *
+ * Some devices may not have a udev device, or the udev device may be
+ * unobtainable. This function returns NULL if no udev device was available.
+ *
+ * Calling this function multiple times for the same device may not
+ * return the same udev handle each time.
+ *
+ * @param device A previously obtained device
+ * @return A udev handle to the device with a refcount of >= 1 or NULL.
+ * @retval NULL This device is not represented by a udev device
+ */
+struct udev_device *
+libinput_device_get_udev_device(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Update the LEDs on the device, if any. If the device does not have
+ * LEDs, or does not have one or more of the LEDs given in the mask, this
+ * function does nothing.
+ *
+ * @param device A previously obtained device
+ * @param leds A mask of the LEDs to set, or unset.
+ */
+void
+libinput_device_led_update(struct libinput_device *device,
+			   enum libinput_led leds);
+
+/**
+ * @ingroup device
+ *
+ * Check if the given device has the specified capability
+ *
+ * @return Non-zero if the given device has the capability or zero otherwise
+ */
+int
+libinput_device_has_capability(struct libinput_device *device,
+			       enum libinput_device_capability capability);
+
+/**
+ * @ingroup device
+ *
+ * Get the physical size of a device in mm, where meaningful. This function
+ * only succeeds on devices with the required data, i.e. tablets, touchpads
+ * and touchscreens.
+ *
+ * If this function returns nonzero, width and height are unmodified.
+ *
+ * @param device The device
+ * @param width Set to the width of the device
+ * @param height Set to the height of the device
+ * @return 0 on success, or nonzero otherwise
+ */
+int
+libinput_device_get_size(struct libinput_device *device,
+			 double *width,
+			 double *height);
+
+/**
+ * @ingroup device
+ *
+ * Check if a @ref LIBINPUT_DEVICE_CAP_POINTER device has a button with the
+ * given code (see linux/input.h).
+ *
+ * @param device A current input device
+ * @param code Button code to check for, e.g. <i>BTN_LEFT</i>
+ *
+ * @return 1 if the device supports this button code, 0 if it does not, -1
+ * on error.
+ */
+int
+libinput_device_pointer_has_button(struct libinput_device *device, uint32_t code);
+
+/**
+ * @ingroup device
+ *
+ * Check if a @ref LIBINPUT_DEVICE_CAP_KEYBOARD device has a key with the
+ * given code (see linux/input.h).
+ *
+ * @param device A current input device
+ * @param code Key code to check for, e.g. <i>KEY_ESC</i>
+ *
+ * @return 1 if the device supports this key code, 0 if it does not, -1
+ * on error.
+ */
+int
+libinput_device_keyboard_has_key(struct libinput_device *device,
+				 uint32_t code);
+
+/**
+ * @ingroup device
+ *
+ * Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
+ * given type.
+ *
+ * @param device A current input device
+ * @param sw Switch to check for
+ *
+ * @return 1 if the device supports this switch, 0 if it does not, -1
+ * on error.
+ */
+int
+libinput_device_switch_has_switch(struct libinput_device *device,
+				  enum libinput_switch sw);
+
+/**
+ * @ingroup device
+ *
+ * Return the number of buttons on a device with the
+ * @ref LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
+ * Buttons on a pad device are numbered sequentially, see @ref
+ * tablet-pad-buttons for details.
+ *
+ * @param device A current input device
+ *
+ * @return The number of buttons supported by the device.
+ */
+int
+libinput_device_tablet_pad_get_num_buttons(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Return the number of rings a device with the @ref
+ * LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
+ *
+ * @param device A current input device
+ *
+ * @return The number of rings or 0 if the device has no rings.
+ *
+ * @see libinput_event_tablet_pad_get_ring_number
+ */
+int
+libinput_device_tablet_pad_get_num_rings(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Return the number of strips a device with the @ref
+ * LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
+ *
+ * @param device A current input device
+ *
+ * @return The number of strips or 0 if the device has no strips.
+ *
+ * @see libinput_event_tablet_pad_get_strip_number
+ */
+int
+libinput_device_tablet_pad_get_num_strips(struct libinput_device *device);
+
+/**
+ * @ingroup device
+ *
+ * Increase the refcount of the device group. A device group will be freed
+ * whenever the refcount reaches 0. This may happen during
+ * libinput_dispatch() if all devices of this group were removed from the
+ * system. A caller must ensure to reference the device group correctly to
+ * avoid dangling pointers.
+ *
+ * @param group A previously obtained device group
+ * @return The passed device group
+ */
+struct libinput_device_group *
+libinput_device_group_ref(struct libinput_device_group *group);
+
+/**
+ * @ingroup device
+ *
+ * Decrease the refcount of the device group. A device group will be freed
+ * whenever the refcount reaches 0. This may happen during
+ * libinput_dispatch() if all devices of this group were removed from the
+ * system. A caller must ensure to reference the device group correctly to
+ * avoid dangling pointers.
+ *
+ * @param group A previously obtained device group
+ * @return NULL if the device group was destroyed, otherwise the passed
+ * device group
+ */
+struct libinput_device_group *
+libinput_device_group_unref(struct libinput_device_group *group);
+
+/**
+ * @ingroup device
+ *
+ * Set caller-specific data associated with this device group. libinput does
+ * not manage, look at, or modify this data. The caller must ensure the
+ * data is valid.
+ *
+ * @param group A previously obtained device group
+ * @param user_data Caller-specific data pointer
+ * @see libinput_device_group_get_user_data
+ */
+void
+libinput_device_group_set_user_data(struct libinput_device_group *group,
+				    void *user_data);
+
+/**
+ * @ingroup device
+ *
+ * Get the caller-specific data associated with this input device group, if
+ * any.
+ *
+ * @param group A previously obtained group
+ * @return Caller-specific data pointer or NULL if none was set
+ * @see libinput_device_group_set_user_data
+ */
+void *
+libinput_device_group_get_user_data(struct libinput_device_group *group);
+
+/**
+ * @defgroup config Device configuration
+ *
+ * Enable, disable, change and/or check for device-specific features. For
+ * all features, libinput assigns a default based on the hardware
+ * configuration. This default can be obtained with the respective
+ * get_default call.
+ *
+ * Configuration options are device dependent and not all options are
+ * supported on all devices. For all configuration options, libinput
+ * provides a call to check if a configuration option is available on a
+ * device (e.g. libinput_device_config_calibration_has_matrix())
+ *
+ * Some configuration option may be dependent on or mutually exclusive with
+ * with other options. The behavior in those cases is
+ * implementation-dependent, the caller must ensure that the options are set
+ * in the right order.
+ *
+ * Below is a general grouping of configuration options according to device
+ * type. Note that this is a guide only and not indicative of any specific
+ * device.
+ * - Touchpad:
+ *    - libinput_device_config_tap_set_enabled()
+ *    - libinput_device_config_tap_set_drag_enabled()
+ *    - libinput_device_config_tap_set_drag_lock_enabled()
+ *    - libinput_device_config_click_set_method()
+ *    - libinput_device_config_scroll_set_method()
+ *    - libinput_device_config_dwt_set_enabled()
+ * - Touchscreens:
+ *    - libinput_device_config_calibration_set_matrix()
+ * - Pointer devices (mice, trackballs, touchpads):
+ *    - libinput_device_config_accel_set_speed()
+ *    - libinput_device_config_accel_set_profile()
+ *    - libinput_device_config_scroll_set_natural_scroll_enabled()
+ *    - libinput_device_config_left_handed_set()
+ *    - libinput_device_config_middle_emulation_set_enabled()
+ *    - libinput_device_config_rotation_set_angle()
+ * - All devices:
+ *    - libinput_device_config_send_events_set_mode()
+ */
+
+/**
+ * @ingroup config
+ *
+ * Status codes returned when applying configuration settings.
+ */
+enum libinput_config_status {
+	LIBINPUT_CONFIG_STATUS_SUCCESS = 0,	/**< Config applied successfully */
+	LIBINPUT_CONFIG_STATUS_UNSUPPORTED,	/**< Configuration not available on
+						     this device */
+	LIBINPUT_CONFIG_STATUS_INVALID,		/**< Invalid parameter range */
+};
+
+/**
+ * @ingroup config
+ *
+ * Return a string describing the error.
+ *
+ * @param status The status to translate to a string
+ * @return A human-readable string representing the error or NULL for an
+ * invalid status.
+ */
+const char *
+libinput_config_status_to_str(enum libinput_config_status status);
+
+/**
+ * @ingroup config
+ */
+enum libinput_config_tap_state {
+	LIBINPUT_CONFIG_TAP_DISABLED, /**< Tapping is to be disabled, or is
+					currently disabled */
+	LIBINPUT_CONFIG_TAP_ENABLED, /**< Tapping is to be enabled, or is
+				       currently enabled */
+};
+
+/**
+ * @ingroup config
+ *
+ * Check if the device supports tap-to-click and how many fingers can be
+ * used for tapping. See
+ * libinput_device_config_tap_set_enabled() for more information.
+ *
+ * @param device The device to configure
+ * @return The number of fingers that can generate a tap event, or 0 if the
+ * device does not support tapping.
+ *
+ * @see libinput_device_config_tap_set_enabled
+ * @see libinput_device_config_tap_get_enabled
+ * @see libinput_device_config_tap_get_default_enabled
+ */
+int
+libinput_device_config_tap_get_finger_count(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable tap-to-click on this device, with a default mapping of
+ * 1, 2, 3 finger tap mapping to left, right, middle click, respectively.
+ * Tapping is limited by the number of simultaneous touches
+ * supported by the device, see
+ * libinput_device_config_tap_get_finger_count().
+ *
+ * @param device The device to configure
+ * @param enable @ref LIBINPUT_CONFIG_TAP_ENABLED to enable tapping or @ref
+ * LIBINPUT_CONFIG_TAP_DISABLED to disable tapping
+ *
+ * @return A config status code. Disabling tapping on a device that does not
+ * support tapping always succeeds.
+ *
+ * @see libinput_device_config_tap_get_finger_count
+ * @see libinput_device_config_tap_get_enabled
+ * @see libinput_device_config_tap_get_default_enabled
+ */
+enum libinput_config_status
+libinput_device_config_tap_set_enabled(struct libinput_device *device,
+				       enum libinput_config_tap_state enable);
+
+/**
+ * @ingroup config
+ *
+ * Check if tap-to-click is enabled on this device. If the device does not
+ * support tapping, this function always returns @ref
+ * LIBINPUT_CONFIG_TAP_DISABLED.
+ *
+ * @param device The device to configure
+ *
+ * @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is currently enabled
+ * @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping is currently disabled
+ *
+ * @see libinput_device_config_tap_get_finger_count
+ * @see libinput_device_config_tap_set_enabled
+ * @see libinput_device_config_tap_get_default_enabled
+ */
+enum libinput_config_tap_state
+libinput_device_config_tap_get_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Return the default setting for whether tap-to-click is enabled on this
+ * device.
+ *
+ * @param device The device to configure
+ * @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is enabled by default
+ * @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping Is disabled by default
+ *
+ * @see libinput_device_config_tap_get_finger_count
+ * @see libinput_device_config_tap_set_enabled
+ * @see libinput_device_config_tap_get_enabled
+ */
+enum libinput_config_tap_state
+libinput_device_config_tap_get_default_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ */
+enum libinput_config_tap_button_map {
+	/** 1/2/3 finger tap maps to left/right/middle */
+	LIBINPUT_CONFIG_TAP_MAP_LRM,
+	/** 1/2/3 finger tap maps to left/middle/right*/
+	LIBINPUT_CONFIG_TAP_MAP_LMR,
+};
+
+/**
+ * @ingroup config
+ *
+ * Set the finger number to button number mapping for tap-to-click. The
+ * default mapping on most devices is to have a 1, 2 and 3 finger tap to map
+ * to the left, right and middle button, respectively.
+ * A device may permit changing the button mapping but disallow specific
+ * maps. In this case @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED is returned,
+ * the caller is expected to handle this case correctly.
+ *
+ * Changing the button mapping may not take effect immediately,
+ * the device may wait until it is in a neutral state before applying any
+ * changes.
+ *
+ * The mapping may be changed when tap-to-click is disabled. The new mapping
+ * takes effect when tap-to-click is enabled in the future.
+ *
+ * @note It is an application bug to call this function for devices where
+ * libinput_device_config_tap_get_finger_count() returns 0.
+ *
+ * @param device The device to configure
+ * @param map The new finger-to-button number mapping
+ * @return A config status code. Changing the order on a device that does not
+ * support tapping always fails with @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED.
+ *
+ * @see libinput_device_config_tap_get_button_map
+ * @see libinput_device_config_tap_get_default_button_map
+ */
+enum libinput_config_status
+libinput_device_config_tap_set_button_map(struct libinput_device *device,
+					    enum libinput_config_tap_button_map map);
+
+/**
+ * @ingroup config
+ *
+ * Get the finger number to button number mapping for tap-to-click.
+ *
+ * The return value for a device that does not support tapping is always
+ * @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
+ *
+ * @note It is an application bug to call this function for devices where
+ * libinput_device_config_tap_get_finger_count() returns 0.
+ *
+ * @param device The device to configure
+ * @return The current finger-to-button number mapping
+ *
+ * @see libinput_device_config_tap_set_button_map
+ * @see libinput_device_config_tap_get_default_button_map
+ */
+enum libinput_config_tap_button_map
+libinput_device_config_tap_get_button_map(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default finger number to button number mapping for tap-to-click.
+ *
+ * The return value for a device that does not support tapping is always
+ * @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
+ *
+ * @note It is an application bug to call this function for devices where
+ * libinput_device_config_tap_get_finger_count() returns 0.
+ *
+ * @param device The device to configure
+ * @return The current finger-to-button number mapping
+ *
+ * @see libinput_device_config_tap_set_button_map
+ * @see libinput_device_config_tap_get_default_button_map
+ */
+enum libinput_config_tap_button_map
+libinput_device_config_tap_get_default_button_map(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * A config status to distinguish or set dragging on a device. Currently
+ * implemented for tap-and-drag only, see
+ * libinput_device_config_tap_set_drag_enabled()
+ */
+enum libinput_config_drag_state {
+	/**
+	 * Drag is to be disabled, or is
+	 * currently disabled.
+	 */
+	LIBINPUT_CONFIG_DRAG_DISABLED,
+	/**
+	 * Drag is to be enabled, or is
+	 * currently enabled
+	 */
+	LIBINPUT_CONFIG_DRAG_ENABLED,
+};
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable tap-and-drag on this device. When enabled, a
+ * single-finger tap immediately followed by a finger down results in a
+ * button down event, subsequent finger motion thus triggers a drag. The
+ * button is released on finger up. See @ref tapndrag for more details.
+ *
+ * @param device The device to configure
+ * @param enable @ref LIBINPUT_CONFIG_DRAG_ENABLED to enable, @ref
+ * LIBINPUT_CONFIG_DRAG_DISABLED to disable tap-and-drag
+ *
+ * @see libinput_device_config_tap_drag_get_enabled
+ * @see libinput_device_config_tap_drag_get_default_enabled
+ */
+enum libinput_config_status
+libinput_device_config_tap_set_drag_enabled(struct libinput_device *device,
+					    enum libinput_config_drag_state enable);
+
+/**
+ * @ingroup config
+ *
+ * Return whether tap-and-drag is enabled or disabled on this device.
+ *
+ * @param device The device to check
+ * @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled
+ * @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
+ * disabled
+ *
+ * @see libinput_device_config_tap_drag_set_enabled
+ * @see libinput_device_config_tap_drag_get_default_enabled
+ */
+enum libinput_config_drag_state
+libinput_device_config_tap_get_drag_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Return whether tap-and-drag is enabled or disabled by default on this
+ * device.
+ *
+ * @param device The device to check
+ * @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled by
+ * default
+ * @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
+ * disabled by default
+ *
+ * @see libinput_device_config_tap_drag_set_enabled
+ * @see libinput_device_config_tap_drag_get_enabled
+ */
+enum libinput_config_drag_state
+libinput_device_config_tap_get_default_drag_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ */
+enum libinput_config_drag_lock_state {
+	/** Drag lock is to be disabled, or is currently disabled */
+	LIBINPUT_CONFIG_DRAG_LOCK_DISABLED,
+	/** Drag lock is to be enabled, or is currently disabled */
+	LIBINPUT_CONFIG_DRAG_LOCK_ENABLED,
+};
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable drag-lock during tapping on this device. When enabled,
+ * a finger may be lifted and put back on the touchpad within a timeout and
+ * the drag process continues. When disabled, lifting the finger during a
+ * tap-and-drag will immediately stop the drag. See @ref tapndrag for
+ * details.
+ *
+ * Enabling drag lock on a device that has tapping disabled is permitted,
+ * but has no effect until tapping is enabled.
+ *
+ * @param device The device to configure
+ * @param enable @ref LIBINPUT_CONFIG_DRAG_LOCK_ENABLED to enable drag lock
+ * or @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED to disable drag lock
+ *
+ * @return A config status code. Disabling drag lock on a device that does not
+ * support tapping always succeeds.
+ *
+ * @see libinput_device_config_tap_get_drag_lock_enabled
+ * @see libinput_device_config_tap_get_default_drag_lock_enabled
+ */
+enum libinput_config_status
+libinput_device_config_tap_set_drag_lock_enabled(struct libinput_device *device,
+						 enum libinput_config_drag_lock_state enable);
+
+/**
+ * @ingroup config
+ *
+ * Check if drag-lock during tapping is enabled on this device. If the
+ * device does not support tapping, this function always returns
+ * @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
+ *
+ * Drag lock may be enabled even when tapping is disabled.
+ *
+ * @param device The device to configure
+ *
+ * @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED If drag lock is currently enabled
+ * @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is currently disabled
+ *
+ * @see libinput_device_config_tap_set_drag_lock_enabled
+ * @see libinput_device_config_tap_get_default_drag_lock_enabled
+ */
+enum libinput_config_drag_lock_state
+libinput_device_config_tap_get_drag_lock_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if drag-lock during tapping is enabled by default on this device.
+ * If the device does not support tapping, this function always returns
+ * @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
+ *
+ * Drag lock may be enabled by default even when tapping is disabled by
+ * default.
+ *
+ * @param device The device to configure
+ *
+ * @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED If drag lock is enabled by
+ * default
+ * @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is disabled by
+ * default
+ *
+ * @see libinput_device_config_tap_set_drag_lock_enabled
+ * @see libinput_device_config_tap_get_drag_lock_enabled
+ */
+enum libinput_config_drag_lock_state
+libinput_device_config_tap_get_default_drag_lock_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if the device can be calibrated via a calibration matrix.
+ *
+ * @param device The device to check
+ * @return Non-zero if the device can be calibrated, zero otherwise.
+ *
+ * @see libinput_device_config_calibration_set_matrix
+ * @see libinput_device_config_calibration_get_matrix
+ * @see libinput_device_config_calibration_get_default_matrix
+ */
+int
+libinput_device_config_calibration_has_matrix(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Apply the 3x3 transformation matrix to absolute device coordinates. This
+ * matrix has no effect on relative events.
+ *
+ * Given a 6-element array [a, b, c, d, e, f], the matrix is applied as
+ * @code
+ * [ a  b  c ]   [ x ]
+ * [ d  e  f ] * [ y ]
+ * [ 0  0  1 ]   [ 1 ]
+ * @endcode
+ *
+ * The translation component (c, f) is expected to be normalized to the
+ * device coordinate range. For example, the matrix
+ * @code
+ * [ 1 0  1 ]
+ * [ 0 1 -1 ]
+ * [ 0 0  1 ]
+ * @endcode
+ * moves all coordinates by 1 device-width to the right and 1 device-height
+ * up.
+ *
+ * The rotation matrix for rotation around the origin is defined as
+ * @code
+ * [ cos(a) -sin(a) 0 ]
+ * [ sin(a)  cos(a) 0 ]
+ * [   0      0     1 ]
+ * @endcode
+ * Note that any rotation requires an additional translation component to
+ * translate the rotated coordinates back into the original device space.
+ * The rotation matrixes for 90, 180 and 270 degrees clockwise are:
+ * @code
+ * 90 deg cw:		180 deg cw:		270 deg cw:
+ * [ 0 -1 1]		[ -1  0 1]		[  0 1 0 ]
+ * [ 1  0 0]		[  0 -1 1]		[ -1 0 1 ]
+ * [ 0  0 1]		[  0  0 1]		[  0 0 1 ]
+ * @endcode
+ *
+ * @param device The device to configure
+ * @param matrix An array representing the first two rows of a 3x3 matrix as
+ * described above.
+ *
+ * @return A config status code.
+ *
+ * @see libinput_device_config_calibration_has_matrix
+ * @see libinput_device_config_calibration_get_matrix
+ * @see libinput_device_config_calibration_get_default_matrix
+ */
+enum libinput_config_status
+libinput_device_config_calibration_set_matrix(struct libinput_device *device,
+					      const float matrix[6]);
+
+/**
+ * @ingroup config
+ *
+ * Return the current calibration matrix for this device.
+ *
+ * @param device The device to configure
+ * @param matrix Set to the array representing the first two rows of a 3x3 matrix as
+ * described in libinput_device_config_calibration_set_matrix().
+ *
+ * @return 0 if no calibration is set and the returned matrix is the
+ * identity matrix, 1 otherwise
+ *
+ * @see libinput_device_config_calibration_has_matrix
+ * @see libinput_device_config_calibration_set_matrix
+ * @see libinput_device_config_calibration_get_default_matrix
+ */
+int
+libinput_device_config_calibration_get_matrix(struct libinput_device *device,
+					      float matrix[6]);
+
+/**
+ * @ingroup config
+ *
+ * Return the default calibration matrix for this device. On most devices,
+ * this is the identity matrix. If the udev property
+ * <b>LIBINPUT_CALIBRATION_MATRIX</b> is set on the respective udev device,
+ * that property's value becomes the default matrix, see @ref udev_config.
+ *
+ * @param device The device to configure
+ * @param matrix Set to the array representing the first two rows of a 3x3 matrix as
+ * described in libinput_device_config_calibration_set_matrix().
+ *
+ * @return 0 if no calibration is set and the returned matrix is the
+ * identity matrix, 1 otherwise
+ *
+ * @see libinput_device_config_calibration_has_matrix
+ * @see libinput_device_config_calibration_set_matrix
+ * @see libinput_device_config_calibration_get_matrix
+ */
+int
+libinput_device_config_calibration_get_default_matrix(struct libinput_device *device,
+						      float matrix[6]);
+
+/**
+ * @ingroup config
+ *
+ * The send-event mode of a device defines when a device may generate events
+ * and pass those events to the caller.
+ */
+enum libinput_config_send_events_mode {
+	/**
+	 * Send events from this device normally. This is a placeholder
+	 * mode only, any device detected by libinput can be enabled. Do not
+	 * test for this value as bitmask.
+	 */
+	LIBINPUT_CONFIG_SEND_EVENTS_ENABLED = 0,
+	/**
+	 * Do not send events through this device. Depending on the device,
+	 * this may close all file descriptors on the device or it may leave
+	 * the file descriptors open and route events through a different
+	 * device.
+	 *
+	 * If this bit field is set, other disable modes may be
+	 * ignored. For example, if both @ref
+	 * LIBINPUT_CONFIG_SEND_EVENTS_DISABLED and @ref
+	 * LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE are set,
+	 * the device remains disabled when all external pointer devices are
+	 * unplugged.
+	 */
+	LIBINPUT_CONFIG_SEND_EVENTS_DISABLED = (1 << 0),
+	/**
+	 * If an external pointer device is plugged in, do not send events
+	 * from this device. This option may be available on built-in
+	 * touchpads.
+	 */
+	LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE = (1 << 1),
+};
+
+/**
+ * @ingroup config
+ *
+ * Return the possible send-event modes for this device. These modes define
+ * when a device may process and send events.
+ *
+ * @param device The device to configure
+ *
+ * @return A bitmask of possible modes.
+ *
+ * @see libinput_device_config_send_events_set_mode
+ * @see libinput_device_config_send_events_get_mode
+ * @see libinput_device_config_send_events_get_default_mode
+ */
+uint32_t
+libinput_device_config_send_events_get_modes(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the send-event mode for this device. The mode defines when the device
+ * processes and sends events to the caller.
+ *
+ * The selected mode may not take effect immediately. Events already
+ * received and processed from this device are unaffected and will be passed
+ * to the caller on the next call to libinput_get_event().
+ *
+ * If the mode is a bitmask of @ref libinput_config_send_events_mode,
+ * the device may wait for or generate events until it is in a neutral
+ * state. For example, this may include waiting for or generating button
+ * release events.
+ *
+ * If the device is already suspended, this function does nothing and
+ * returns success. Changing the send-event mode on a device that has been
+ * removed is permitted.
+ *
+ * @param device The device to configure
+ * @param mode A bitmask of send-events modes
+ *
+ * @return A config status code.
+ *
+ * @see libinput_device_config_send_events_get_modes
+ * @see libinput_device_config_send_events_get_mode
+ * @see libinput_device_config_send_events_get_default_mode
+ */
+enum libinput_config_status
+libinput_device_config_send_events_set_mode(struct libinput_device *device,
+					    uint32_t mode);
+
+/**
+ * @ingroup config
+ *
+ * Get the send-event mode for this device. The mode defines when the device
+ * processes and sends events to the caller.
+ *
+ * If a caller enables the bits for multiple modes, some of which are
+ * subsets of another mode libinput may drop the bits that are subsets. In
+ * other words, don't expect libinput_device_config_send_events_get_mode()
+ * to always return exactly the same bitmask as passed into
+ * libinput_device_config_send_events_set_mode().
+ *
+ * @param device The device to configure
+ * @return The current bitmask of the send-event mode for this device.
+ *
+ * @see libinput_device_config_send_events_get_modes
+ * @see libinput_device_config_send_events_set_mode
+ * @see libinput_device_config_send_events_get_default_mode
+ */
+uint32_t
+libinput_device_config_send_events_get_mode(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default send-event mode for this device. The mode defines when
+ * the device processes and sends events to the caller.
+ *
+ * @param device The device to configure
+ * @return The bitmask of the send-event mode for this device.
+ *
+ * @see libinput_device_config_send_events_get_modes
+ * @see libinput_device_config_send_events_set_mode
+ * @see libinput_device_config_send_events_get_mode
+ */
+uint32_t
+libinput_device_config_send_events_get_default_mode(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if a device uses libinput-internal pointer-acceleration.
+ *
+ * @param device The device to configure
+ *
+ * @return 0 if the device is not accelerated, nonzero if it is accelerated
+ *
+ * @see libinput_device_config_accel_set_speed
+ * @see libinput_device_config_accel_get_speed
+ * @see libinput_device_config_accel_get_default_speed
+ */
+int
+libinput_device_config_accel_is_available(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the pointer acceleration speed of this pointer device within a range
+ * of [-1, 1], where 0 is the default acceleration for this device, -1 is
+ * the slowest acceleration and 1 is the maximum acceleration available on
+ * this device. The actual pointer acceleration mechanism is
+ * implementation-dependent, as is the number of steps available within the
+ * range. libinput picks the semantically closest acceleration step if the
+ * requested value does not match a discrete setting.
+ *
+ * @param device The device to configure
+ * @param speed The normalized speed, in a range of [-1, 1]
+ *
+ * @return A config status code
+ *
+ * @see libinput_device_config_accel_is_available
+ * @see libinput_device_config_accel_get_speed
+ * @see libinput_device_config_accel_get_default_speed
+ */
+enum libinput_config_status
+libinput_device_config_accel_set_speed(struct libinput_device *device,
+				       double speed);
+
+/**
+ * @ingroup config
+ *
+ * Get the current pointer acceleration setting for this pointer device. The
+ * returned value is normalized to a range of [-1, 1].
+ * See libinput_device_config_accel_set_speed() for details.
+ *
+ * @param device The device to configure
+ *
+ * @return The current speed, range -1 to 1
+ *
+ * @see libinput_device_config_accel_is_available
+ * @see libinput_device_config_accel_set_speed
+ * @see libinput_device_config_accel_get_default_speed
+ */
+double
+libinput_device_config_accel_get_speed(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Return the default speed setting for this device, normalized to a range
+ * of [-1, 1].
+ * See libinput_device_config_accel_set_speed() for details.
+ *
+ * @param device The device to configure
+ * @return The default speed setting for this device.
+ *
+ * @see libinput_device_config_accel_is_available
+ * @see libinput_device_config_accel_set_speed
+ * @see libinput_device_config_accel_get_speed
+ */
+double
+libinput_device_config_accel_get_default_speed(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ */
+enum libinput_config_accel_profile {
+	/**
+	 * Placeholder for devices that don't have a configurable pointer
+	 * acceleration profile.
+	 */
+	LIBINPUT_CONFIG_ACCEL_PROFILE_NONE = 0,
+	/**
+	 * A flat acceleration profile. Pointer motion is accelerated by a
+	 * constant (device-specific) factor, depending on the current
+	 * speed.
+	 *
+	 * @see libinput_device_config_accel_set_speed
+	 */
+	LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT = (1 << 0),
+
+	/**
+	 * An adaptive acceleration profile. Pointer acceleration depends
+	 * on the input speed. This is the default profile for most devices.
+	 */
+	LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE = (1 << 1),
+};
+
+/**
+ * @ingroup config
+ *
+ * Returns a bitmask of the configurable acceleration modes available on
+ * this device.
+ *
+ * @param device The device to configure
+ *
+ * @return A bitmask of all configurable modes available on this device.
+ */
+uint32_t
+libinput_device_config_accel_get_profiles(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the pointer acceleration profile of this pointer device to the given
+ * mode.
+ *
+ * @param device The device to configure
+ * @param mode The mode to set the device to.
+ *
+ * @return A config status code
+ */
+enum libinput_config_status
+libinput_device_config_accel_set_profile(struct libinput_device *device,
+					 enum libinput_config_accel_profile mode);
+
+/**
+ * @ingroup config
+ *
+ * Get the current pointer acceleration profile for this pointer device.
+ *
+ * @param device The device to configure
+ *
+ * @return The currently configured pointer acceleration profile.
+ */
+enum libinput_config_accel_profile
+libinput_device_config_accel_get_profile(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Return the default pointer acceleration profile for this pointer device.
+ *
+ * @param device The device to configure
+ *
+ * @return The default acceleration profile for this device.
+ */
+enum libinput_config_accel_profile
+libinput_device_config_accel_get_default_profile(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Return non-zero if the device supports "natural scrolling".
+ *
+ * In traditional scroll mode, the movement of fingers on a touchpad when
+ * scrolling matches the movement of the scroll bars. When the fingers move
+ * down, the scroll bar moves down, a line of text on the screen moves
+ * towards the upper end of the screen. This also matches scroll wheels on
+ * mice (wheel down, content moves up).
+ *
+ * Natural scrolling is the term coined by Apple for inverted scrolling.
+ * In this mode, the effect of scrolling movement of fingers on a touchpad
+ * resemble physical manipulation of paper. When the fingers move down, a
+ * line of text on the screen moves down (scrollbars move up). This is the
+ * opposite of scroll wheels on mice.
+ *
+ * A device supporting natural scrolling can be switched between traditional
+ * scroll mode and natural scroll mode.
+ *
+ * @param device The device to configure
+ *
+ * @return Zero if natural scrolling is not supported, non-zero if natural
+ * scrolling is supported by this device
+ *
+ * @see libinput_device_config_scroll_set_natural_scroll_enabled
+ * @see libinput_device_config_scroll_get_natural_scroll_enabled
+ * @see libinput_device_config_scroll_get_default_natural_scroll_enabled
+ */
+int
+libinput_device_config_scroll_has_natural_scroll(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable natural scrolling on the device.
+ *
+ * @param device The device to configure
+ * @param enable non-zero to enable, zero to disable natural scrolling
+ *
+ * @return A config status code
+ *
+ * @see libinput_device_config_scroll_has_natural_scroll
+ * @see libinput_device_config_scroll_get_natural_scroll_enabled
+ * @see libinput_device_config_scroll_get_default_natural_scroll_enabled
+ */
+enum libinput_config_status
+libinput_device_config_scroll_set_natural_scroll_enabled(struct libinput_device *device,
+							 int enable);
+/**
+ * @ingroup config
+ *
+ * Get the current mode for scrolling on this device
+ *
+ * @param device The device to configure
+ *
+ * @return Zero if natural scrolling is disabled, non-zero if enabled
+ *
+ * @see libinput_device_config_scroll_has_natural_scroll
+ * @see libinput_device_config_scroll_set_natural_scroll_enabled
+ * @see libinput_device_config_scroll_get_default_natural_scroll_enabled
+ */
+int
+libinput_device_config_scroll_get_natural_scroll_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default mode for scrolling on this device
+ *
+ * @param device The device to configure
+ *
+ * @return Zero if natural scrolling is disabled by default, non-zero if enabled
+ *
+ * @see libinput_device_config_scroll_has_natural_scroll
+ * @see libinput_device_config_scroll_set_natural_scroll_enabled
+ * @see libinput_device_config_scroll_get_natural_scroll_enabled
+ */
+int
+libinput_device_config_scroll_get_default_natural_scroll_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if a device has a configuration that supports left-handed usage.
+ *
+ * @param device The device to configure
+ * @return Non-zero if the device can be set to left-handed, or zero
+ * otherwise
+ *
+ * @see libinput_device_config_left_handed_set
+ * @see libinput_device_config_left_handed_get
+ * @see libinput_device_config_left_handed_get_default
+ */
+int
+libinput_device_config_left_handed_is_available(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the left-handed configuration of the device.
+ *
+ * The exact behavior is device-dependent. On a mouse and most pointing
+ * devices, left and right buttons are swapped but the middle button is
+ * unmodified. On a touchpad, physical buttons (if present) are swapped. On a
+ * clickpad, the top and bottom software-emulated buttons are swapped where
+ * present, the main area of the touchpad remains a left button. Tapping and
+ * clickfinger behavior is not affected by this setting.
+ *
+ * Changing the left-handed configuration of a device may not take effect
+ * until all buttons have been logically released.
+ *
+ * @param device The device to configure
+ * @param left_handed Zero to disable, non-zero to enable left-handed mode
+ * @return A configuration status code
+ *
+ * @see libinput_device_config_left_handed_is_available
+ * @see libinput_device_config_left_handed_get
+ * @see libinput_device_config_left_handed_get_default
+ */
+enum libinput_config_status
+libinput_device_config_left_handed_set(struct libinput_device *device,
+				       int left_handed);
+
+/**
+ * @ingroup config
+ *
+ * Get the current left-handed configuration of the device.
+ *
+ * @param device The device to configure
+ * @return Zero if the device is in right-handed mode, non-zero if the
+ * device is in left-handed mode
+ *
+ * @see libinput_device_config_left_handed_is_available
+ * @see libinput_device_config_left_handed_set
+ * @see libinput_device_config_left_handed_get_default
+ */
+int
+libinput_device_config_left_handed_get(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default left-handed configuration of the device.
+ *
+ * @param device The device to configure
+ * @return Zero if the device is in right-handed mode by default, or non-zero
+ * if the device is in left-handed mode by default
+ *
+ * @see libinput_device_config_left_handed_is_available
+ * @see libinput_device_config_left_handed_set
+ * @see libinput_device_config_left_handed_get
+ */
+int
+libinput_device_config_left_handed_get_default(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * The click method defines when to generate software-emulated
+ * buttons, usually on a device that does not have a specific physical
+ * button available.
+ */
+enum libinput_config_click_method {
+	/**
+	 * Do not send software-emulated button events. This has no effect
+	 * on events generated by physical buttons.
+	 */
+	LIBINPUT_CONFIG_CLICK_METHOD_NONE = 0,
+	/**
+	 * Use software-button areas (see @ref clickfinger) to generate
+	 * button events.
+	 */
+	LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS = (1 << 0),
+	/**
+	 * The number of fingers decides which button press to generate.
+	 */
+	LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER = (1 << 1),
+};
+
+/**
+ * @ingroup config
+ *
+ * Check which button click methods a device supports. The button click
+ * method defines when to generate software-emulated buttons, usually on a
+ * device that does not have a specific physical button available.
+ *
+ * @param device The device to configure
+ *
+ * @return A bitmask of possible methods.
+ *
+ * @see libinput_device_config_click_get_methods
+ * @see libinput_device_config_click_set_method
+ * @see libinput_device_config_click_get_method
+ */
+uint32_t
+libinput_device_config_click_get_methods(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the button click method for this device. The button click
+ * method defines when to generate software-emulated buttons, usually on a
+ * device that does not have a specific physical button available.
+ *
+ * @note The selected click method may not take effect immediately. The
+ * device may require changing to a neutral state first before activating
+ * the new method.
+ *
+ * @param device The device to configure
+ * @param method The button click method
+ *
+ * @return A config status code
+ *
+ * @see libinput_device_config_click_get_methods
+ * @see libinput_device_config_click_get_method
+ * @see libinput_device_config_click_get_default_method
+ */
+enum libinput_config_status
+libinput_device_config_click_set_method(struct libinput_device *device,
+					enum libinput_config_click_method method);
+/**
+ * @ingroup config
+ *
+ * Get the button click method for this device. The button click
+ * method defines when to generate software-emulated buttons, usually on a
+ * device that does not have a specific physical button available.
+ *
+ * @param device The device to configure
+ *
+ * @return The current button click method for this device
+ *
+ * @see libinput_device_config_click_get_methods
+ * @see libinput_device_config_click_set_method
+ * @see libinput_device_config_click_get_default_method
+ */
+enum libinput_config_click_method
+libinput_device_config_click_get_method(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default button click method for this device. The button click
+ * method defines when to generate software-emulated buttons, usually on a
+ * device that does not have a specific physical button available.
+ *
+ * @param device The device to configure
+ *
+ * @return The default button click method for this device
+ *
+ * @see libinput_device_config_click_get_methods
+ * @see libinput_device_config_click_set_method
+ * @see libinput_device_config_click_get_method
+ */
+enum libinput_config_click_method
+libinput_device_config_click_get_default_method(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ */
+enum libinput_config_middle_emulation_state {
+	/**
+	 * Middle mouse button emulation is to be disabled, or
+	 * is currently disabled.
+	 */
+	LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED,
+	/**
+	 * Middle mouse button emulation is to be enabled, or
+	 * is currently enabled.
+	 */
+	LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED,
+};
+
+/**
+ * @ingroup config
+ *
+ * Check if middle mouse button emulation configuration is available on this
+ * device. See @ref middle_button_emulation for details.
+ *
+ * @note Some devices provide middle mouse button emulation but do not allow
+ * enabling/disabling that emulation. These devices return zero in
+ * libinput_device_config_middle_emulation_is_available().
+ *
+ * @param device The device to query
+ *
+ * @return Non-zero if middle mouse button emulation is available and can be
+ * configured, zero otherwise.
+ *
+ * @see libinput_device_config_middle_emulation_set_enabled
+ * @see libinput_device_config_middle_emulation_get_enabled
+ * @see libinput_device_config_middle_emulation_get_default_enabled
+ */
+int
+libinput_device_config_middle_emulation_is_available(
+		struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable middle button emulation on this device. When enabled, a
+ * simultaneous press of the left and right button generates a middle mouse
+ * button event. Releasing the buttons generates a middle mouse button
+ * release, the left and right button events are discarded otherwise.
+ *
+ * See @ref middle_button_emulation for details.
+ *
+ * @param device The device to configure
+ * @param enable @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED to
+ * disable, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED To enable
+ * middle button emulation.
+ *
+ * @return A config status code. Disabling middle button emulation on a
+ * device that does not support middle button emulation always succeeds.
+ *
+ * @see libinput_device_config_middle_emulation_is_available
+ * @see libinput_device_config_middle_emulation_get_enabled
+ * @see libinput_device_config_middle_emulation_get_default_enabled
+ */
+enum libinput_config_status
+libinput_device_config_middle_emulation_set_enabled(
+		struct libinput_device *device,
+		enum libinput_config_middle_emulation_state enable);
+
+/**
+ * @ingroup config
+ *
+ * Check if configurable middle button emulation is enabled on this device.
+ * See @ref middle_button_emulation for details.
+ *
+ * If the device does not have configurable middle button emulation, this
+ * function returns @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
+ *
+ * @note Some devices provide middle mouse button emulation but do not allow
+ * enabling/disabling that emulation. These devices always return @ref
+ * LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
+ *
+ * @param device The device to configure
+ * @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED if disabled
+ * or not available/configurable, @ref
+ * LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED If enabled.
+ *
+ * @see libinput_device_config_middle_emulation_is_available
+ * @see libinput_device_config_middle_emulation_set_enabled
+ * @see libinput_device_config_middle_emulation_get_default_enabled
+ */
+enum libinput_config_middle_emulation_state
+libinput_device_config_middle_emulation_get_enabled(
+		struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if configurable middle button emulation is enabled by default on
+ * this device. See @ref middle_button_emulation for details.
+ *
+ * If the device does not have configurable middle button
+ * emulation, this function returns @ref
+ * LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
+ *
+ * @note Some devices provide middle mouse button emulation but do not allow
+ * enabling/disabling that emulation. These devices always return @ref
+ * LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
+ *
+ * @param device The device to configure
+ * @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED If disabled
+ * or not available, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED if
+ * enabled.
+ *
+ * @see libinput_device_config_middle_emulation_is_available
+ * @see libinput_device_config_middle_emulation_set_enabled
+ * @see libinput_device_config_middle_emulation_get_enabled
+ */
+enum libinput_config_middle_emulation_state
+libinput_device_config_middle_emulation_get_default_enabled(
+		struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * The scroll method of a device selects when to generate scroll axis events
+ * instead of pointer motion events.
+ */
+enum libinput_config_scroll_method {
+	/**
+	 * Never send scroll events instead of pointer motion events.
+	 * This has no effect on events generated by scroll wheels.
+	 */
+	LIBINPUT_CONFIG_SCROLL_NO_SCROLL = 0,
+	/**
+	 * Send scroll events when two fingers are logically down on the
+	 * device.
+	 */
+	LIBINPUT_CONFIG_SCROLL_2FG = (1 << 0),
+	/**
+	 * Send scroll events when a finger moves along the bottom or
+	 * right edge of a device.
+	 */
+	LIBINPUT_CONFIG_SCROLL_EDGE = (1 << 1),
+	/**
+	 * Send scroll events when a button is down and the device moves
+	 * along a scroll-capable axis.
+	 */
+	LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN = (1 << 2),
+};
+
+/**
+ * @ingroup config
+ *
+ * Check which scroll methods a device supports. The method defines when to
+ * generate scroll axis events instead of pointer motion events.
+ *
+ * @param device The device to configure
+ *
+ * @return A bitmask of possible methods.
+ *
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+uint32_t
+libinput_device_config_scroll_get_methods(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the scroll method for this device. The method defines when to
+ * generate scroll axis events instead of pointer motion events.
+ *
+ * @note Setting @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN enables
+ * the scroll method, but scrolling is only activated when the configured
+ * button is held down. If no button is set, i.e.
+ * libinput_device_config_scroll_get_button() returns 0, scrolling
+ * cannot activate.
+ *
+ * @param device The device to configure
+ * @param method The scroll method for this device.
+ *
+ * @return A config status code.
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+enum libinput_config_status
+libinput_device_config_scroll_set_method(struct libinput_device *device,
+					 enum libinput_config_scroll_method method);
+
+/**
+ * @ingroup config
+ *
+ * Get the scroll method for this device. The method defines when to
+ * generate scroll axis events instead of pointer motion events.
+ *
+ * @param device The device to configure
+ * @return The current scroll method for this device.
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+enum libinput_config_scroll_method
+libinput_device_config_scroll_get_method(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default scroll method for this device. The method defines when to
+ * generate scroll axis events instead of pointer motion events.
+ *
+ * @param device The device to configure
+ * @return The default scroll method for this device.
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+enum libinput_config_scroll_method
+libinput_device_config_scroll_get_default_method(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
+ * for this device.
+ *
+ * When the current scroll method is set to @ref
+ * LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN, no button press/release events
+ * will be send for the configured button.
+ *
+ * When the configured button is pressed, any motion events along a
+ * scroll-capable axis are turned into scroll axis events.
+ *
+ * @note Setting the button does not change the scroll method. To change the
+ * scroll method call libinput_device_config_scroll_set_method().
+ *
+ * If the button is 0, button scrolling is effectively disabled.
+ *
+ * @param device The device to configure
+ * @param button The button which when pressed switches to sending scroll events
+ *
+ * @return A config status code
+ * @retval LIBINPUT_CONFIG_STATUS_SUCCESS On success
+ * @retval LIBINPUT_CONFIG_STATUS_UNSUPPORTED If @ref
+ * LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN is not supported
+ * @retval LIBINPUT_CONFIG_STATUS_INVALID The given button does not
+ * exist on this device
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_get_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+enum libinput_config_status
+libinput_device_config_scroll_set_button(struct libinput_device *device,
+					 uint32_t button);
+
+/**
+ * @ingroup config
+ *
+ * Get the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
+ * for this device.
+ *
+ * If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not
+ * supported, or no button is set, this function returns 0.
+ *
+ * @note The return value is independent of the currently selected
+ * scroll-method. For button scrolling to activate, a device must have the
+ * @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method enabled, and a non-zero
+ * button set as scroll button.
+ *
+ * @param device The device to configure
+ * @return The button which when pressed switches to sending scroll events
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_default_button
+ */
+uint32_t
+libinput_device_config_scroll_get_button(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
+ * method for this device.
+ *
+ * If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not supported,
+ * or no default button is set, this function returns 0.
+ *
+ * @param device The device to configure
+ * @return The default button for the @ref
+ * LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
+ *
+ * @see libinput_device_config_scroll_get_methods
+ * @see libinput_device_config_scroll_set_method
+ * @see libinput_device_config_scroll_get_method
+ * @see libinput_device_config_scroll_get_default_method
+ * @see libinput_device_config_scroll_set_button
+ * @see libinput_device_config_scroll_get_button
+ */
+uint32_t
+libinput_device_config_scroll_get_default_button(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Possible states for the disable-while-typing feature. See @ref
+ * disable-while-typing for details.
+ */
+enum libinput_config_dwt_state {
+	LIBINPUT_CONFIG_DWT_DISABLED,
+	LIBINPUT_CONFIG_DWT_ENABLED,
+};
+
+/**
+ * @ingroup config
+ *
+ * Check if this device supports configurable disable-while-typing feature.
+ * This feature is usually available on built-in touchpads and disables the
+ * touchpad while typing. See @ref disable-while-typing for details.
+ *
+ * @param device The device to configure
+ * @return 0 if this device does not support disable-while-typing, or 1
+ * otherwise.
+ *
+ * @see libinput_device_config_dwt_set_enabled
+ * @see libinput_device_config_dwt_get_enabled
+ * @see libinput_device_config_dwt_get_default_enabled
+ */
+int
+libinput_device_config_dwt_is_available(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Enable or disable the disable-while-typing feature. When enabled, the
+ * device will be disabled while typing and for a short period after. See
+ * @ref disable-while-typing for details.
+ *
+ * @note Enabling or disabling disable-while-typing may not take effect
+ * immediately.
+ *
+ * @param device The device to configure
+ * @param enable @ref LIBINPUT_CONFIG_DWT_DISABLED to disable
+ * disable-while-typing, @ref LIBINPUT_CONFIG_DWT_ENABLED to enable
+ *
+ * @return A config status code. Disabling disable-while-typing on a
+ * device that does not support the feature always succeeds.
+ *
+ * @see libinput_device_config_dwt_is_available
+ * @see libinput_device_config_dwt_get_enabled
+ * @see libinput_device_config_dwt_get_default_enabled
+ */
+enum libinput_config_status
+libinput_device_config_dwt_set_enabled(struct libinput_device *device,
+				       enum libinput_config_dwt_state enable);
+
+/**
+ * @ingroup config
+ *
+ * Check if the disable-while typing feature is currently enabled on this
+ * device. If the device does not support disable-while-typing, this
+ * function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
+ *
+ * @param device The device to configure
+ * @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
+ * LIBINPUT_CONFIG_DWT_ENABLED if enabled.
+ *
+ * @see libinput_device_config_dwt_is_available
+ * @see libinput_device_config_dwt_set_enabled
+ * @see libinput_device_config_dwt_get_default_enabled
+ */
+enum libinput_config_dwt_state
+libinput_device_config_dwt_get_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check if the disable-while typing feature is enabled on this device by
+ * default. If the device does not support disable-while-typing, this
+ * function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
+ *
+ * @param device The device to configure
+ * @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
+ * LIBINPUT_CONFIG_DWT_ENABLED if enabled.
+ *
+ * @see libinput_device_config_dwt_is_available
+ * @see libinput_device_config_dwt_set_enabled
+ * @see libinput_device_config_dwt_get_enabled
+ */
+enum libinput_config_dwt_state
+libinput_device_config_dwt_get_default_enabled(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Check whether a device can have a custom rotation applied.
+ *
+ * @param device The device to configure
+ * @return Non-zero if a device can be rotated, zero otherwise.
+ *
+ * @see libinput_device_config_rotation_set_angle
+ * @see libinput_device_config_rotation_get_angle
+ * @see libinput_device_config_rotation_get_default_angle
+ */
+int
+libinput_device_config_rotation_is_available(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Set the rotation of a device in degrees clockwise off the logical neutral
+ * position. Any subsequent motion events are adjusted according to the
+ * given angle.
+ *
+ * The angle has to be in the range of [0, 360[ degrees, otherwise this
+ * function returns LIBINPUT_CONFIG_STATUS_INVALID. If the angle is a
+ * multiple of 360 or negative, the caller must ensure the correct ranging
+ * before calling this function.
+ *
+ * libinput guarantees that this function accepts multiples of 90 degrees.
+ * If a value is within the [0, 360[ range but not a multiple of 90 degrees,
+ * this function may return LIBINPUT_CONFIG_STATUS_INVALID if the underlying
+ * device or implementation does not support finer-grained rotation angles.
+ *
+ * The rotation angle is applied to all motion events emitted by the device.
+ * Thus, rotating the device also changes the angle required or presented by
+ * scrolling, gestures, etc.
+ *
+ * @param device The device to configure
+ * @param degrees_cw The angle in degrees clockwise
+ * @return A config status code. Setting a rotation of 0 degrees on a
+ * device that does not support rotation always succeeds.
+ *
+ * @see libinput_device_config_rotation_is_available
+ * @see libinput_device_config_rotation_get_angle
+ * @see libinput_device_config_rotation_get_default_angle
+ */
+enum libinput_config_status
+libinput_device_config_rotation_set_angle(struct libinput_device *device,
+					  unsigned int degrees_cw);
+
+/**
+ * @ingroup config
+ *
+ * Get the current rotation of a device in degrees clockwise off the logical
+ * neutral position. If this device does not support rotation, the return
+ * value is always 0.
+ *
+ * @param device The device to configure
+ * @return The angle in degrees clockwise
+ *
+ * @see libinput_device_config_rotation_is_available
+ * @see libinput_device_config_rotation_set_angle
+ * @see libinput_device_config_rotation_get_default_angle
+ */
+unsigned int
+libinput_device_config_rotation_get_angle(struct libinput_device *device);
+
+/**
+ * @ingroup config
+ *
+ * Get the default rotation of a device in degrees clockwise off the logical
+ * neutral position. If this device does not support rotation, the return
+ * value is always 0.
+ *
+ * @param device The device to configure
+ * @return The default angle in degrees clockwise
+ *
+ * @see libinput_device_config_rotation_is_available
+ * @see libinput_device_config_rotation_set_angle
+ * @see libinput_device_config_rotation_get_angle
+ */
+unsigned int
+libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* LIBINPUT_H */
--- libinput-1.10.7.orig/test/litest.c
+++ libinput-1.10.7/test/litest.c
@@ -2481,6 +2481,15 @@ litest_event_type_str(enum libinput_even
 	case LIBINPUT_EVENT_GESTURE_PINCH_END:
 		str = "GESTURE PINCH END";
 		break;
+	case LIBINPUT_EVENT_GESTURE_TAP_BEGIN:
+      str = "GESTURE TAP START";
+      break;
+	case LIBINPUT_EVENT_GESTURE_TAP_UPDATE:
+      str = "GESTURE TAP UPDATE";
+      break;
+	case LIBINPUT_EVENT_GESTURE_TAP_END:
+      str = "GESTURE TAP END";
+      break;
 	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
 		str = "TABLET TOOL AXIS";
 		break;
--- /dev/null
+++ libinput-1.10.7/test/litest.c.orig
@@ -0,0 +1,3760 @@
+/*
+ * Copyright © 2013 Red Hat, Inc.
+ * Copyright © 2013 Marcin Slusarz <marcin.slusarz@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <check.h>
+#include <dirent.h>
+#include <errno.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <time.h>
+#include <unistd.h>
+#include "linux/input.h"
+#include <sys/ptrace.h>
+#include <sys/resource.h>
+#include <sys/sendfile.h>
+#include <sys/timerfd.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <libudev.h>
+#if HAVE_LIBSYSTEMD
+#include <systemd/sd-bus.h>
+#endif
+
+#include "litest.h"
+#include "litest-int.h"
+#include "libinput-util.h"
+
+#define UDEV_RULES_D "/run/udev/rules.d"
+#define UDEV_RULE_PREFIX "99-litest-"
+#define UDEV_HWDB_D "/etc/udev/hwdb.d"
+#define UDEV_MODEL_QUIRKS_RULE_FILE UDEV_RULES_D \
+	"/91-litest-model-quirks-REMOVEME-XXXXXX.rules"
+#define UDEV_MODEL_QUIRKS_HWDB_FILE UDEV_HWDB_D \
+	"/91-litest-model-quirks-REMOVEME-XXXXXX.hwdb"
+#define UDEV_TEST_DEVICE_RULE_FILE UDEV_RULES_D \
+	"/91-litest-test-device-REMOVEME-XXXXXXX.rules"
+#define UDEV_DEVICE_GROUPS_FILE UDEV_RULES_D \
+	"/80-libinput-device-groups-litest-XXXXXX.rules"
+
+static int jobs = 8;
+static int in_debugger = -1;
+static int verbose = 0;
+const char *filter_test = NULL;
+const char *filter_device = NULL;
+const char *filter_group = NULL;
+
+struct created_file {
+	struct list link;
+	char *path;
+};
+
+struct list created_files_list; /* list of all files to remove at the end of
+				   the test run */
+
+static void litest_init_udev_rules(struct list *created_files_list);
+static void litest_remove_udev_rules(struct list *created_files_list);
+
+/* defined for the litest selftest */
+#ifndef LITEST_DISABLE_BACKTRACE_LOGGING
+#define litest_log(...) fprintf(stderr, __VA_ARGS__)
+#define litest_vlog(format_, args_) vfprintf(stderr, format_, args_)
+#else
+#define litest_log(...) { /* __VA_ARGS__ */ }
+#define litest_vlog(...) { /* __VA_ARGS__ */ }
+#endif
+
+#if HAVE_LIBUNWIND
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#include <dlfcn.h>
+
+static char cwd[PATH_MAX];
+
+static bool
+litest_backtrace_get_lineno(const char *executable,
+			    unw_word_t addr,
+			    char *file_return,
+			    int *line_return)
+{
+#if HAVE_ADDR2LINE
+	FILE* f;
+	char buffer[PATH_MAX];
+	char *s;
+	unsigned int i;
+
+	if (!cwd[0]) {
+		if (getcwd(cwd, sizeof(cwd)) == NULL)
+			cwd[0] = 0; /* contents otherwise undefined. */
+	}
+
+	sprintf (buffer,
+		 ADDR2LINE " -C -e %s -i %lx",
+		 executable,
+		 (unsigned long) addr);
+
+	f = popen(buffer, "r");
+	if (f == NULL) {
+		litest_log("Failed to execute: %s\n", buffer);
+		return false;
+	}
+
+	buffer[0] = '?';
+	if (fgets(buffer, sizeof(buffer), f) == NULL) {
+		pclose(f);
+		return false;
+	}
+	pclose(f);
+
+	if (buffer[0] == '?')
+		return false;
+
+	s = strrchr(buffer, ':');
+	if (!s)
+		return false;
+
+	*s = '\0';
+	s++;
+	sscanf(s, "%d", line_return);
+
+	/* now strip cwd from buffer */
+	s = buffer;
+	i = 0;
+	while(i < strlen(cwd) && *s != '\0' && cwd[i] == *s) {
+		*s = '\0';
+		s++;
+		i++;
+	}
+
+	if (i > 0)
+		*(--s) = '.';
+	strcpy(file_return, s);
+
+	return true;
+#else /* HAVE_ADDR2LINE */
+	return false;
+#endif
+}
+
+static void
+litest_backtrace(void)
+{
+	unw_cursor_t cursor;
+	unw_context_t context;
+	unw_word_t off;
+	unw_proc_info_t pip;
+	int ret;
+	char procname[256];
+	Dl_info dlinfo;
+	/* filename and i are unused ifdef LITEST_SHUTUP */
+
+	pip.unwind_info = NULL;
+	ret = unw_getcontext(&context);
+	if (ret) {
+		litest_log("unw_getcontext failed: %s [%d]\n",
+			   unw_strerror(ret),
+			   ret);
+		return;
+	}
+
+	ret = unw_init_local(&cursor, &context);
+	if (ret) {
+		litest_log("unw_init_local failed: %s [%d]\n",
+			   unw_strerror(ret),
+			   ret);
+		return;
+	}
+
+	litest_log("\nBacktrace:\n");
+	ret = unw_step(&cursor);
+	while (ret > 0) {
+		char file[PATH_MAX];
+		int line;
+		bool have_lineno = false;
+		const char *filename = "?";
+		int i = 0;
+
+		ret = unw_get_proc_info(&cursor, &pip);
+		if (ret) {
+			litest_log("unw_get_proc_info failed: %s [%d]\n",
+				   unw_strerror(ret),
+				   ret);
+			break;
+		}
+
+		ret = unw_get_proc_name(&cursor, procname, 256, &off);
+		if (ret && ret != -UNW_ENOMEM) {
+			if (ret != -UNW_EUNSPEC)
+				litest_log("unw_get_proc_name failed: %s [%d]\n",
+					   unw_strerror(ret),
+					   ret);
+			procname[0] = '?';
+			procname[1] = 0;
+		}
+
+		if (dladdr((void *)(pip.start_ip + off), &dlinfo) &&
+		    dlinfo.dli_fname &&
+		    *dlinfo.dli_fname) {
+			filename = dlinfo.dli_fname;
+			have_lineno = litest_backtrace_get_lineno(filename,
+								  (pip.start_ip + off),
+								  file,
+								  &line);
+		}
+
+		if (have_lineno) {
+			litest_log("%d: %s() (%s:%d)\n",
+				   i,
+				   procname,
+				   file,
+				   line);
+		} else  {
+			litest_log("%d: %s (%s%s+%#x) [%p]\n",
+				   i,
+				   filename,
+				   procname,
+				   ret == -UNW_ENOMEM ? "..." : "",
+				   (int)off,
+				   (void *)(pip.start_ip + off));
+		}
+
+		i++;
+		ret = unw_step(&cursor);
+		if (ret < 0)
+			litest_log("unw_step failed: %s [%d]\n",
+				   unw_strerror(ret),
+				   ret);
+	}
+	litest_log("\n");
+}
+#else /* HAVE_LIBUNWIND */
+static inline void
+litest_backtrace(void)
+{
+	/* thou shall install libunwind */
+}
+#endif
+
+LIBINPUT_ATTRIBUTE_PRINTF(5, 6)
+__attribute__((noreturn))
+void
+litest_fail_condition(const char *file,
+		      int line,
+		      const char *func,
+		      const char *condition,
+		      const char *message,
+		      ...)
+{
+	litest_log("FAILED: %s\n", condition);
+
+	if (message) {
+		va_list args;
+		va_start(args, message);
+		litest_vlog(message, args);
+		va_end(args);
+	}
+
+	litest_log("in %s() (%s:%d)\n", func, file, line);
+	litest_backtrace();
+	abort();
+}
+
+__attribute__((noreturn))
+void
+litest_fail_comparison_int(const char *file,
+			   int line,
+			   const char *func,
+			   const char *operator,
+			   int a,
+			   int b,
+			   const char *astr,
+			   const char *bstr)
+{
+	litest_log("FAILED COMPARISON: %s %s %s\n", astr, operator, bstr);
+	litest_log("Resolved to: %d %s %d\n", a, operator, b);
+	litest_log("in %s() (%s:%d)\n", func, file, line);
+	litest_backtrace();
+	abort();
+}
+
+__attribute__((noreturn))
+void
+litest_fail_comparison_ptr(const char *file,
+			   int line,
+			   const char *func,
+			   const char *comparison)
+{
+	litest_log("FAILED COMPARISON: %s\n", comparison);
+	litest_log("in %s() (%s:%d)\n", func, file, line);
+	litest_backtrace();
+	abort();
+}
+
+struct test {
+	struct list node;
+	char *name;
+	char *devname;
+	void *func;
+	void *setup;
+	void *teardown;
+
+	struct range range;
+};
+
+struct suite {
+	struct list node;
+	struct list tests;
+	char *name;
+};
+
+static struct litest_device *current_device;
+
+struct litest_device *litest_current_device(void)
+{
+	return current_device;
+}
+
+void litest_set_current_device(struct litest_device *device)
+{
+	current_device = device;
+}
+
+void litest_generic_device_teardown(void)
+{
+	litest_delete_device(current_device);
+	current_device = NULL;
+}
+
+struct litest_test_device** devices;
+
+static struct list all_tests;
+
+static inline void
+litest_system(const char *command)
+{
+	int ret;
+
+	ret = system(command);
+
+	if (ret == -1) {
+		litest_abort_msg("Failed to execute: %s", command);
+	} else if (WIFEXITED(ret)) {
+		if (WEXITSTATUS(ret))
+			litest_abort_msg("'%s' failed with %d",
+					 command,
+					 WEXITSTATUS(ret));
+	} else if (WIFSIGNALED(ret)) {
+		litest_abort_msg("'%s' terminated with signal %d",
+				 command,
+				 WTERMSIG(ret));
+	}
+}
+
+static void
+litest_reload_udev_rules(void)
+{
+	litest_system("udevadm control --reload-rules");
+	litest_system("udevadm hwdb --update");
+}
+
+static void
+litest_add_tcase_for_device(struct suite *suite,
+			    const char *funcname,
+			    void *func,
+			    const struct litest_test_device *dev,
+			    const struct range *range)
+{
+	struct test *t;
+
+	t = zalloc(sizeof(*t));
+	t->name = safe_strdup(funcname);
+	t->devname = safe_strdup(dev->shortname);
+	t->func = func;
+	t->setup = dev->setup;
+	t->teardown = dev->teardown ?
+			dev->teardown : litest_generic_device_teardown;
+	if (range)
+		t->range = *range;
+
+	list_insert(&suite->tests, &t->node);
+}
+
+static void
+litest_add_tcase_no_device(struct suite *suite,
+			   void *func,
+			   const char *funcname,
+			   const struct range *range)
+{
+	struct test *t;
+	const char *test_name = funcname;
+
+	if (filter_device &&
+	    fnmatch(filter_device, test_name, 0) != 0)
+		return;
+
+	t = zalloc(sizeof(*t));
+	t->name = safe_strdup(test_name);
+	t->devname = safe_strdup("no device");
+	t->func = func;
+	if (range)
+		t->range = *range;
+	t->setup = NULL;
+	t->teardown = NULL;
+
+	list_insert(&suite->tests, &t->node);
+}
+
+static struct suite *
+get_suite(const char *name)
+{
+	struct suite *s;
+
+	list_for_each(s, &all_tests, node) {
+		if (streq(s->name, name))
+			return s;
+	}
+
+	s = zalloc(sizeof(*s));
+	s->name = safe_strdup(name);
+
+	list_init(&s->tests);
+	list_insert(&all_tests, &s->node);
+
+	return s;
+}
+
+static void
+litest_add_tcase(const char *suite_name,
+		 const char *funcname,
+		 void *func,
+		 enum litest_device_feature required,
+		 enum litest_device_feature excluded,
+		 const struct range *range)
+{
+	struct litest_test_device **dev = devices;
+	struct suite *suite;
+	bool added = false;
+
+	litest_assert(required >= LITEST_DISABLE_DEVICE);
+	litest_assert(excluded >= LITEST_DISABLE_DEVICE);
+
+	if (filter_test &&
+	    fnmatch(filter_test, funcname, 0) != 0)
+		return;
+
+	if (filter_group &&
+	    fnmatch(filter_group, suite_name, 0) != 0)
+		return;
+
+	suite = get_suite(suite_name);
+
+	if (required == LITEST_DISABLE_DEVICE &&
+	    excluded == LITEST_DISABLE_DEVICE) {
+		litest_add_tcase_no_device(suite, func, funcname, range);
+		added = true;
+	} else if (required != LITEST_ANY || excluded != LITEST_ANY) {
+		for (; *dev; dev++) {
+			if ((*dev)->features & LITEST_IGNORED)
+				continue;
+
+			if (filter_device &&
+			    fnmatch(filter_device, (*dev)->shortname, 0) != 0)
+				continue;
+			if (((*dev)->features & required) != required ||
+			    ((*dev)->features & excluded) != 0)
+				continue;
+
+			litest_add_tcase_for_device(suite,
+						    funcname,
+						    func,
+						    *dev,
+						    range);
+			added = true;
+		}
+	} else {
+		for (; *dev; dev++) {
+			if ((*dev)->features & LITEST_IGNORED)
+				continue;
+
+			if (filter_device &&
+			    fnmatch(filter_device, (*dev)->shortname, 0) != 0)
+				continue;
+
+			litest_add_tcase_for_device(suite,
+						    funcname,
+						    func,
+						    *dev,
+						    range);
+			added = true;
+		}
+	}
+
+	if (!added &&
+	    filter_test == NULL &&
+	    filter_device == NULL &&
+	    filter_group == NULL) {
+		fprintf(stderr, "Test '%s' does not match any devices. Aborting.\n", funcname);
+		abort();
+	}
+}
+
+void
+_litest_add_no_device(const char *name, const char *funcname, void *func)
+{
+	_litest_add(name, funcname, func, LITEST_DISABLE_DEVICE, LITEST_DISABLE_DEVICE);
+}
+
+void
+_litest_add_ranged_no_device(const char *name,
+			     const char *funcname,
+			     void *func,
+			     const struct range *range)
+{
+	_litest_add_ranged(name,
+			   funcname,
+			   func,
+			   LITEST_DISABLE_DEVICE,
+			   LITEST_DISABLE_DEVICE,
+			   range);
+}
+
+void
+_litest_add(const char *name,
+	    const char *funcname,
+	    void *func,
+	    enum litest_device_feature required,
+	    enum litest_device_feature excluded)
+{
+	_litest_add_ranged(name,
+			   funcname,
+			   func,
+			   required,
+			   excluded,
+			   NULL);
+}
+
+void
+_litest_add_ranged(const char *name,
+		   const char *funcname,
+		   void *func,
+		   enum litest_device_feature required,
+		   enum litest_device_feature excluded,
+		   const struct range *range)
+{
+	litest_add_tcase(name, funcname, func, required, excluded, range);
+}
+
+void
+_litest_add_for_device(const char *name,
+		       const char *funcname,
+		       void *func,
+		       enum litest_device_type type)
+{
+	_litest_add_ranged_for_device(name, funcname, func, type, NULL);
+}
+
+void
+_litest_add_ranged_for_device(const char *name,
+			      const char *funcname,
+			      void *func,
+			      enum litest_device_type type,
+			      const struct range *range)
+{
+	struct suite *s;
+	struct litest_test_device **dev = devices;
+	bool device_filtered = false;
+
+	litest_assert(type < LITEST_NO_DEVICE);
+
+	if (filter_test &&
+	    fnmatch(filter_test, funcname, 0) != 0)
+		return;
+
+	if (filter_group &&
+	    fnmatch(filter_group, name, 0) != 0)
+		return;
+
+	s = get_suite(name);
+	for (; *dev; dev++) {
+		if (filter_device &&
+		    fnmatch(filter_device, (*dev)->shortname, 0) != 0) {
+			device_filtered = true;
+			continue;
+		}
+
+		if ((*dev)->type == type) {
+			litest_add_tcase_for_device(s,
+						    funcname,
+						    func,
+						    *dev,
+						    range);
+			return;
+		}
+	}
+
+	/* only abort if no filter was set, that's a bug */
+	if (!device_filtered)
+		litest_abort_msg("Invalid test device type\n");
+}
+
+LIBINPUT_ATTRIBUTE_PRINTF(3, 0)
+static void
+litest_log_handler(struct libinput *libinput,
+		   enum libinput_log_priority pri,
+		   const char *format,
+		   va_list args)
+{
+	static int is_tty = -1;
+	const char *priority = NULL;
+	const char *color;
+
+	if (is_tty == -1)
+		is_tty = isatty(STDERR_FILENO);
+
+	switch(pri) {
+	case LIBINPUT_LOG_PRIORITY_INFO:
+		priority =  "info ";
+		color = ANSI_HIGHLIGHT;
+		break;
+	case LIBINPUT_LOG_PRIORITY_ERROR:
+		priority = "error";
+		color = ANSI_BRIGHT_RED;
+		break;
+	case LIBINPUT_LOG_PRIORITY_DEBUG:
+		priority = "debug";
+		color = ANSI_NORMAL;
+		break;
+	default:
+		  abort();
+	}
+
+	if (!is_tty)
+		color = "";
+	else if (strstr(format, "tap state:"))
+		color = ANSI_BLUE;
+	else if (strstr(format, "thumb state:"))
+		color = ANSI_YELLOW;
+	else if (strstr(format, "button state:"))
+		color = ANSI_MAGENTA;
+	else if (strstr(format, "touch-size:") ||
+		 strstr(format, "pressure:"))
+		color = ANSI_GREEN;
+	else if (strstr(format, "palm:") ||
+		 strstr(format, "thumb:"))
+		color = ANSI_CYAN;
+	else if (strstr(format, "edge state:"))
+		color = ANSI_BRIGHT_GREEN;
+
+	fprintf(stderr, "%slitest %s ", color, priority);
+	vfprintf(stderr, format, args);
+	if (is_tty)
+		fprintf(stderr, ANSI_NORMAL);
+
+	if (strstr(format, "client bug: ") ||
+	    strstr(format, "libinput bug: ")) {
+		/* valgrind is too slow and some of our offsets are too
+		 * short, don't abort if during a valgrind run we get a
+		 * negative offset */
+		if (!getenv("USING_VALGRIND") ||
+		    !strstr(format, "offset negative"))
+		litest_abort_msg("libinput bug triggered, aborting.\n");
+	}
+}
+
+static char *
+litest_init_device_udev_rules(struct litest_test_device *dev);
+
+static void
+litest_init_all_device_udev_rules(struct list *created_files)
+{
+	struct litest_test_device **dev = devices;
+
+	while (*dev) {
+		char *udev_file;
+
+		udev_file = litest_init_device_udev_rules(*dev);
+		if (udev_file) {
+			struct created_file *file = zalloc(sizeof(*file));
+			file->path = udev_file;
+			list_insert(created_files, &file->link);
+		}
+		dev++;
+	}
+}
+
+static int
+open_restricted(const char *path, int flags, void *userdata)
+{
+	int fd = open(path, flags);
+	return fd < 0 ? -errno : fd;
+}
+
+static void
+close_restricted(int fd, void *userdata)
+{
+	close(fd);
+}
+
+struct libinput_interface interface = {
+	.open_restricted = open_restricted,
+	.close_restricted = close_restricted,
+};
+
+static void
+litest_signal(int sig)
+{
+	struct created_file *f, *tmp;
+
+	list_for_each_safe(f, tmp, &created_files_list, link) {
+		list_remove(&f->link);
+		unlink(f->path);
+		/* in the sighandler, we can't free */
+	}
+
+	if (fork() == 0) {
+		/* child, we can run system() */
+		litest_reload_udev_rules();
+		exit(0);
+	}
+
+	exit(1);
+}
+
+static inline void
+litest_setup_sighandler(int sig)
+{
+	struct sigaction act, oact;
+	int rc;
+
+	sigemptyset(&act.sa_mask);
+	sigaddset(&act.sa_mask, sig);
+	act.sa_flags = 0;
+	act.sa_handler = litest_signal;
+	rc = sigaction(sig, &act, &oact);
+	litest_assert_int_ne(rc, -1);
+}
+
+static void
+litest_free_test_list(struct list *tests)
+{
+	struct suite *s, *snext;
+
+	list_for_each_safe(s, snext, tests, node) {
+		struct test *t, *tnext;
+
+		list_for_each_safe(t, tnext, &s->tests, node) {
+			free(t->name);
+			free(t->devname);
+			list_remove(&t->node);
+			free(t);
+		}
+
+		list_remove(&s->node);
+		free(s->name);
+		free(s);
+	}
+}
+
+static int
+litest_run_suite(struct list *tests, int which, int max, int error_fd)
+{
+	int failed = 0;
+	SRunner *sr = NULL;
+	struct suite *s;
+	struct test *t;
+	int count = -1;
+	struct name {
+		struct list node;
+		char *name;
+	};
+	struct name *n, *tmp;
+	struct list testnames;
+
+	/* Check just takes the suite/test name pointers but doesn't strdup
+	 * them - we have to keep them around */
+	list_init(&testnames);
+
+	/* For each test, create one test suite with one test case, then
+	   add it to the test runner. The only benefit suites give us in
+	   check is that we can filter them, but our test runner has a
+	   --filter-group anyway. */
+	list_for_each(s, tests, node) {
+		list_for_each(t, &s->tests, node) {
+			Suite *suite;
+			TCase *tc;
+			char *sname, *tname;
+
+			count = (count + 1) % max;
+			if (max != 1 && (count % max) != which)
+				continue;
+
+			xasprintf(&sname,
+				  "%s:%s:%s",
+				  s->name,
+				  t->name,
+				  t->devname);
+			litest_assert(sname != NULL);
+			n = zalloc(sizeof(*n));
+			n->name = sname;
+			list_insert(&testnames, &n->node);
+
+			xasprintf(&tname,
+				  "%s:%s",
+				  t->name,
+				  t->devname);
+			litest_assert(tname != NULL);
+			n = zalloc(sizeof(*n));
+			n->name = tname;
+			list_insert(&testnames, &n->node);
+
+			tc = tcase_create(tname);
+			tcase_add_checked_fixture(tc,
+						  t->setup,
+						  t->teardown);
+			if (t->range.upper != t->range.lower)
+				tcase_add_loop_test(tc,
+						    t->func,
+						    t->range.lower,
+						    t->range.upper);
+			else
+				tcase_add_test(tc, t->func);
+
+			suite = suite_create(sname);
+			suite_add_tcase(suite, tc);
+
+			if (!sr)
+				sr = srunner_create(suite);
+			else
+				srunner_add_suite(sr, suite);
+		}
+	}
+
+	if (!sr)
+		goto out;
+
+	srunner_run_all(sr, CK_ENV);
+	failed = srunner_ntests_failed(sr);
+	if (failed) {
+		TestResult **trs;
+
+		trs = srunner_failures(sr);
+		for (int i = 0; i < failed; i++) {
+			dprintf(error_fd,
+				":: Failure: %s:%d:%s\n",
+				tr_lfile(trs[i]),
+				tr_lno(trs[i]),
+				tr_tcname(trs[i]));
+		}
+		free(trs);
+	}
+	srunner_free(sr);
+out:
+	list_for_each_safe(n, tmp, &testnames, node) {
+		free(n->name);
+		free(n);
+	}
+
+	return failed;
+}
+
+static int
+litest_fork_subtests(struct list *tests, int max_forks)
+{
+	int failed = 0;
+	int status;
+	pid_t pid;
+	int f;
+	int pipes[max_forks];
+
+	for (f = 0; f < max_forks; f++) {
+		int rc;
+		int pipefd[2];
+
+		rc = pipe2(pipefd, O_NONBLOCK|O_NONBLOCK);
+		assert(rc != -1);
+
+		pid = fork();
+		if (pid == 0) {
+			close(pipefd[0]);
+			failed = litest_run_suite(tests,
+						  f,
+						  max_forks,
+						  pipefd[1]);
+
+			litest_free_test_list(&all_tests);
+			exit(failed);
+			/* child always exits here */
+		} else {
+			pipes[f] = pipefd[0];
+			close(pipefd[1]);
+		}
+	}
+
+	/* parent process only */
+	while (wait(&status) != -1 && errno != ECHILD) {
+		if (WEXITSTATUS(status) != 0)
+			failed = 1;
+	}
+
+	for (f = 0; f < max_forks; f++) {
+		char buf[1024] = {0};
+		int rc;
+
+		while ((rc = read(pipes[f], buf, sizeof(buf) - 1)) > 0) {
+			buf[rc] = '\0';
+			fprintf(stderr, "%s", buf);
+		}
+
+		close(pipes[f]);
+	}
+
+	return failed;
+}
+
+static inline int
+inhibit(void)
+{
+	int lock_fd = -1;
+#if HAVE_LIBSYSTEMD
+	sd_bus_error error = SD_BUS_ERROR_NULL;
+	sd_bus_message *m = NULL;
+	sd_bus *bus = NULL;
+	int rc;
+
+	rc = sd_bus_open_system(&bus);
+	if (rc != 0) {
+		fprintf(stderr, "Warning: inhibit failed: %s\n", strerror(-rc));
+		goto out;
+	}
+
+	rc = sd_bus_call_method(bus,
+				"org.freedesktop.login1",
+				"/org/freedesktop/login1",
+				"org.freedesktop.login1.Manager",
+				"Inhibit",
+				&error,
+				&m,
+				"ssss",
+				"handle-lid-switch:handle-power-key:handle-suspend-key:handle-hibernate-key",
+				"libinput test-suite runner",
+				"testing in progress",
+				"block");
+	if (rc < 0) {
+		fprintf(stderr, "Warning: inhibit failed: %s\n", error.message);
+		goto out;
+	}
+
+	rc = sd_bus_message_read(m, "h", &lock_fd);
+	if (rc < 0) {
+		fprintf(stderr, "Warning: inhibit failed: %s\n", strerror(-rc));
+		goto out;
+	}
+
+	lock_fd = dup(lock_fd);
+out:
+	sd_bus_error_free(&error);
+	sd_bus_message_unref(m);
+	sd_bus_close(bus);
+	sd_bus_unref(bus);
+#endif
+	return lock_fd;
+}
+
+static inline int
+litest_run(int argc, char **argv)
+{
+	int failed = 0;
+	int inhibit_lock_fd;
+
+	list_init(&created_files_list);
+
+	if (list_empty(&all_tests)) {
+		fprintf(stderr,
+			"Error: filters are too strict, no tests to run.\n");
+		return 1;
+	}
+
+	if (getenv("LITEST_VERBOSE"))
+		verbose = 1;
+
+	litest_init_udev_rules(&created_files_list);
+
+	litest_setup_sighandler(SIGINT);
+
+	inhibit_lock_fd = inhibit();
+
+	if (jobs == 1)
+		failed = litest_run_suite(&all_tests, 1, 1, STDERR_FILENO);
+	else
+		failed = litest_fork_subtests(&all_tests, jobs);
+
+	close(inhibit_lock_fd);
+
+	litest_free_test_list(&all_tests);
+
+	litest_remove_udev_rules(&created_files_list);
+
+	return failed;
+}
+
+static struct input_absinfo *
+merge_absinfo(const struct input_absinfo *orig,
+	      const struct input_absinfo *override)
+{
+	struct input_absinfo *abs;
+	unsigned int nelem, i;
+	size_t sz = ABS_MAX + 1;
+
+	if (!orig)
+		return NULL;
+
+	abs = zalloc(sz * sizeof(*abs));
+	litest_assert(abs != NULL);
+
+	nelem = 0;
+	while (orig[nelem].value != -1) {
+		abs[nelem] = orig[nelem];
+		nelem++;
+		litest_assert_int_lt(nelem, sz);
+	}
+
+	/* just append, if the same axis is present twice, libevdev will
+	   only use the last value anyway */
+	i = 0;
+	while (override && override[i].value != -1) {
+		abs[nelem++] = override[i++];
+		litest_assert_int_lt(nelem, sz);
+	}
+
+	litest_assert_int_lt(nelem, sz);
+	abs[nelem].value = -1;
+
+	return abs;
+}
+
+static int*
+merge_events(const int *orig, const int *override)
+{
+	int *events;
+	unsigned int nelem, i;
+	size_t sz = KEY_MAX * 3;
+
+	if (!orig)
+		return NULL;
+
+	events = zalloc(sz * sizeof(int));
+	litest_assert(events != NULL);
+
+	nelem = 0;
+	while (orig[nelem] != -1) {
+		events[nelem] = orig[nelem];
+		nelem++;
+		litest_assert_int_lt(nelem, sz);
+	}
+
+	/* just append, if the same axis is present twice, libevdev will
+	 * ignore the double definition anyway */
+	i = 0;
+	while (override && override[i] != -1) {
+		events[nelem++] = override[i++];
+		litest_assert_int_le(nelem, sz);
+	}
+
+	litest_assert_int_lt(nelem, sz);
+	events[nelem] = -1;
+
+	return events;
+}
+
+static inline struct created_file *
+litest_copy_file(const char *dest, const char *src, const char *header)
+{
+	int in, out, length;
+	struct created_file *file;
+	int suffixlen;
+
+	file = zalloc(sizeof(*file));
+	file->path = safe_strdup(dest);
+
+	suffixlen = file->path + strlen(file->path)  - rindex(file->path, '.');
+	out = mkstemps(file->path, suffixlen);
+	if (out == -1)
+		litest_abort_msg("Failed to write to file %s (%s)\n",
+				 file->path,
+				 strerror(errno));
+	litest_assert_int_ne(chmod(file->path, 0644), -1);
+
+	if (header) {
+		length = strlen(header);
+		litest_assert_int_eq(write(out, header, length), length);
+	}
+
+	in = open(src, O_RDONLY);
+	if (in == -1)
+		litest_abort_msg("Failed to open file %s (%s)\n",
+				 src,
+				 strerror(errno));
+	/* lazy, just check for error and empty file copy */
+	litest_assert_int_gt(sendfile(out, in, NULL, 40960), 0);
+	close(out);
+	close(in);
+
+	return file;
+}
+
+static inline void
+litest_install_model_quirks(struct list *created_files_list)
+{
+	const char *warning =
+			 "#################################################################\n"
+			 "# WARNING: REMOVE THIS FILE\n"
+			 "# This is a run-time file for the libinput test suite and\n"
+			 "# should be removed on exit. If the test-suite is not currently \n"
+			 "# running, remove this file and update your hwdb: \n"
+			 "#       sudo udevadm hwdb --update\n"
+			 "#################################################################\n\n";
+	struct created_file *file;
+
+	file = litest_copy_file(UDEV_MODEL_QUIRKS_RULE_FILE,
+				LIBINPUT_MODEL_QUIRKS_UDEV_RULES_FILE,
+				warning);
+	list_insert(created_files_list, &file->link);
+
+	file = litest_copy_file(UDEV_MODEL_QUIRKS_HWDB_FILE,
+				LIBINPUT_MODEL_QUIRKS_UDEV_HWDB_FILE,
+				warning);
+	list_insert(created_files_list, &file->link);
+
+	file = litest_copy_file(UDEV_TEST_DEVICE_RULE_FILE,
+				LIBINPUT_TEST_DEVICE_RULES_FILE,
+				warning);
+	list_insert(created_files_list, &file->link);
+
+	file = litest_copy_file(UDEV_DEVICE_GROUPS_FILE,
+				LIBINPUT_DEVICE_GROUPS_RULES_FILE,
+				warning);
+	list_insert(created_files_list, &file->link);
+}
+
+static inline void
+mkdir_p(const char *dir)
+{
+	char *path, *parent;
+	int rc;
+
+	if (streq(dir, "/"))
+		return;
+
+	path = strdup(dir);
+	parent = dirname(path);
+
+	mkdir_p(parent);
+	rc = mkdir(dir, 0755);
+
+	if (rc == -1 && errno != EEXIST) {
+		litest_abort_msg("Failed to create directory %s (%s)\n",
+				 dir,
+				 strerror(errno));
+	}
+
+	free(path);
+}
+
+static void
+litest_init_udev_rules(struct list *created_files)
+{
+	mkdir_p(UDEV_RULES_D);
+	mkdir_p(UDEV_HWDB_D);
+
+	litest_install_model_quirks(created_files);
+	litest_init_all_device_udev_rules(created_files);
+	litest_reload_udev_rules();
+}
+
+static void
+litest_remove_udev_rules(struct list *created_files_list)
+{
+	struct created_file *f, *tmp;
+
+	list_for_each_safe(f, tmp, created_files_list, link) {
+		list_remove(&f->link);
+		unlink(f->path);
+		free(f->path);
+		free(f);
+	}
+
+	litest_reload_udev_rules();
+}
+
+static char *
+litest_init_device_udev_rules(struct litest_test_device *dev)
+{
+	int rc;
+	int fd;
+	FILE *f;
+	char *path = NULL;
+
+	if (!dev->udev_rule)
+		return NULL;
+
+	rc = xasprintf(&path,
+		      "%s/%s%s-XXXXXX.rules",
+		      UDEV_RULES_D,
+		      UDEV_RULE_PREFIX,
+		      dev->shortname);
+	litest_assert_int_eq(rc,
+			     (int)(
+				   strlen(UDEV_RULES_D) +
+				   strlen(UDEV_RULE_PREFIX) +
+				   strlen(dev->shortname) + 14));
+
+	fd = mkstemps(path, 6);
+	litest_assert_int_ne(fd, -1);
+	f = fdopen(fd, "w");
+	litest_assert_notnull(f);
+	litest_assert_int_ge(fputs(dev->udev_rule, f), 0);
+	fclose(f);
+
+	return path;
+}
+
+/**
+ * Creates a uinput device but does not add it to a libinput context
+ */
+struct litest_device *
+litest_create(enum litest_device_type which,
+	      const char *name_override,
+	      struct input_id *id_override,
+	      const struct input_absinfo *abs_override,
+	      const int *events_override)
+{
+	struct litest_device *d = NULL;
+	struct litest_test_device **dev;
+	const char *name;
+	const struct input_id *id;
+	struct input_absinfo *abs;
+	int *events, *e;
+	const char *path;
+	int fd, rc;
+
+	dev = devices;
+	while (*dev) {
+		if ((*dev)->type == which)
+			break;
+		dev++;
+	}
+
+	if (!*dev)
+		ck_abort_msg("Invalid device type %d\n", which);
+
+	d = zalloc(sizeof(*d));
+
+	/* device has custom create method */
+	if ((*dev)->create) {
+		(*dev)->create(d);
+		if (abs_override || events_override) {
+			litest_abort_msg("Custom create cannot be overridden");
+		}
+	} else {
+		abs = merge_absinfo((*dev)->absinfo, abs_override);
+		events = merge_events((*dev)->events, events_override);
+		name = name_override ? name_override : (*dev)->name;
+		id = id_override ? id_override : (*dev)->id;
+
+		d->uinput = litest_create_uinput_device_from_description(name,
+									 id,
+									 abs,
+									 events);
+		d->interface = (*dev)->interface;
+
+		for (e = events; *e != -1; e += 2) {
+			unsigned int type = *e,
+				     code = *(e + 1);
+
+			if (type == INPUT_PROP_MAX &&
+			    code == INPUT_PROP_SEMI_MT) {
+				d->semi_mt.is_semi_mt = true;
+				break;
+			}
+		}
+
+		free(abs);
+		free(events);
+	}
+
+	path = libevdev_uinput_get_devnode(d->uinput);
+	litest_assert(path != NULL);
+	fd = open(path, O_RDWR|O_NONBLOCK);
+	litest_assert_int_ne(fd, -1);
+
+	rc = libevdev_new_from_fd(fd, &d->evdev);
+	litest_assert_int_eq(rc, 0);
+
+	return d;
+
+}
+
+struct libinput *
+litest_create_context(void)
+{
+	struct libinput *libinput =
+		libinput_path_create_context(&interface, NULL);
+	litest_assert_notnull(libinput);
+
+	libinput_log_set_handler(libinput, litest_log_handler);
+	if (verbose)
+		libinput_log_set_priority(libinput, LIBINPUT_LOG_PRIORITY_DEBUG);
+
+	return libinput;
+}
+
+void
+litest_disable_log_handler(struct libinput *libinput)
+{
+	libinput_log_set_handler(libinput, NULL);
+}
+
+void
+litest_restore_log_handler(struct libinput *libinput)
+{
+	libinput_log_set_handler(libinput, litest_log_handler);
+	if (verbose)
+		libinput_log_set_priority(libinput, LIBINPUT_LOG_PRIORITY_DEBUG);
+}
+
+LIBINPUT_ATTRIBUTE_PRINTF(3, 0)
+static void
+litest_bug_log_handler(struct libinput *libinput,
+		       enum libinput_log_priority pri,
+		       const char *format,
+		       va_list args)
+{
+	if (strstr(format, "client bug: ") ||
+	    strstr(format, "libinput bug: "))
+		return;
+
+	litest_abort_msg("Expected bug statement in log msg, aborting.\n");
+}
+
+void
+litest_set_log_handler_bug(struct libinput *libinput)
+{
+	libinput_log_set_handler(libinput, litest_bug_log_handler);
+}
+
+struct litest_device *
+litest_add_device_with_overrides(struct libinput *libinput,
+				 enum litest_device_type which,
+				 const char *name_override,
+				 struct input_id *id_override,
+				 const struct input_absinfo *abs_override,
+				 const int *events_override)
+{
+	struct litest_device *d;
+	const char *path;
+
+	d = litest_create(which,
+			  name_override,
+			  id_override,
+			  abs_override,
+			  events_override);
+
+	path = libevdev_uinput_get_devnode(d->uinput);
+	litest_assert(path != NULL);
+
+	d->libinput = libinput;
+	d->libinput_device = libinput_path_add_device(d->libinput, path);
+	litest_assert(d->libinput_device != NULL);
+	libinput_device_ref(d->libinput_device);
+
+	if (d->interface) {
+		d->interface->min[ABS_X] = libevdev_get_abs_minimum(d->evdev, ABS_X);
+		d->interface->max[ABS_X] = libevdev_get_abs_maximum(d->evdev, ABS_X);
+		d->interface->min[ABS_Y] = libevdev_get_abs_minimum(d->evdev, ABS_Y);
+		d->interface->max[ABS_Y] = libevdev_get_abs_maximum(d->evdev, ABS_Y);
+	}
+	return d;
+}
+
+struct litest_device *
+litest_add_device(struct libinput *libinput,
+		  enum litest_device_type which)
+{
+	return litest_add_device_with_overrides(libinput,
+						which,
+						NULL,
+						NULL,
+						NULL,
+						NULL);
+}
+
+struct litest_device *
+litest_create_device_with_overrides(enum litest_device_type which,
+				    const char *name_override,
+				    struct input_id *id_override,
+				    const struct input_absinfo *abs_override,
+				    const int *events_override)
+{
+	struct litest_device *dev =
+		litest_add_device_with_overrides(litest_create_context(),
+						 which,
+						 name_override,
+						 id_override,
+						 abs_override,
+						 events_override);
+	dev->owns_context = true;
+	return dev;
+}
+
+struct litest_device *
+litest_create_device(enum litest_device_type which)
+{
+	return litest_create_device_with_overrides(which, NULL, NULL, NULL, NULL);
+}
+
+void
+litest_delete_device(struct litest_device *d)
+{
+	if (!d)
+		return;
+
+	litest_assert_int_eq(d->skip_ev_syn, 0);
+
+	if (d->libinput_device) {
+		libinput_path_remove_device(d->libinput_device);
+		libinput_device_unref(d->libinput_device);
+	}
+	if (d->owns_context)
+		libinput_unref(d->libinput);
+	close(libevdev_get_fd(d->evdev));
+	libevdev_free(d->evdev);
+	libevdev_uinput_destroy(d->uinput);
+	free(d->private);
+	memset(d,0, sizeof(*d));
+	free(d);
+}
+
+void
+litest_event(struct litest_device *d, unsigned int type,
+	     unsigned int code, int value)
+{
+	int ret;
+
+	if (d->skip_ev_syn && type == EV_SYN && code == SYN_REPORT)
+		return;
+
+	ret = libevdev_uinput_write_event(d->uinput, type, code, value);
+	litest_assert_int_eq(ret, 0);
+}
+
+static bool
+axis_replacement_value(struct litest_device *d,
+		       struct axis_replacement *axes,
+		       int32_t evcode,
+		       int32_t *value)
+{
+	struct axis_replacement *axis = axes;
+
+	if (!axes)
+		return false;
+
+	while (axis->evcode != -1) {
+		if (axis->evcode == evcode) {
+			*value = litest_scale(d, evcode, axis->value);
+			return true;
+		}
+		axis++;
+	}
+
+	return false;
+}
+
+int
+litest_auto_assign_value(struct litest_device *d,
+			 const struct input_event *ev,
+			 int slot, double x, double y,
+			 struct axis_replacement *axes,
+			 bool touching)
+{
+	static int tracking_id;
+	int value = ev->value;
+
+	if (value != LITEST_AUTO_ASSIGN || ev->type != EV_ABS)
+		return value;
+
+	switch (ev->code) {
+	case ABS_X:
+	case ABS_MT_POSITION_X:
+		value = litest_scale(d, ABS_X, x);
+		break;
+	case ABS_Y:
+	case ABS_MT_POSITION_Y:
+		value = litest_scale(d, ABS_Y, y);
+		break;
+	case ABS_MT_TRACKING_ID:
+		value = ++tracking_id;
+		break;
+	case ABS_MT_SLOT:
+		value = slot;
+		break;
+	case ABS_MT_DISTANCE:
+		value = touching ? 0 : 1;
+		break;
+	default:
+		if (!axis_replacement_value(d, axes, ev->code, &value) &&
+		    d->interface->get_axis_default)
+			d->interface->get_axis_default(d, ev->code, &value);
+		break;
+	}
+
+	return value;
+}
+
+static void
+send_btntool(struct litest_device *d, bool hover)
+{
+	litest_event(d, EV_KEY, BTN_TOUCH, d->ntouches_down != 0 && !hover);
+	litest_event(d, EV_KEY, BTN_TOOL_FINGER, d->ntouches_down == 1);
+	litest_event(d, EV_KEY, BTN_TOOL_DOUBLETAP, d->ntouches_down == 2);
+	litest_event(d, EV_KEY, BTN_TOOL_TRIPLETAP, d->ntouches_down == 3);
+	litest_event(d, EV_KEY, BTN_TOOL_QUADTAP, d->ntouches_down == 4);
+	litest_event(d, EV_KEY, BTN_TOOL_QUINTTAP, d->ntouches_down == 5);
+}
+
+static void
+slot_start(struct litest_device *d,
+	   unsigned int slot,
+	   double x,
+	   double y,
+	   struct axis_replacement *axes,
+	   bool touching,
+	   bool filter_abs_xy)
+{
+	struct input_event *ev;
+
+	litest_assert(d->ntouches_down >= 0);
+	d->ntouches_down++;
+
+	send_btntool(d, !touching);
+
+	if (d->interface->touch_down) {
+		d->interface->touch_down(d, slot, x, y);
+		return;
+	}
+
+	for (ev = d->interface->touch_down_events;
+	     ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1;
+	     ev++) {
+		int value = litest_auto_assign_value(d,
+						     ev,
+						     slot,
+						     x,
+						     y,
+						     axes,
+						     touching);
+		if (value == LITEST_AUTO_ASSIGN)
+			continue;
+
+		if (filter_abs_xy && ev->type == EV_ABS &&
+		    (ev->code == ABS_X || ev->code == ABS_Y))
+			continue;
+
+		litest_event(d, ev->type, ev->code, value);
+	}
+}
+
+static void
+slot_move(struct litest_device *d,
+	  unsigned int slot,
+	  double x,
+	  double y,
+	  struct axis_replacement *axes,
+	  bool touching,
+	  bool filter_abs_xy)
+{
+	struct input_event *ev;
+
+	if (d->interface->touch_move) {
+		d->interface->touch_move(d, slot, x, y);
+		return;
+	}
+
+	for (ev = d->interface->touch_move_events;
+	     ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1;
+	     ev++) {
+		int value = litest_auto_assign_value(d,
+						     ev,
+						     slot,
+						     x,
+						     y,
+						     axes,
+						     touching);
+		if (value == LITEST_AUTO_ASSIGN)
+			continue;
+
+		if (filter_abs_xy && ev->type == EV_ABS &&
+		    (ev->code == ABS_X || ev->code == ABS_Y))
+			continue;
+
+		litest_event(d, ev->type, ev->code, value);
+	}
+}
+
+static void
+touch_up(struct litest_device *d, unsigned int slot)
+{
+	struct input_event *ev;
+	struct input_event up[] = {
+		{ .type = EV_ABS, .code = ABS_MT_SLOT, .value = LITEST_AUTO_ASSIGN },
+		{ .type = EV_ABS, .code = ABS_MT_TRACKING_ID, .value = -1 },
+		{ .type = EV_ABS, .code = ABS_MT_PRESSURE, .value = 0 },
+		{ .type = EV_ABS, .code = ABS_MT_TOUCH_MAJOR, .value = 0 },
+		{ .type = EV_ABS, .code = ABS_MT_TOUCH_MINOR, .value = 0 },
+		{ .type = EV_SYN, .code = SYN_REPORT, .value = 0 },
+		{ .type = -1, .code = -1 }
+	};
+
+	litest_assert_int_gt(d->ntouches_down, 0);
+	d->ntouches_down--;
+
+	send_btntool(d, false);
+
+	if (d->interface->touch_up) {
+		d->interface->touch_up(d, slot);
+		return;
+	} else if (d->interface->touch_up_events) {
+		ev = d->interface->touch_up_events;
+	} else
+		ev = up;
+
+	for ( /* */;
+	     ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1;
+	     ev++) {
+		int value = litest_auto_assign_value(d,
+						     ev,
+						     slot,
+						     0,
+						     0,
+						     NULL,
+						     false);
+		litest_event(d, ev->type, ev->code, value);
+	}
+}
+
+static void
+litest_slot_start(struct litest_device *d,
+		  unsigned int slot,
+		  double x,
+		  double y,
+		  struct axis_replacement *axes,
+		  bool touching)
+{
+	double t, l, r = 0, b = 0; /* top, left, right, bottom */
+	bool filter_abs_xy = false;
+
+	if (!d->semi_mt.is_semi_mt) {
+		slot_start(d, slot, x, y, axes, touching, filter_abs_xy);
+		return;
+	}
+
+	if (d->ntouches_down >= 2 || slot > 1)
+		return;
+
+	slot = d->ntouches_down;
+
+	if (d->ntouches_down == 0) {
+		l = x;
+		t = y;
+	} else {
+		int other = (slot + 1) % 2;
+		l = min(x, d->semi_mt.touches[other].x);
+		t = min(y, d->semi_mt.touches[other].y);
+		r = max(x, d->semi_mt.touches[other].x);
+		b = max(y, d->semi_mt.touches[other].y);
+	}
+
+	litest_push_event_frame(d);
+	if (d->ntouches_down == 0)
+		slot_start(d, 0, l, t, axes, touching, filter_abs_xy);
+	else
+		slot_move(d, 0, l, t, axes, touching, filter_abs_xy);
+
+	if (slot == 1) {
+		filter_abs_xy = true;
+		slot_start(d, 1, r, b, axes, touching, filter_abs_xy);
+	}
+
+	litest_pop_event_frame(d);
+
+	d->semi_mt.touches[slot].x = x;
+	d->semi_mt.touches[slot].y = y;
+}
+
+void
+litest_touch_down(struct litest_device *d,
+		  unsigned int slot,
+		  double x,
+		  double y)
+{
+	litest_slot_start(d, slot, x, y, NULL, true);
+}
+
+void
+litest_touch_down_extended(struct litest_device *d,
+			   unsigned int slot,
+			   double x,
+			   double y,
+			   struct axis_replacement *axes)
+{
+	litest_slot_start(d, slot, x, y, axes, true);
+}
+
+static void
+litest_slot_move(struct litest_device *d,
+		 unsigned int slot,
+		 double x,
+		 double y,
+		 struct axis_replacement *axes,
+		 bool touching)
+{
+	double t, l, r = 0, b = 0; /* top, left, right, bottom */
+	bool filter_abs_xy = false;
+
+	if (!d->semi_mt.is_semi_mt) {
+		slot_move(d, slot, x, y, axes, touching, filter_abs_xy);
+		return;
+	}
+
+	if (d->ntouches_down > 2 || slot > 1)
+		return;
+
+	if (d->ntouches_down == 1) {
+		l = x;
+		t = y;
+	} else {
+		int other = (slot + 1) % 2;
+		l = min(x, d->semi_mt.touches[other].x);
+		t = min(y, d->semi_mt.touches[other].y);
+		r = max(x, d->semi_mt.touches[other].x);
+		b = max(y, d->semi_mt.touches[other].y);
+	}
+
+	litest_push_event_frame(d);
+	slot_move(d, 0, l, t, axes, touching, filter_abs_xy);
+
+	if (d->ntouches_down == 2) {
+		filter_abs_xy = true;
+		slot_move(d, 1, r, b, axes, touching, filter_abs_xy);
+	}
+
+	litest_pop_event_frame(d);
+
+	d->semi_mt.touches[slot].x = x;
+	d->semi_mt.touches[slot].y = y;
+}
+
+void
+litest_touch_up(struct litest_device *d, unsigned int slot)
+{
+	if (!d->semi_mt.is_semi_mt) {
+		touch_up(d, slot);
+		return;
+	}
+
+	if (d->ntouches_down > 2 || slot > 1)
+		return;
+
+	litest_push_event_frame(d);
+	touch_up(d, d->ntouches_down - 1);
+
+	/* if we have one finger left, send x/y coords for that finger left.
+	   this is likely to happen with a real touchpad */
+	if (d->ntouches_down == 1) {
+		bool touching = true;
+		bool filter_abs_xy = false;
+
+		int other = (slot + 1) % 2;
+		slot_move(d,
+			  0,
+			  d->semi_mt.touches[other].x,
+			  d->semi_mt.touches[other].y,
+			  NULL,
+			  touching,
+			  filter_abs_xy);
+	}
+
+	litest_pop_event_frame(d);
+}
+
+void
+litest_touch_move(struct litest_device *d,
+		  unsigned int slot,
+		  double x,
+		  double y)
+{
+	litest_slot_move(d, slot, x, y, NULL, true);
+}
+
+void
+litest_touch_move_extended(struct litest_device *d,
+			   unsigned int slot,
+			   double x,
+			   double y,
+			   struct axis_replacement *axes)
+{
+	litest_slot_move(d, slot, x, y, axes, true);
+}
+
+void
+litest_touch_move_to(struct litest_device *d,
+		     unsigned int slot,
+		     double x_from, double y_from,
+		     double x_to, double y_to,
+		     int steps, int sleep_ms)
+{
+	for (int i = 1; i < steps; i++) {
+		litest_touch_move(d, slot,
+				  x_from + (x_to - x_from)/steps * i,
+				  y_from + (y_to - y_from)/steps * i);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+			libinput_dispatch(d->libinput);
+		}
+	}
+	litest_touch_move(d, slot, x_to, y_to);
+}
+
+void
+litest_touch_move_to_extended(struct litest_device *d,
+			      unsigned int slot,
+			      double x_from, double y_from,
+			      double x_to, double y_to,
+			      struct axis_replacement *axes,
+			      int steps, int sleep_ms)
+{
+	for (int i = 1; i < steps - 1; i++) {
+		litest_touch_move_extended(d, slot,
+					   x_from + (x_to - x_from)/steps * i,
+					   y_from + (y_to - y_from)/steps * i,
+					   axes);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+			libinput_dispatch(d->libinput);
+		}
+	}
+	litest_touch_move_extended(d, slot, x_to, y_to, axes);
+}
+
+static int
+auto_assign_tablet_value(struct litest_device *d,
+			 const struct input_event *ev,
+			 int x, int y,
+			 struct axis_replacement *axes)
+{
+	int value = ev->value;
+
+	if (value != LITEST_AUTO_ASSIGN || ev->type != EV_ABS)
+		return value;
+
+	switch (ev->code) {
+	case ABS_X:
+		value = litest_scale(d, ABS_X, x);
+		break;
+	case ABS_Y:
+		value = litest_scale(d, ABS_Y, y);
+		break;
+	default:
+		if (!axis_replacement_value(d, axes, ev->code, &value) &&
+		    d->interface->get_axis_default)
+			d->interface->get_axis_default(d, ev->code, &value);
+		break;
+	}
+
+	return value;
+}
+
+static int
+tablet_ignore_event(const struct input_event *ev, int value)
+{
+	return value == -1 && (ev->code == ABS_PRESSURE || ev->code == ABS_DISTANCE);
+}
+
+void
+litest_tablet_proximity_in(struct litest_device *d, int x, int y, struct axis_replacement *axes)
+{
+	struct input_event *ev;
+
+	ev = d->interface->tablet_proximity_in_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		int value = auto_assign_tablet_value(d, ev, x, y, axes);
+		if (!tablet_ignore_event(ev, value))
+			litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_tablet_proximity_out(struct litest_device *d)
+{
+	struct input_event *ev;
+
+	ev = d->interface->tablet_proximity_out_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		int value = auto_assign_tablet_value(d, ev, -1, -1, NULL);
+		if (!tablet_ignore_event(ev, value))
+			litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_tablet_motion(struct litest_device *d, int x, int y, struct axis_replacement *axes)
+{
+	struct input_event *ev;
+
+	ev = d->interface->tablet_motion_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		int value = auto_assign_tablet_value(d, ev, x, y, axes);
+		if (!tablet_ignore_event(ev, value))
+			litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_touch_move_two_touches(struct litest_device *d,
+			      double x0, double y0,
+			      double x1, double y1,
+			      double dx, double dy,
+			      int steps, int sleep_ms)
+{
+	for (int i = 1; i < steps; i++) {
+		litest_push_event_frame(d);
+		litest_touch_move(d, 0, x0 + dx / steps * i,
+					y0 + dy / steps * i);
+		litest_touch_move(d, 1, x1 + dx / steps * i,
+					y1 + dy / steps * i);
+		litest_pop_event_frame(d);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+		}
+		libinput_dispatch(d->libinput);
+	}
+	litest_push_event_frame(d);
+	litest_touch_move(d, 0, x0 + dx, y0 + dy);
+	litest_touch_move(d, 1, x1 + dx, y1 + dy);
+	litest_pop_event_frame(d);
+}
+
+void
+litest_touch_move_three_touches(struct litest_device *d,
+				double x0, double y0,
+				double x1, double y1,
+				double x2, double y2,
+				double dx, double dy,
+				int steps, int sleep_ms)
+{
+	for (int i = 0; i < steps - 1; i++) {
+		litest_touch_move(d, 0, x0 + dx / steps * i,
+					y0 + dy / steps * i);
+		litest_touch_move(d, 1, x1 + dx / steps * i,
+					y1 + dy / steps * i);
+		litest_touch_move(d, 2, x2 + dx / steps * i,
+					y2 + dy / steps * i);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+			libinput_dispatch(d->libinput);
+		}
+	}
+	litest_touch_move(d, 0, x0 + dx, y0 + dy);
+	litest_touch_move(d, 1, x1 + dx, y1 + dy);
+	litest_touch_move(d, 2, x2 + dx, y2 + dy);
+}
+
+void
+litest_hover_start(struct litest_device *d,
+		   unsigned int slot,
+		   double x,
+		   double y)
+{
+	struct axis_replacement axes[] = {
+		{ABS_MT_PRESSURE, 0 },
+		{ABS_PRESSURE, 0 },
+		{-1, -1 },
+	};
+
+	litest_slot_start(d, slot, x, y, axes, 0);
+}
+
+void
+litest_hover_end(struct litest_device *d, unsigned int slot)
+{
+	struct input_event *ev;
+	struct input_event up[] = {
+		{ .type = EV_ABS, .code = ABS_MT_SLOT, .value = LITEST_AUTO_ASSIGN },
+		{ .type = EV_ABS, .code = ABS_MT_DISTANCE, .value = 1 },
+		{ .type = EV_ABS, .code = ABS_MT_TRACKING_ID, .value = -1 },
+		{ .type = EV_SYN, .code = SYN_REPORT, .value = 0 },
+		{ .type = -1, .code = -1 }
+	};
+
+	litest_assert_int_gt(d->ntouches_down, 0);
+	d->ntouches_down--;
+
+	send_btntool(d, true);
+
+	if (d->interface->touch_up) {
+		d->interface->touch_up(d, slot);
+		return;
+	} else if (d->interface->touch_up_events) {
+		ev = d->interface->touch_up_events;
+	} else
+		ev = up;
+
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		int value = litest_auto_assign_value(d, ev, slot, 0, 0, NULL, false);
+		litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_hover_move(struct litest_device *d, unsigned int slot,
+		  double x, double y)
+{
+	struct axis_replacement axes[] = {
+		{ABS_MT_PRESSURE, 0 },
+		{ABS_PRESSURE, 0 },
+		{-1, -1 },
+	};
+
+	litest_slot_move(d, slot, x, y, axes, false);
+}
+
+void
+litest_hover_move_to(struct litest_device *d,
+		     unsigned int slot,
+		     double x_from, double y_from,
+		     double x_to, double y_to,
+		     int steps, int sleep_ms)
+{
+	for (int i = 0; i < steps - 1; i++) {
+		litest_hover_move(d, slot,
+				  x_from + (x_to - x_from)/steps * i,
+				  y_from + (y_to - y_from)/steps * i);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+			libinput_dispatch(d->libinput);
+		}
+	}
+	litest_hover_move(d, slot, x_to, y_to);
+}
+
+void
+litest_hover_move_two_touches(struct litest_device *d,
+			      double x0, double y0,
+			      double x1, double y1,
+			      double dx, double dy,
+			      int steps, int sleep_ms)
+{
+	for (int i = 0; i < steps - 1; i++) {
+		litest_push_event_frame(d);
+		litest_hover_move(d, 0, x0 + dx / steps * i,
+					y0 + dy / steps * i);
+		litest_hover_move(d, 1, x1 + dx / steps * i,
+					y1 + dy / steps * i);
+		litest_pop_event_frame(d);
+		if (sleep_ms) {
+			libinput_dispatch(d->libinput);
+			msleep(sleep_ms);
+			libinput_dispatch(d->libinput);
+		}
+	}
+	litest_push_event_frame(d);
+	litest_hover_move(d, 0, x0 + dx, y0 + dy);
+	litest_hover_move(d, 1, x1 + dx, y1 + dy);
+	litest_pop_event_frame(d);
+}
+
+void
+litest_button_click(struct litest_device *d,
+		    unsigned int button,
+		    bool is_press)
+{
+	struct input_event *ev;
+	struct input_event click[] = {
+		{ .type = EV_KEY, .code = button, .value = is_press ? 1 : 0 },
+		{ .type = EV_SYN, .code = SYN_REPORT, .value = 0 },
+	};
+
+	ARRAY_FOR_EACH(click, ev)
+		litest_event(d, ev->type, ev->code, ev->value);
+}
+
+void
+litest_button_click_debounced(struct litest_device *d,
+			      struct libinput *li,
+			      unsigned int button,
+			      bool is_press)
+{
+	litest_button_click(d, button, is_press);
+
+	libinput_dispatch(li);
+	litest_timeout_debounce();
+	libinput_dispatch(li);
+}
+
+void
+litest_button_scroll(struct litest_device *dev,
+		     unsigned int button,
+		     double dx, double dy)
+{
+	struct libinput *li = dev->libinput;
+
+	litest_button_click_debounced(dev, li, button, 1);
+
+	libinput_dispatch(li);
+	litest_timeout_buttonscroll();
+	libinput_dispatch(li);
+
+	litest_event(dev, EV_REL, REL_X, dx);
+	litest_event(dev, EV_REL, REL_Y, dy);
+	litest_event(dev, EV_SYN, SYN_REPORT, 0);
+
+	litest_button_click_debounced(dev, li, button, 0);
+
+	libinput_dispatch(li);
+}
+
+void
+litest_keyboard_key(struct litest_device *d, unsigned int key, bool is_press)
+{
+	struct input_event *ev;
+	struct input_event click[] = {
+		{ .type = EV_KEY, .code = key, .value = is_press ? 1 : 0 },
+		{ .type = EV_SYN, .code = SYN_REPORT, .value = 0 },
+	};
+
+	ARRAY_FOR_EACH(click, ev)
+		litest_event(d, ev->type, ev->code, ev->value);
+}
+
+void
+litest_switch_action(struct litest_device *dev,
+		     enum libinput_switch sw,
+		     enum libinput_switch_state state)
+{
+	unsigned int code;
+
+	switch (sw) {
+	case LIBINPUT_SWITCH_LID:
+		code = SW_LID;
+		break;
+	case LIBINPUT_SWITCH_TABLET_MODE:
+		code = SW_TABLET_MODE;
+		break;
+	default:
+		litest_abort_msg("Invalid switch %d", sw);
+		break;
+	}
+	litest_event(dev, EV_SW, code, state);
+	litest_event(dev, EV_SYN, SYN_REPORT, 0);
+}
+
+static int
+litest_scale_axis(const struct litest_device *d,
+		  unsigned int axis,
+		  double val)
+{
+	const struct input_absinfo *abs;
+
+	litest_assert_double_ge(val, 0.0);
+	/* major/minor must be able to beyond 100% for large fingers */
+	if (axis != ABS_MT_TOUCH_MAJOR &&
+	    axis != ABS_MT_TOUCH_MINOR) {
+		litest_assert_double_le(val, 100.0);
+	}
+
+	abs = libevdev_get_abs_info(d->evdev, axis);
+	litest_assert_notnull(abs);
+
+	return (abs->maximum - abs->minimum) * val/100.0 + abs->minimum;
+}
+
+static inline int
+litest_scale_range(int min, int max, double val)
+{
+	litest_assert_int_ge((int)val, 0);
+	litest_assert_int_le((int)val, 100);
+
+	return (max - min) * val/100.0 + min;
+}
+
+int
+litest_scale(const struct litest_device *d, unsigned int axis, double val)
+{
+	int min, max;
+
+	litest_assert_double_ge(val, 0.0);
+	/* major/minor must be able to beyond 100% for large fingers */
+	if (axis != ABS_MT_TOUCH_MAJOR &&
+	    axis != ABS_MT_TOUCH_MINOR)
+		litest_assert_double_le(val, 100.0);
+
+	if (axis <= ABS_Y) {
+		min = d->interface->min[axis];
+		max = d->interface->max[axis];
+
+		return litest_scale_range(min, max, val);
+	} else {
+		return litest_scale_axis(d, axis, val);
+	}
+}
+
+static inline int
+auto_assign_pad_value(struct litest_device *dev,
+		      struct input_event *ev,
+		      double value)
+{
+	const struct input_absinfo *abs;
+
+	if (ev->value != LITEST_AUTO_ASSIGN ||
+	    ev->type != EV_ABS)
+		return value;
+
+	abs = libevdev_get_abs_info(dev->evdev, ev->code);
+	litest_assert_notnull(abs);
+
+	if (ev->code == ABS_RX || ev->code == ABS_RY) {
+		double min = abs->minimum != 0 ? log2(abs->minimum) : 0,
+		       max = abs->maximum != 0 ? log2(abs->maximum) : 0;
+
+		/* Value 0 is reserved for finger up, so a value of 0% is
+		 * actually 1 */
+		if (value == 0.0) {
+			return 1;
+		} else {
+			value = litest_scale_range(min, max, value);
+			return pow(2, value);
+		}
+	} else {
+		return litest_scale_range(abs->minimum, abs->maximum, value);
+	}
+}
+
+void
+litest_pad_ring_start(struct litest_device *d, double value)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_ring_start_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		value = auto_assign_pad_value(d, ev, value);
+		litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_pad_ring_change(struct litest_device *d, double value)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_ring_change_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		value = auto_assign_pad_value(d, ev, value);
+		litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_pad_ring_end(struct litest_device *d)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_ring_end_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		litest_event(d, ev->type, ev->code, ev->value);
+		ev++;
+	}
+}
+
+void
+litest_pad_strip_start(struct litest_device *d, double value)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_strip_start_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		value = auto_assign_pad_value(d, ev, value);
+		litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_pad_strip_change(struct litest_device *d, double value)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_strip_change_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		value = auto_assign_pad_value(d, ev, value);
+		litest_event(d, ev->type, ev->code, value);
+		ev++;
+	}
+}
+
+void
+litest_pad_strip_end(struct litest_device *d)
+{
+	struct input_event *ev;
+
+	ev = d->interface->pad_strip_end_events;
+	while (ev && (int16_t)ev->type != -1 && (int16_t)ev->code != -1) {
+		litest_event(d, ev->type, ev->code, ev->value);
+		ev++;
+	}
+}
+
+void
+litest_wait_for_event(struct libinput *li)
+{
+	return litest_wait_for_event_of_type(li, -1);
+}
+
+void
+litest_wait_for_event_of_type(struct libinput *li, ...)
+{
+	va_list args;
+	enum libinput_event_type types[32] = {LIBINPUT_EVENT_NONE};
+	size_t ntypes = 0;
+	enum libinput_event_type type;
+	struct pollfd fds;
+
+	va_start(args, li);
+	type = va_arg(args, int);
+	while ((int)type != -1) {
+		litest_assert(type > 0);
+		litest_assert(ntypes < ARRAY_LENGTH(types));
+		types[ntypes++] = type;
+		type = va_arg(args, int);
+	}
+	va_end(args);
+
+	fds.fd = libinput_get_fd(li);
+	fds.events = POLLIN;
+	fds.revents = 0;
+
+	while (1) {
+		size_t i;
+		struct libinput_event *event;
+
+		while ((type = libinput_next_event_type(li)) == LIBINPUT_EVENT_NONE) {
+			int rc = poll(&fds, 1, 2000);
+			litest_assert_int_gt(rc, 0);
+			libinput_dispatch(li);
+		}
+
+		/* no event mask means wait for any event */
+		if (ntypes == 0)
+			return;
+
+		for (i = 0; i < ntypes; i++) {
+			if (type == types[i])
+				return;
+		}
+
+		event = libinput_get_event(li);
+		libinput_event_destroy(event);
+	}
+}
+
+void
+litest_drain_events(struct libinput *li)
+{
+	struct libinput_event *event;
+
+	libinput_dispatch(li);
+	while ((event = libinput_get_event(li))) {
+		libinput_event_destroy(event);
+		libinput_dispatch(li);
+	}
+}
+
+static const char *
+litest_event_type_str(enum libinput_event_type type)
+{
+	const char *str = NULL;
+
+	switch (type) {
+	case LIBINPUT_EVENT_NONE:
+		abort();
+	case LIBINPUT_EVENT_DEVICE_ADDED:
+		str = "ADDED";
+		break;
+	case LIBINPUT_EVENT_DEVICE_REMOVED:
+		str = "REMOVED";
+		break;
+	case LIBINPUT_EVENT_KEYBOARD_KEY:
+		str = "KEY";
+		break;
+	case LIBINPUT_EVENT_POINTER_MOTION:
+		str = "MOTION";
+		break;
+	case LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE:
+		str = "ABSOLUTE";
+		break;
+	case LIBINPUT_EVENT_POINTER_BUTTON:
+		str = "BUTTON";
+		break;
+	case LIBINPUT_EVENT_POINTER_AXIS:
+		str = "AXIS";
+		break;
+	case LIBINPUT_EVENT_TOUCH_DOWN:
+		str = "TOUCH DOWN";
+		break;
+	case LIBINPUT_EVENT_TOUCH_UP:
+		str = "TOUCH UP";
+		break;
+	case LIBINPUT_EVENT_TOUCH_MOTION:
+		str = "TOUCH MOTION";
+		break;
+	case LIBINPUT_EVENT_TOUCH_CANCEL:
+		str = "TOUCH CANCEL";
+		break;
+	case LIBINPUT_EVENT_TOUCH_FRAME:
+		str = "TOUCH FRAME";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
+		str = "GESTURE SWIPE START";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE:
+		str = "GESTURE SWIPE UPDATE";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_END:
+		str = "GESTURE SWIPE END";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_BEGIN:
+		str = "GESTURE PINCH START";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_UPDATE:
+		str = "GESTURE PINCH UPDATE";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_END:
+		str = "GESTURE PINCH END";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+		str = "TABLET TOOL AXIS";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+		str = "TABLET TOOL PROX";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+		str = "TABLET TOOL TIP";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+		str = "TABLET TOOL BUTTON";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+		str = "TABLET PAD BUTTON";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_RING:
+		str = "TABLET PAD RING";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+		str = "TABLET PAD STRIP";
+		break;
+	case LIBINPUT_EVENT_SWITCH_TOGGLE:
+		str = "SWITCH TOGGLE";
+		break;
+	}
+	return str;
+}
+
+static const char *
+litest_event_get_type_str(struct libinput_event *event)
+{
+	return litest_event_type_str(libinput_event_get_type(event));
+}
+
+static void
+litest_print_event(struct libinput_event *event)
+{
+	struct libinput_event_pointer *p;
+	struct libinput_event_tablet_tool *t;
+	struct libinput_event_tablet_pad *pad;
+	struct libinput_device *dev;
+	enum libinput_event_type type;
+	double x, y;
+
+	dev = libinput_event_get_device(event);
+	type = libinput_event_get_type(event);
+
+	fprintf(stderr,
+		"device %s type %s ",
+		libinput_device_get_sysname(dev),
+		litest_event_get_type_str(event));
+	switch (type) {
+	case LIBINPUT_EVENT_POINTER_MOTION:
+		p = libinput_event_get_pointer_event(event);
+		x = libinput_event_pointer_get_dx(p);
+		y = libinput_event_pointer_get_dy(p);
+		fprintf(stderr, "%.2f/%.2f", x, y);
+		break;
+	case LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE:
+		p = libinput_event_get_pointer_event(event);
+		x = libinput_event_pointer_get_absolute_x(p);
+		y = libinput_event_pointer_get_absolute_y(p);
+		fprintf(stderr, "%.2f/%.2f", x, y);
+		break;
+	case LIBINPUT_EVENT_POINTER_BUTTON:
+		p = libinput_event_get_pointer_event(event);
+		fprintf(stderr,
+			"button %d state %d",
+			libinput_event_pointer_get_button(p),
+			libinput_event_pointer_get_button_state(p));
+		break;
+	case LIBINPUT_EVENT_POINTER_AXIS:
+		p = libinput_event_get_pointer_event(event);
+		x = 0.0;
+		y = 0.0;
+		if (libinput_event_pointer_has_axis(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL))
+			y = libinput_event_pointer_get_axis_value(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL);
+		if (libinput_event_pointer_has_axis(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL))
+			x = libinput_event_pointer_get_axis_value(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL);
+		fprintf(stderr, "vert %.f horiz %.2f", y, x);
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+		t = libinput_event_get_tablet_tool_event(event);
+		fprintf(stderr, "proximity %d",
+			libinput_event_tablet_tool_get_proximity_state(t));
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+		t = libinput_event_get_tablet_tool_event(event);
+		fprintf(stderr, "tip %d",
+			libinput_event_tablet_tool_get_tip_state(t));
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+		t = libinput_event_get_tablet_tool_event(event);
+		fprintf(stderr, "button %d state %d",
+			libinput_event_tablet_tool_get_button(t),
+			libinput_event_tablet_tool_get_button_state(t));
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+		pad = libinput_event_get_tablet_pad_event(event);
+		fprintf(stderr, "button %d state %d",
+			libinput_event_tablet_pad_get_button_number(pad),
+			libinput_event_tablet_pad_get_button_state(pad));
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_RING:
+		pad = libinput_event_get_tablet_pad_event(event);
+		fprintf(stderr, "ring %d position %.2f source %d",
+			libinput_event_tablet_pad_get_ring_number(pad),
+			libinput_event_tablet_pad_get_ring_position(pad),
+			libinput_event_tablet_pad_get_ring_source(pad));
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+		pad = libinput_event_get_tablet_pad_event(event);
+		fprintf(stderr, "strip %d position %.2f source %d",
+			libinput_event_tablet_pad_get_ring_number(pad),
+			libinput_event_tablet_pad_get_ring_position(pad),
+			libinput_event_tablet_pad_get_ring_source(pad));
+		break;
+	default:
+		break;
+	}
+
+	fprintf(stderr, "\n");
+}
+
+void
+litest_assert_event_type(struct libinput_event *event,
+			 enum libinput_event_type want)
+{
+	if (libinput_event_get_type(event) == want)
+		return;
+
+	fprintf(stderr,
+		"FAILED EVENT TYPE: have %s (%d) but want %s (%d)\n",
+		litest_event_get_type_str(event),
+		libinput_event_get_type(event),
+		litest_event_type_str(want),
+		want);
+	litest_backtrace();
+	abort();
+}
+
+void
+litest_assert_empty_queue(struct libinput *li)
+{
+	bool empty_queue = true;
+	struct libinput_event *event;
+
+	libinput_dispatch(li);
+	while ((event = libinput_get_event(li))) {
+		empty_queue = false;
+		fprintf(stderr,
+			"Unexpected event: ");
+		litest_print_event(event);
+		libinput_event_destroy(event);
+		libinput_dispatch(li);
+	}
+
+	litest_assert(empty_queue);
+}
+
+static struct libevdev_uinput *
+litest_create_uinput(const char *name,
+		     const struct input_id *id,
+		     const struct input_absinfo *abs_info,
+		     const int *events)
+{
+	struct libevdev_uinput *uinput;
+	struct libevdev *dev;
+	int type, code;
+	int rc, fd;
+	const struct input_absinfo *abs;
+	const struct input_absinfo default_abs = {
+		.value = 0,
+		.minimum = 0,
+		.maximum = 100,
+		.fuzz = 0,
+		.flat = 0,
+		.resolution = 100
+	};
+	char buf[512];
+	const char *devnode;
+
+	dev = libevdev_new();
+	litest_assert(dev != NULL);
+
+	snprintf(buf, sizeof(buf), "litest %s", name);
+	libevdev_set_name(dev, buf);
+	if (id) {
+		libevdev_set_id_bustype(dev, id->bustype);
+		libevdev_set_id_vendor(dev, id->vendor);
+		libevdev_set_id_product(dev, id->product);
+		libevdev_set_id_version(dev, id->version);
+	}
+
+	abs = abs_info;
+	while (abs && abs->value != -1) {
+		struct input_absinfo a = *abs;
+
+		/* abs_info->value is used for the code and may be outside
+		   of [min, max] */
+		a.value = abs->minimum;
+		rc = libevdev_enable_event_code(dev, EV_ABS, abs->value, &a);
+		litest_assert_int_eq(rc, 0);
+		abs++;
+	}
+
+	while (events &&
+	       (type = *events++) != -1 &&
+	       (code = *events++) != -1) {
+		if (type == INPUT_PROP_MAX) {
+			rc = libevdev_enable_property(dev, code);
+		} else {
+			rc = libevdev_enable_event_code(dev, type, code,
+							type == EV_ABS ? &default_abs : NULL);
+		}
+		litest_assert_int_eq(rc, 0);
+	}
+
+	rc = libevdev_uinput_create_from_device(dev,
+					        LIBEVDEV_UINPUT_OPEN_MANAGED,
+						&uinput);
+	/* workaround for a bug in libevdev pre-1.3
+	   http://cgit.freedesktop.org/libevdev/commit/?id=debe9b030c8069cdf78307888ef3b65830b25122 */
+	if (rc == -EBADF)
+		rc = -EACCES;
+	litest_assert_msg(rc == 0, "Failed to create uinput device: %s\n", strerror(-rc));
+
+	libevdev_free(dev);
+
+	devnode = libevdev_uinput_get_devnode(uinput);
+	litest_assert_notnull(devnode);
+	fd = open(devnode, O_RDONLY);
+	litest_assert_int_gt(fd, -1);
+	rc = libevdev_new_from_fd(fd, &dev);
+	litest_assert_int_eq(rc, 0);
+
+	/* uinput before kernel 4.5 + libevdev 1.5.0 does not support
+	 * setting the resolution, so we set it afterwards. This is of
+	 * course racy as hell but the way we _generally_ use this function
+	 * by the time libinput uses the device, we're finished here.
+	 *
+	 * If you have kernel 4.5 and libevdev 1.5.0 or later, this code
+	 * just keeps the room warm.
+	 */
+	abs = abs_info;
+	while (abs && abs->value != -1) {
+		if (abs->resolution != 0) {
+			if (libevdev_get_abs_resolution(dev, abs->value) ==
+			    abs->resolution)
+				break;
+
+			rc = libevdev_kernel_set_abs_info(dev,
+							  abs->value,
+							  abs);
+			litest_assert_int_eq(rc, 0);
+		}
+		abs++;
+	}
+	close(fd);
+	libevdev_free(dev);
+
+	return uinput;
+}
+
+struct libevdev_uinput *
+litest_create_uinput_device_from_description(const char *name,
+					     const struct input_id *id,
+					     const struct input_absinfo *abs_info,
+					     const int *events)
+{
+	struct libevdev_uinput *uinput;
+	const char *syspath;
+	char path[PATH_MAX];
+
+	struct udev *udev;
+	struct udev_monitor *udev_monitor;
+	struct udev_device *udev_device;
+	const char *udev_action;
+	const char *udev_syspath = NULL;
+	int rc;
+
+	udev = udev_new();
+	litest_assert_notnull(udev);
+	udev_monitor = udev_monitor_new_from_netlink(udev, "udev");
+	litest_assert_notnull(udev_monitor);
+	udev_monitor_filter_add_match_subsystem_devtype(udev_monitor, "input",
+							NULL);
+	/* remove O_NONBLOCK */
+	rc = fcntl(udev_monitor_get_fd(udev_monitor), F_SETFL, 0);
+	litest_assert_int_ne(rc, -1);
+	litest_assert_int_eq(udev_monitor_enable_receiving(udev_monitor),
+			     0);
+
+	uinput = litest_create_uinput(name, id, abs_info, events);
+
+	syspath = libevdev_uinput_get_syspath(uinput);
+	snprintf(path, sizeof(path), "%s/event", syspath);
+
+	/* blocking, we don't want to continue until udev is ready */
+	while (1) {
+		udev_device = udev_monitor_receive_device(udev_monitor);
+		litest_assert_notnull(udev_device);
+		udev_action = udev_device_get_action(udev_device);
+		if (strcmp(udev_action, "add") != 0) {
+			udev_device_unref(udev_device);
+			continue;
+		}
+
+		udev_syspath = udev_device_get_syspath(udev_device);
+		if (udev_syspath && strneq(udev_syspath, path, strlen(path)))
+			break;
+
+		udev_device_unref(udev_device);
+	}
+
+	litest_assert(udev_device_get_property_value(udev_device, "ID_INPUT"));
+
+	udev_device_unref(udev_device);
+	udev_monitor_unref(udev_monitor);
+	udev_unref(udev);
+
+	return uinput;
+}
+
+static struct libevdev_uinput *
+litest_create_uinput_abs_device_v(const char *name,
+				  struct input_id *id,
+				  const struct input_absinfo *abs,
+				  va_list args)
+{
+	int events[KEY_MAX * 2 + 2]; /* increase this if not sufficient */
+	int *event = events;
+	int type, code;
+
+	while ((type = va_arg(args, int)) != -1 &&
+	       (code = va_arg(args, int)) != -1) {
+		*event++ = type;
+		*event++ = code;
+		litest_assert(event < &events[ARRAY_LENGTH(events) - 2]);
+	}
+
+	*event++ = -1;
+	*event++ = -1;
+
+	return litest_create_uinput_device_from_description(name, id,
+							    abs, events);
+}
+
+struct libevdev_uinput *
+litest_create_uinput_abs_device(const char *name,
+				struct input_id *id,
+				const struct input_absinfo *abs,
+				...)
+{
+	struct libevdev_uinput *uinput;
+	va_list args;
+
+	va_start(args, abs);
+	uinput = litest_create_uinput_abs_device_v(name, id, abs, args);
+	va_end(args);
+
+	return uinput;
+}
+
+struct libevdev_uinput *
+litest_create_uinput_device(const char *name, struct input_id *id, ...)
+{
+	struct libevdev_uinput *uinput;
+	va_list args;
+
+	va_start(args, id);
+	uinput = litest_create_uinput_abs_device_v(name, id, NULL, args);
+	va_end(args);
+
+	return uinput;
+}
+
+struct libinput_event_pointer*
+litest_is_button_event(struct libinput_event *event,
+		       unsigned int button,
+		       enum libinput_button_state state)
+{
+	struct libinput_event_pointer *ptrev;
+	enum libinput_event_type type = LIBINPUT_EVENT_POINTER_BUTTON;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+	ptrev = libinput_event_get_pointer_event(event);
+	litest_assert_int_eq(libinput_event_pointer_get_button(ptrev),
+			     button);
+	litest_assert_int_eq(libinput_event_pointer_get_button_state(ptrev),
+			     state);
+
+	return ptrev;
+}
+
+struct libinput_event_pointer *
+litest_is_axis_event(struct libinput_event *event,
+		     enum libinput_pointer_axis axis,
+		     enum libinput_pointer_axis_source source)
+{
+	struct libinput_event_pointer *ptrev;
+	enum libinput_event_type type = LIBINPUT_EVENT_POINTER_AXIS;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+	ptrev = libinput_event_get_pointer_event(event);
+	litest_assert(libinput_event_pointer_has_axis(ptrev, axis));
+
+	if (source != 0)
+		litest_assert_int_eq(libinput_event_pointer_get_axis_source(ptrev),
+				     source);
+
+	return ptrev;
+}
+
+struct libinput_event_pointer *
+litest_is_motion_event(struct libinput_event *event)
+{
+	struct libinput_event_pointer *ptrev;
+	enum libinput_event_type type = LIBINPUT_EVENT_POINTER_MOTION;
+	double x, y, ux, uy;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+	ptrev = libinput_event_get_pointer_event(event);
+
+	x = libinput_event_pointer_get_dx(ptrev);
+	y = libinput_event_pointer_get_dy(ptrev);
+	ux = libinput_event_pointer_get_dx_unaccelerated(ptrev);
+	uy = libinput_event_pointer_get_dy_unaccelerated(ptrev);
+
+	/* No 0 delta motion events */
+	litest_assert(x != 0.0 || y != 0.0 ||
+		      ux != 0.0 || uy != 0.0);
+
+	return ptrev;
+}
+
+void
+litest_assert_key_event(struct libinput *li, unsigned int key,
+			enum libinput_key_state state)
+{
+	struct libinput_event *event;
+
+	litest_wait_for_event(li);
+	event = libinput_get_event(li);
+
+	litest_is_keyboard_event(event, key, state);
+
+	libinput_event_destroy(event);
+}
+
+void
+litest_assert_button_event(struct libinput *li, unsigned int button,
+			   enum libinput_button_state state)
+{
+	struct libinput_event *event;
+
+	litest_wait_for_event(li);
+	event = libinput_get_event(li);
+
+	litest_is_button_event(event, button, state);
+
+	libinput_event_destroy(event);
+}
+
+struct libinput_event_touch *
+litest_is_touch_event(struct libinput_event *event,
+		      enum libinput_event_type type)
+{
+	struct libinput_event_touch *touch;
+
+	litest_assert(event != NULL);
+
+	if (type == 0)
+		type = libinput_event_get_type(event);
+
+	switch (type) {
+	case LIBINPUT_EVENT_TOUCH_DOWN:
+	case LIBINPUT_EVENT_TOUCH_UP:
+	case LIBINPUT_EVENT_TOUCH_MOTION:
+	case LIBINPUT_EVENT_TOUCH_FRAME:
+		litest_assert_event_type(event, type);
+		break;
+	default:
+		ck_abort_msg("%s: invalid touch type %d\n", __func__, type);
+	}
+
+	touch = libinput_event_get_touch_event(event);
+
+	return touch;
+}
+
+struct libinput_event_keyboard *
+litest_is_keyboard_event(struct libinput_event *event,
+			 unsigned int key,
+			 enum libinput_key_state state)
+{
+	struct libinput_event_keyboard *kevent;
+	enum libinput_event_type type = LIBINPUT_EVENT_KEYBOARD_KEY;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+
+	kevent = libinput_event_get_keyboard_event(event);
+	litest_assert(kevent != NULL);
+
+	litest_assert_int_eq(libinput_event_keyboard_get_key(kevent), key);
+	litest_assert_int_eq(libinput_event_keyboard_get_key_state(kevent),
+			     state);
+	return kevent;
+}
+
+struct libinput_event_gesture *
+litest_is_gesture_event(struct libinput_event *event,
+			enum libinput_event_type type,
+			int nfingers)
+{
+	struct libinput_event_gesture *gevent;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+
+	gevent = libinput_event_get_gesture_event(event);
+	litest_assert(gevent != NULL);
+
+	if (nfingers != -1)
+		litest_assert_int_eq(libinput_event_gesture_get_finger_count(gevent),
+				     nfingers);
+	return gevent;
+}
+
+struct libinput_event_tablet_tool *
+litest_is_tablet_event(struct libinput_event *event,
+		       enum libinput_event_type type)
+{
+	struct libinput_event_tablet_tool *tevent;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+
+	tevent = libinput_event_get_tablet_tool_event(event);
+	litest_assert(tevent != NULL);
+
+	return tevent;
+}
+
+void
+litest_assert_tablet_button_event(struct libinput *li, unsigned int button,
+				  enum libinput_button_state state)
+{
+	struct libinput_event *event;
+	struct libinput_event_tablet_tool *tev;
+	enum libinput_event_type type = LIBINPUT_EVENT_TABLET_TOOL_BUTTON;
+
+	litest_wait_for_event(li);
+	event = libinput_get_event(li);
+
+	litest_assert_notnull(event);
+	litest_assert_event_type(event, type);
+	tev = libinput_event_get_tablet_tool_event(event);
+	litest_assert_int_eq(libinput_event_tablet_tool_get_button(tev),
+			     button);
+	litest_assert_int_eq(libinput_event_tablet_tool_get_button_state(tev),
+			     state);
+	libinput_event_destroy(event);
+}
+
+void litest_assert_tablet_proximity_event(struct libinput *li,
+					  enum libinput_tablet_tool_proximity_state state)
+{
+	struct libinput_event *event;
+	struct libinput_event_tablet_tool *tev;
+	enum libinput_event_type type = LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY;
+
+	litest_wait_for_event(li);
+	event = libinput_get_event(li);
+
+	litest_assert_notnull(event);
+	litest_assert_event_type(event, type);
+	tev = libinput_event_get_tablet_tool_event(event);
+	litest_assert_int_eq(libinput_event_tablet_tool_get_proximity_state(tev),
+			     state);
+	libinput_event_destroy(event);
+}
+
+struct libinput_event_tablet_pad *
+litest_is_pad_button_event(struct libinput_event *event,
+			   unsigned int button,
+			   enum libinput_button_state state)
+{
+	struct libinput_event_tablet_pad *p;
+	enum libinput_event_type type = LIBINPUT_EVENT_TABLET_PAD_BUTTON;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+
+	p = libinput_event_get_tablet_pad_event(event);
+	litest_assert(p != NULL);
+
+	litest_assert_int_eq(libinput_event_tablet_pad_get_button_number(p),
+			     button);
+	litest_assert_int_eq(libinput_event_tablet_pad_get_button_state(p),
+			     state);
+
+	return p;
+}
+
+struct libinput_event_tablet_pad *
+litest_is_pad_ring_event(struct libinput_event *event,
+			 unsigned int number,
+			 enum libinput_tablet_pad_ring_axis_source source)
+{
+	struct libinput_event_tablet_pad *p;
+	enum libinput_event_type type = LIBINPUT_EVENT_TABLET_PAD_RING;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+	p = libinput_event_get_tablet_pad_event(event);
+
+	litest_assert_int_eq(libinput_event_tablet_pad_get_ring_number(p),
+			     number);
+	litest_assert_int_eq(libinput_event_tablet_pad_get_ring_source(p),
+			     source);
+
+	return p;
+}
+
+struct libinput_event_tablet_pad *
+litest_is_pad_strip_event(struct libinput_event *event,
+			  unsigned int number,
+			  enum libinput_tablet_pad_strip_axis_source source)
+{
+	struct libinput_event_tablet_pad *p;
+	enum libinput_event_type type = LIBINPUT_EVENT_TABLET_PAD_STRIP;
+
+	litest_assert(event != NULL);
+	litest_assert_event_type(event, type);
+	p = libinput_event_get_tablet_pad_event(event);
+
+	litest_assert_int_eq(libinput_event_tablet_pad_get_strip_number(p),
+			     number);
+	litest_assert_int_eq(libinput_event_tablet_pad_get_strip_source(p),
+			     source);
+
+	return p;
+}
+
+struct libinput_event_switch *
+litest_is_switch_event(struct libinput_event *event,
+		       enum libinput_switch sw,
+		       enum libinput_switch_state state)
+{
+	struct libinput_event_switch *swev;
+	enum libinput_event_type type = LIBINPUT_EVENT_SWITCH_TOGGLE;
+
+	litest_assert_notnull(event);
+	litest_assert_event_type(event, type);
+	swev = libinput_event_get_switch_event(event);
+
+	litest_assert_int_eq(libinput_event_switch_get_switch(swev), sw);
+	litest_assert_int_eq(libinput_event_switch_get_switch_state(swev),
+			     state);
+
+	return swev;
+}
+
+void
+litest_assert_pad_button_event(struct libinput *li,
+			       unsigned int button,
+			       enum libinput_button_state state)
+{
+	struct libinput_event *event;
+	struct libinput_event_tablet_pad *pev;
+
+	litest_wait_for_event(li);
+	event = libinput_get_event(li);
+
+	pev = litest_is_pad_button_event(event, button, state);
+	libinput_event_destroy(libinput_event_tablet_pad_get_base_event(pev));
+}
+
+void
+litest_assert_scroll(struct libinput *li,
+		     enum libinput_pointer_axis axis,
+		     int minimum_movement)
+{
+	struct libinput_event *event, *next_event;
+	struct libinput_event_pointer *ptrev;
+	int value;
+	int nevents = 0;
+
+	event = libinput_get_event(li);
+	next_event = libinput_get_event(li);
+	litest_assert(next_event != NULL); /* At least 1 scroll + stop scroll */
+
+	while (event) {
+		ptrev = litest_is_axis_event(event, axis, 0);
+		nevents++;
+
+		if (next_event) {
+			int min = minimum_movement;
+
+			value = libinput_event_pointer_get_axis_value(ptrev,
+								      axis);
+			/* Due to how the hysteresis works on touchpad
+			 * events, the first event is reduced by the
+			 * hysteresis margin that can cause the first event
+			 * go under the minimum we expect for all other
+			 * events */
+			if (nevents == 1)
+				min = minimum_movement/2;
+
+			/* Normal scroll event, check dir */
+			if (minimum_movement > 0)
+				litest_assert_int_ge(value, min);
+			else
+				litest_assert_int_le(value, min);
+		} else {
+			/* Last scroll event, must be 0 */
+			ck_assert_double_eq(
+				libinput_event_pointer_get_axis_value(ptrev, axis),
+				0.0);
+		}
+		libinput_event_destroy(event);
+		event = next_event;
+		next_event = libinput_get_event(li);
+	}
+}
+
+void
+litest_assert_only_typed_events(struct libinput *li,
+				enum libinput_event_type type)
+{
+	struct libinput_event *event;
+
+	litest_assert(type != LIBINPUT_EVENT_NONE);
+
+	libinput_dispatch(li);
+	event = libinput_get_event(li);
+	litest_assert_notnull(event);
+
+	while (event) {
+		litest_assert_int_eq(libinput_event_get_type(event),
+                                     type);
+		libinput_event_destroy(event);
+		libinput_dispatch(li);
+		event = libinput_get_event(li);
+	}
+}
+
+void
+litest_assert_touch_sequence(struct libinput *li)
+{
+	struct libinput_event *event;
+
+	event = libinput_get_event(li);
+	litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_DOWN);
+	libinput_event_destroy(event);
+
+	event = libinput_get_event(li);
+	litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_FRAME);
+	libinput_event_destroy(event);
+
+	event = libinput_get_event(li);
+	do {
+		litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_MOTION);
+		libinput_event_destroy(event);
+
+		event = libinput_get_event(li);
+		litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_FRAME);
+		libinput_event_destroy(event);
+
+		event = libinput_get_event(li);
+		litest_assert_notnull(event);
+	} while (libinput_event_get_type(event) != LIBINPUT_EVENT_TOUCH_UP);
+
+	litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_UP);
+	libinput_event_destroy(event);
+	event = libinput_get_event(li);
+	litest_is_touch_event(event, LIBINPUT_EVENT_TOUCH_FRAME);
+	libinput_event_destroy(event);
+}
+
+void
+litest_timeout_tap(void)
+{
+	msleep(200);
+}
+
+void
+litest_timeout_tapndrag(void)
+{
+	msleep(520);
+}
+
+void
+litest_timeout_debounce(void)
+{
+	msleep(30);
+}
+
+void
+litest_timeout_softbuttons(void)
+{
+	msleep(300);
+}
+
+void
+litest_timeout_buttonscroll(void)
+{
+	msleep(300);
+}
+
+void
+litest_timeout_finger_switch(void)
+{
+	msleep(120);
+}
+
+void
+litest_timeout_edgescroll(void)
+{
+	msleep(300);
+}
+
+void
+litest_timeout_middlebutton(void)
+{
+	msleep(70);
+}
+
+void
+litest_timeout_dwt_short(void)
+{
+	msleep(220);
+}
+
+void
+litest_timeout_dwt_long(void)
+{
+	msleep(520);
+}
+
+void
+litest_timeout_gesture(void)
+{
+	msleep(120);
+}
+
+void
+litest_timeout_gesture_scroll(void)
+{
+	msleep(180);
+}
+
+void
+litest_timeout_trackpoint(void)
+{
+	msleep(320);
+}
+
+void
+litest_timeout_tablet_proxout(void)
+{
+	msleep(70);
+}
+
+void
+litest_timeout_hysteresis(void)
+{
+	msleep(90);
+}
+
+void
+litest_push_event_frame(struct litest_device *dev)
+{
+	litest_assert(dev->skip_ev_syn >= 0);
+	dev->skip_ev_syn++;
+}
+
+void
+litest_pop_event_frame(struct litest_device *dev)
+{
+	litest_assert(dev->skip_ev_syn > 0);
+	dev->skip_ev_syn--;
+	if (dev->skip_ev_syn == 0)
+		litest_event(dev, EV_SYN, SYN_REPORT, 0);
+}
+
+void
+litest_filter_event(struct litest_device *dev,
+		    unsigned int type,
+		    unsigned int code)
+{
+	libevdev_disable_event_code(dev->evdev, type, code);
+}
+
+void
+litest_unfilter_event(struct litest_device *dev,
+		      unsigned int type,
+		      unsigned int code)
+{
+	/* would need an non-NULL argument for re-enabling, so simply abort
+	 * until we need to be more sophisticated */
+	litest_assert(type != EV_ABS);
+
+	libevdev_enable_event_code(dev->evdev, type, code, NULL);
+}
+
+static void
+send_abs_xy(struct litest_device *d, double x, double y)
+{
+	struct input_event e;
+	int val;
+
+	e.type = EV_ABS;
+	e.code = ABS_X;
+	e.value = LITEST_AUTO_ASSIGN;
+	val = litest_auto_assign_value(d, &e, 0, x, y, NULL, true);
+	litest_event(d, EV_ABS, ABS_X, val);
+
+	e.code = ABS_Y;
+	val = litest_auto_assign_value(d, &e, 0, x, y, NULL, true);
+	litest_event(d, EV_ABS, ABS_Y, val);
+}
+
+static void
+send_abs_mt_xy(struct litest_device *d, double x, double y)
+{
+	struct input_event e;
+	int val;
+
+	e.type = EV_ABS;
+	e.code = ABS_MT_POSITION_X;
+	e.value = LITEST_AUTO_ASSIGN;
+	val = litest_auto_assign_value(d, &e, 0, x, y, NULL, true);
+	litest_event(d, EV_ABS, ABS_MT_POSITION_X, val);
+
+	e.code = ABS_MT_POSITION_Y;
+	e.value = LITEST_AUTO_ASSIGN;
+	val = litest_auto_assign_value(d, &e, 0, x, y, NULL, true);
+	litest_event(d, EV_ABS, ABS_MT_POSITION_Y, val);
+}
+
+void
+litest_semi_mt_touch_down(struct litest_device *d,
+			  struct litest_semi_mt *semi_mt,
+			  unsigned int slot,
+			  double x, double y)
+{
+	double t, l, r = 0, b = 0; /* top, left, right, bottom */
+
+	if (d->ntouches_down > 2 || slot > 1)
+		return;
+
+	if (d->ntouches_down == 1) {
+		l = x;
+		t = y;
+	} else {
+		int other = (slot + 1) % 2;
+		l = min(x, semi_mt->touches[other].x);
+		t = min(y, semi_mt->touches[other].y);
+		r = max(x, semi_mt->touches[other].x);
+		b = max(y, semi_mt->touches[other].y);
+	}
+
+	send_abs_xy(d, l, t);
+
+	litest_event(d, EV_ABS, ABS_MT_SLOT, 0);
+
+	if (d->ntouches_down == 1)
+		litest_event(d, EV_ABS, ABS_MT_TRACKING_ID, ++semi_mt->tracking_id);
+
+	send_abs_mt_xy(d, l, t);
+
+	if (d->ntouches_down == 2) {
+		litest_event(d, EV_ABS, ABS_MT_SLOT, 1);
+		litest_event(d, EV_ABS, ABS_MT_TRACKING_ID, ++semi_mt->tracking_id);
+
+		send_abs_mt_xy(d, r, b);
+	}
+
+	litest_event(d, EV_SYN, SYN_REPORT, 0);
+
+	semi_mt->touches[slot].x = x;
+	semi_mt->touches[slot].y = y;
+}
+
+void
+litest_semi_mt_touch_move(struct litest_device *d,
+			  struct litest_semi_mt *semi_mt,
+			  unsigned int slot,
+			  double x, double y)
+{
+	double t, l, r = 0, b = 0; /* top, left, right, bottom */
+
+	if (d->ntouches_down > 2 || slot > 1)
+		return;
+
+	if (d->ntouches_down == 1) {
+		l = x;
+		t = y;
+	} else {
+		int other = (slot + 1) % 2;
+		l = min(x, semi_mt->touches[other].x);
+		t = min(y, semi_mt->touches[other].y);
+		r = max(x, semi_mt->touches[other].x);
+		b = max(y, semi_mt->touches[other].y);
+	}
+
+	send_abs_xy(d, l, t);
+
+	litest_event(d, EV_ABS, ABS_MT_SLOT, 0);
+	send_abs_mt_xy(d, l, t);
+
+	if (d->ntouches_down == 2) {
+		litest_event(d, EV_ABS, ABS_MT_SLOT, 1);
+		send_abs_mt_xy(d, r, b);
+	}
+
+	litest_event(d, EV_SYN, SYN_REPORT, 0);
+
+	semi_mt->touches[slot].x = x;
+	semi_mt->touches[slot].y = y;
+}
+
+void
+litest_semi_mt_touch_up(struct litest_device *d,
+			struct litest_semi_mt *semi_mt,
+			unsigned int slot)
+{
+	/* note: ntouches_down is decreased before we get here */
+	if (d->ntouches_down >= 2 || slot > 1)
+		return;
+
+	litest_event(d, EV_ABS, ABS_MT_SLOT, d->ntouches_down);
+	litest_event(d, EV_ABS, ABS_MT_TRACKING_ID, -1);
+
+	/* if we have one finger left, send x/y coords for that finger left.
+	   this is likely to happen with a real touchpad */
+	if (d->ntouches_down == 1) {
+		int other = (slot + 1) % 2;
+		send_abs_xy(d, semi_mt->touches[other].x, semi_mt->touches[other].y);
+		litest_event(d, EV_ABS, ABS_MT_SLOT, 0);
+		send_abs_mt_xy(d, semi_mt->touches[other].x, semi_mt->touches[other].y);
+	}
+
+	litest_event(d, EV_SYN, SYN_REPORT, 0);
+}
+
+enum litest_mode {
+	LITEST_MODE_ERROR,
+	LITEST_MODE_TEST,
+	LITEST_MODE_LIST,
+};
+
+static inline enum litest_mode
+litest_parse_argv(int argc, char **argv)
+{
+	enum {
+		OPT_FILTER_TEST,
+		OPT_FILTER_DEVICE,
+		OPT_FILTER_GROUP,
+		OPT_JOBS,
+		OPT_LIST,
+		OPT_VERBOSE,
+	};
+	static const struct option opts[] = {
+		{ "filter-test", 1, 0, OPT_FILTER_TEST },
+		{ "filter-device", 1, 0, OPT_FILTER_DEVICE },
+		{ "filter-group", 1, 0, OPT_FILTER_GROUP },
+		{ "jobs", 1, 0, OPT_JOBS },
+		{ "list", 0, 0, OPT_LIST },
+		{ "verbose", 0, 0, OPT_VERBOSE },
+		{ 0, 0, 0, 0}
+	};
+
+	enum {
+		JOBS_DEFAULT,
+		JOBS_SINGLE,
+		JOBS_CUSTOM
+	} want_jobs = JOBS_DEFAULT;
+
+	if (in_debugger)
+		want_jobs = JOBS_SINGLE;
+
+	while(1) {
+		int c;
+		int option_index = 0;
+
+		c = getopt_long(argc, argv, "j:", opts, &option_index);
+		if (c == -1)
+			break;
+		switch(c) {
+		case OPT_FILTER_TEST:
+			filter_test = optarg;
+			if (want_jobs == JOBS_DEFAULT)
+				want_jobs = JOBS_SINGLE;
+			break;
+		case OPT_FILTER_DEVICE:
+			filter_device = optarg;
+			if (want_jobs == JOBS_DEFAULT)
+				want_jobs = JOBS_SINGLE;
+			break;
+		case OPT_FILTER_GROUP:
+			filter_group = optarg;
+			if (want_jobs == JOBS_DEFAULT)
+				want_jobs = JOBS_SINGLE;
+			break;
+		case 'j':
+		case OPT_JOBS:
+			jobs = atoi(optarg);
+			want_jobs = JOBS_CUSTOM;
+			break;
+		case OPT_LIST:
+			return LITEST_MODE_LIST;
+		case OPT_VERBOSE:
+			verbose = 1;
+			break;
+		default:
+			fprintf(stderr, "usage: %s [--list]\n", argv[0]);
+			return LITEST_MODE_ERROR;
+		}
+	}
+
+	if (want_jobs == JOBS_SINGLE)
+		jobs = 1;
+
+	return LITEST_MODE_TEST;
+}
+
+#ifndef LITEST_NO_MAIN
+static int
+is_debugger_attached(void)
+{
+	int status;
+	int rc;
+	int pid = fork();
+
+	if (pid == -1)
+		return 0;
+
+	if (pid == 0) {
+		int ppid = getppid();
+		if (ptrace(PTRACE_ATTACH, ppid, NULL, NULL) == 0) {
+			waitpid(ppid, NULL, 0);
+			ptrace(PTRACE_CONT, NULL, NULL);
+			ptrace(PTRACE_DETACH, ppid, NULL, NULL);
+			rc = 0;
+		} else {
+			rc = 1;
+		}
+		_exit(rc);
+	} else {
+		waitpid(pid, &status, 0);
+		rc = WEXITSTATUS(status);
+	}
+
+	return rc;
+}
+
+static void
+litest_list_tests(struct list *tests)
+{
+	struct suite *s;
+	const char *last_test_name = NULL;
+
+	list_for_each(s, tests, node) {
+		struct test *t;
+		printf("%s:\n", s->name);
+		list_for_each(t, &s->tests, node) {
+			if (!last_test_name ||
+			    !streq(last_test_name, t->name))
+				printf("	%s:\n", t->name);
+
+			last_test_name = t->name;
+
+			printf("		%s\n", t->devname);
+		}
+	}
+}
+
+extern const struct test_device __start_test_section, __stop_test_section;
+
+static void
+litest_init_test_devices(void)
+{
+	const struct test_device *t;
+	size_t ndevices = 0;
+
+	for (ndevices = 1,
+	     t = &__start_test_section;
+	     t < &__stop_test_section;
+	     ndevices++, t++)
+		; /* loopdeeloop */
+
+	ndevices++;
+	devices = zalloc(ndevices * sizeof(*devices));
+
+	for (ndevices = 0,
+	     t = &__start_test_section;
+	     t < &__stop_test_section;
+	     t++, ndevices++) {
+		devices[ndevices] = t->device;
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	const struct rlimit corelimit = { 0, 0 };
+	enum litest_mode mode;
+
+	if (getuid() != 0) {
+		fprintf(stderr,
+			"%s must be run as root.\n",
+			program_invocation_short_name);
+		return 77;
+	}
+
+	if (access("/dev/uinput", F_OK) == -1 &&
+	    access("/dev/input/uinput", F_OK) == -1) {
+		fprintf(stderr,
+			"uinput device is missing, skipping tests.\n");
+		return 77;
+	}
+
+	litest_init_test_devices();
+
+	list_init(&all_tests);
+
+	setenv("CK_DEFAULT_TIMEOUT", "30", 0);
+	setenv("LIBINPUT_RUNNING_TEST_SUITE", "1", 1);
+
+	in_debugger = is_debugger_attached();
+	if (in_debugger)
+		setenv("CK_FORK", "no", 0);
+
+	mode = litest_parse_argv(argc, argv);
+	if (mode == LITEST_MODE_ERROR)
+		return EXIT_FAILURE;
+
+	litest_setup_tests_udev();
+	litest_setup_tests_path();
+	litest_setup_tests_pointer();
+	litest_setup_tests_touch();
+	litest_setup_tests_log();
+	litest_setup_tests_tablet();
+	litest_setup_tests_pad();
+	litest_setup_tests_touchpad();
+	litest_setup_tests_touchpad_tap();
+	litest_setup_tests_touchpad_buttons();
+	litest_setup_tests_trackpoint();
+	litest_setup_tests_trackball();
+	litest_setup_tests_misc();
+	litest_setup_tests_keyboard();
+	litest_setup_tests_device();
+	litest_setup_tests_gestures();
+	litest_setup_tests_lid();
+
+	if (mode == LITEST_MODE_LIST) {
+		litest_list_tests(&all_tests);
+		return EXIT_SUCCESS;
+	}
+
+	if (setrlimit(RLIMIT_CORE, &corelimit) != 0)
+		perror("WARNING: Core dumps not disabled. Reason");
+
+	return litest_run(argc, argv);
+}
+#endif
--- libinput-1.10.7.orig/tools/libinput-debug-events.c
+++ libinput-1.10.7/tools/libinput-debug-events.c
@@ -119,6 +119,15 @@ print_event_header(struct libinput_event
 	case LIBINPUT_EVENT_GESTURE_PINCH_END:
 		type = "GESTURE_PINCH_END";
 		break;
+	case LIBINPUT_EVENT_GESTURE_TAP_BEGIN:
+      type = "GESTURE_TAP_BEGIN";
+      break;
+	case LIBINPUT_EVENT_GESTURE_TAP_UPDATE:
+      type = "GESTURE_TAP_UPDATE";
+      break;
+	case LIBINPUT_EVENT_GESTURE_TAP_END:
+      type = "GESTURE_TAP_END";
+      break;
 	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
 		type = "TABLET_TOOL_AXIS";
 		break;
@@ -625,7 +634,8 @@ print_gesture_event_without_coords(struc
 	type = libinput_event_get_type(ev);
 
 	if (type == LIBINPUT_EVENT_GESTURE_SWIPE_END ||
-	    type == LIBINPUT_EVENT_GESTURE_PINCH_END)
+	    type == LIBINPUT_EVENT_GESTURE_PINCH_END ||
+      type == LIBINPUT_EVENT_GESTURE_TAP_END)
 	    cancelled = libinput_event_gesture_get_cancelled(t);
 
 	print_event_time(libinput_event_gesture_get_time(t));
@@ -827,6 +837,15 @@ handle_and_print_events(struct libinput
 		case LIBINPUT_EVENT_GESTURE_PINCH_END:
 			print_gesture_event_without_coords(ev);
 			break;
+		case LIBINPUT_EVENT_GESTURE_TAP_BEGIN:
+        print_gesture_event_without_coords(ev);
+        break;
+		case LIBINPUT_EVENT_GESTURE_TAP_UPDATE:
+        print_gesture_event_with_coords(ev);
+        break;
+		case LIBINPUT_EVENT_GESTURE_TAP_END:
+        print_gesture_event_without_coords(ev);
+        break;
 		case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
 			print_tablet_axis_event(ev);
 			break;
--- /dev/null
+++ libinput-1.10.7/tools/libinput-debug-events.c.orig
@@ -0,0 +1,999 @@
+/*
+ * Copyright © 2014 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <inttypes.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <poll.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <libudev.h>
+#include "linux/input.h"
+#include <sys/ioctl.h>
+
+#include <libinput.h>
+#include <libevdev/libevdev.h>
+
+#include "shared.h"
+
+static uint32_t start_time;
+static const uint32_t screen_width = 100;
+static const uint32_t screen_height = 100;
+static struct tools_options options;
+static bool show_keycodes;
+static unsigned int stop = 0;
+static bool be_quiet = false;
+
+#define printq(...) ({ if (!be_quiet)  printf(__VA_ARGS__); })
+
+static void
+print_event_header(struct libinput_event *ev)
+{
+	/* use for pointer value only, do not dereference */
+	static void *last_device = NULL;
+	struct libinput_device *dev = libinput_event_get_device(ev);
+	const char *type = NULL;
+	char prefix;
+
+	switch(libinput_event_get_type(ev)) {
+	case LIBINPUT_EVENT_NONE:
+		abort();
+	case LIBINPUT_EVENT_DEVICE_ADDED:
+		type = "DEVICE_ADDED";
+		break;
+	case LIBINPUT_EVENT_DEVICE_REMOVED:
+		type = "DEVICE_REMOVED";
+		break;
+	case LIBINPUT_EVENT_KEYBOARD_KEY:
+		type = "KEYBOARD_KEY";
+		break;
+	case LIBINPUT_EVENT_POINTER_MOTION:
+		type = "POINTER_MOTION";
+		break;
+	case LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE:
+		type = "POINTER_MOTION_ABSOLUTE";
+		break;
+	case LIBINPUT_EVENT_POINTER_BUTTON:
+		type = "POINTER_BUTTON";
+		break;
+	case LIBINPUT_EVENT_POINTER_AXIS:
+		type = "POINTER_AXIS";
+		break;
+	case LIBINPUT_EVENT_TOUCH_DOWN:
+		type = "TOUCH_DOWN";
+		break;
+	case LIBINPUT_EVENT_TOUCH_MOTION:
+		type = "TOUCH_MOTION";
+		break;
+	case LIBINPUT_EVENT_TOUCH_UP:
+		type = "TOUCH_UP";
+		break;
+	case LIBINPUT_EVENT_TOUCH_CANCEL:
+		type = "TOUCH_CANCEL";
+		break;
+	case LIBINPUT_EVENT_TOUCH_FRAME:
+		type = "TOUCH_FRAME";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
+		type = "GESTURE_SWIPE_BEGIN";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE:
+		type = "GESTURE_SWIPE_UPDATE";
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_END:
+		type = "GESTURE_SWIPE_END";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_BEGIN:
+		type = "GESTURE_PINCH_BEGIN";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_UPDATE:
+		type = "GESTURE_PINCH_UPDATE";
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_END:
+		type = "GESTURE_PINCH_END";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+		type = "TABLET_TOOL_AXIS";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+		type = "TABLET_TOOL_PROXIMITY";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+		type = "TABLET_TOOL_TIP";
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+		type = "TABLET_TOOL_BUTTON";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+		type = "TABLET_PAD_BUTTON";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_RING:
+		type = "TABLET_PAD_RING";
+		break;
+	case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+		type = "TABLET_PAD_STRIP";
+		break;
+	case LIBINPUT_EVENT_SWITCH_TOGGLE:
+		type = "SWITCH_TOGGLE";
+		break;
+	}
+
+	prefix = (last_device != dev) ? '-' : ' ';
+
+	printq("%c%-7s  %-16s ",
+	       prefix,
+	       libinput_device_get_sysname(dev),
+	       type);
+
+	last_device = dev;
+}
+
+static void
+print_event_time(uint32_t time)
+{
+	printq("%+6.2fs	", (time - start_time) / 1000.0);
+}
+
+static inline void
+print_device_options(struct libinput_device *dev)
+{
+	uint32_t scroll_methods, click_methods;
+
+	if (libinput_device_config_tap_get_finger_count(dev)) {
+	    printq(" tap");
+	    if (libinput_device_config_tap_get_drag_lock_enabled(dev))
+		    printq("(dl on)");
+	    else
+		    printq("(dl off)");
+	}
+	if (libinput_device_config_left_handed_is_available(dev))
+	    printq(" left");
+	if (libinput_device_config_scroll_has_natural_scroll(dev))
+	    printq(" scroll-nat");
+	if (libinput_device_config_calibration_has_matrix(dev))
+	    printq(" calib");
+
+	scroll_methods = libinput_device_config_scroll_get_methods(dev);
+	if (scroll_methods != LIBINPUT_CONFIG_SCROLL_NO_SCROLL) {
+		printq(" scroll");
+		if (scroll_methods & LIBINPUT_CONFIG_SCROLL_2FG)
+			printq("-2fg");
+		if (scroll_methods & LIBINPUT_CONFIG_SCROLL_EDGE)
+			printq("-edge");
+		if (scroll_methods & LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN)
+			printq("-button");
+	}
+
+	click_methods = libinput_device_config_click_get_methods(dev);
+	if (click_methods != LIBINPUT_CONFIG_CLICK_METHOD_NONE) {
+		printq(" click");
+		if (click_methods & LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS)
+			printq("-buttonareas");
+		if (click_methods & LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER)
+			printq("-clickfinger");
+	}
+
+	if (libinput_device_config_dwt_is_available(dev)) {
+		if (libinput_device_config_dwt_get_enabled(dev) ==
+		    LIBINPUT_CONFIG_DWT_ENABLED)
+			printq(" dwt-on");
+		else
+			printq(" dwt-off)");
+	}
+
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_TABLET_PAD)) {
+		int nbuttons, nstrips, nrings, ngroups;
+
+		nbuttons = libinput_device_tablet_pad_get_num_buttons(dev);
+		nstrips = libinput_device_tablet_pad_get_num_strips(dev);
+		nrings = libinput_device_tablet_pad_get_num_rings(dev);
+		ngroups = libinput_device_tablet_pad_get_num_mode_groups(dev);
+
+		printq(" buttons:%d strips:%d rings:%d mode groups:%d",
+		       nbuttons,
+		       nstrips,
+		       nrings,
+		       ngroups);
+	}
+}
+
+static void
+print_device_notify(struct libinput_event *ev)
+{
+	struct libinput_device *dev = libinput_event_get_device(ev);
+	struct libinput_seat *seat = libinput_device_get_seat(dev);
+	struct libinput_device_group *group;
+	double w, h;
+	static int next_group_id = 0;
+	intptr_t group_id;
+
+	group = libinput_device_get_device_group(dev);
+	group_id = (intptr_t)libinput_device_group_get_user_data(group);
+	if (!group_id) {
+		group_id = ++next_group_id;
+		libinput_device_group_set_user_data(group, (void*)group_id);
+	}
+
+	printq("%-33s %5s %7s group%-2d",
+	       libinput_device_get_name(dev),
+	       libinput_seat_get_physical_name(seat),
+	       libinput_seat_get_logical_name(seat),
+	       (int)group_id);
+
+	printq(" cap:");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_KEYBOARD))
+		printq("k");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_POINTER))
+		printq("p");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_TOUCH))
+		printq("t");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_GESTURE))
+		printq("g");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_TABLET_TOOL))
+		printq("T");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_TABLET_PAD))
+		printq("P");
+	if (libinput_device_has_capability(dev,
+					   LIBINPUT_DEVICE_CAP_SWITCH))
+		printq("S");
+
+	if (libinput_device_get_size(dev, &w, &h) == 0)
+		printq("  size %.0fx%.0fmm", w, h);
+
+	if (libinput_event_get_type(ev) == LIBINPUT_EVENT_DEVICE_ADDED)
+		print_device_options(dev);
+
+	printq("\n");
+
+}
+
+static void
+print_key_event(struct libinput *li, struct libinput_event *ev)
+{
+	struct libinput_event_keyboard *k = libinput_event_get_keyboard_event(ev);
+	enum libinput_key_state state;
+	uint32_t key;
+	const char *keyname;
+
+	print_event_time(libinput_event_keyboard_get_time(k));
+	state = libinput_event_keyboard_get_key_state(k);
+
+	key = libinput_event_keyboard_get_key(k);
+	if (!show_keycodes && (key >= KEY_ESC && key < KEY_ZENKAKUHANKAKU)) {
+		keyname = "***";
+		key = -1;
+	} else {
+		keyname = libevdev_event_code_get_name(EV_KEY, key);
+		keyname = keyname ? keyname : "???";
+	}
+	printq("%s (%d) %s\n",
+	       keyname,
+	       key,
+	       state == LIBINPUT_KEY_STATE_PRESSED ? "pressed" : "released");
+}
+
+static void
+print_motion_event(struct libinput_event *ev)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double x = libinput_event_pointer_get_dx(p);
+	double y = libinput_event_pointer_get_dy(p);
+
+	print_event_time(libinput_event_pointer_get_time(p));
+
+	printq("%6.2f/%6.2f\n", x, y);
+}
+
+static void
+print_absmotion_event(struct libinput_event *ev)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double x = libinput_event_pointer_get_absolute_x_transformed(
+		p, screen_width);
+	double y = libinput_event_pointer_get_absolute_y_transformed(
+		p, screen_height);
+
+	print_event_time(libinput_event_pointer_get_time(p));
+	printq("%6.2f/%6.2f\n", x, y);
+}
+
+static void
+print_pointer_button_event(struct libinput_event *ev)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	enum libinput_button_state state;
+	const char *buttonname;
+	int button;
+
+	print_event_time(libinput_event_pointer_get_time(p));
+
+	button = libinput_event_pointer_get_button(p);
+	buttonname = libevdev_event_code_get_name(EV_KEY, button);
+
+	state = libinput_event_pointer_get_button_state(p);
+	printq("%s (%d) %s, seat count: %u\n",
+	       buttonname ? buttonname : "???",
+	       button,
+	       state == LIBINPUT_BUTTON_STATE_PRESSED ? "pressed" : "released",
+	       libinput_event_pointer_get_seat_button_count(p));
+}
+
+static void
+print_tablet_tip_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_tool *p = libinput_event_get_tablet_tool_event(ev);
+	enum libinput_tablet_tool_tip_state state;
+
+	print_event_time(libinput_event_tablet_tool_get_time(p));
+
+	state = libinput_event_tablet_tool_get_tip_state(p);
+	printq("%s\n", state == LIBINPUT_TABLET_TOOL_TIP_DOWN ? "down" : "up");
+}
+
+static void
+print_tablet_button_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_tool *p = libinput_event_get_tablet_tool_event(ev);
+	enum libinput_button_state state;
+	const char *buttonname;
+	int button;
+
+	print_event_time(libinput_event_tablet_tool_get_time(p));
+
+	button = libinput_event_tablet_tool_get_button(p);
+	buttonname = libevdev_event_code_get_name(EV_KEY, button);
+
+	state = libinput_event_tablet_tool_get_button_state(p);
+	printq("%3d (%s) %s, seat count: %u\n",
+	       button,
+	       buttonname ? buttonname : "???",
+	       state == LIBINPUT_BUTTON_STATE_PRESSED ? "pressed" : "released",
+	       libinput_event_tablet_tool_get_seat_button_count(p));
+}
+
+static void
+print_pointer_axis_event(struct libinput_event *ev)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double v = 0, h = 0;
+	const char *have_vert = "",
+		   *have_horiz = "";
+	const char *source = "invalid";
+
+	switch (libinput_event_pointer_get_axis_source(p)) {
+	case LIBINPUT_POINTER_AXIS_SOURCE_WHEEL:
+		source = "wheel";
+		break;
+	case LIBINPUT_POINTER_AXIS_SOURCE_FINGER:
+		source = "finger";
+		break;
+	case LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS:
+		source = "continuous";
+		break;
+	case LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT:
+		source = "tilt";
+		break;
+	}
+
+	if (libinput_event_pointer_has_axis(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL)) {
+		v = libinput_event_pointer_get_axis_value(p,
+			      LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL);
+		have_vert = "*";
+	}
+	if (libinput_event_pointer_has_axis(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL)) {
+		h = libinput_event_pointer_get_axis_value(p,
+			      LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL);
+		have_horiz = "*";
+	}
+	print_event_time(libinput_event_pointer_get_time(p));
+	printq("vert %.2f%s horiz %.2f%s (%s)\n",
+	       v, have_vert, h, have_horiz, source);
+}
+
+static void
+print_tablet_axes(struct libinput_event_tablet_tool *t)
+{
+	struct libinput_tablet_tool *tool = libinput_event_tablet_tool_get_tool(t);
+	double x, y;
+	double dist, pressure;
+	double rotation, slider, wheel;
+	double delta;
+
+#define changed_sym(ev, ax) \
+	(libinput_event_tablet_tool_##ax##_has_changed(ev) ? "*" : "")
+
+	x = libinput_event_tablet_tool_get_x(t);
+	y = libinput_event_tablet_tool_get_y(t);
+	printq("\t%.2f%s/%.2f%s",
+	       x, changed_sym(t, x),
+	       y, changed_sym(t, y));
+
+	if (libinput_tablet_tool_has_tilt(tool)) {
+		x = libinput_event_tablet_tool_get_tilt_x(t);
+		y = libinput_event_tablet_tool_get_tilt_y(t);
+		printq("\ttilt: %.2f%s/%.2f%s",
+		       x, changed_sym(t, tilt_x),
+		       y, changed_sym(t, tilt_y));
+	}
+
+	if (libinput_tablet_tool_has_distance(tool) ||
+	    libinput_tablet_tool_has_pressure(tool)) {
+		dist = libinput_event_tablet_tool_get_distance(t);
+		pressure = libinput_event_tablet_tool_get_pressure(t);
+		if (dist)
+			printq("\tdistance: %.2f%s",
+			       dist, changed_sym(t, distance));
+		else
+			printq("\tpressure: %.2f%s",
+			       pressure, changed_sym(t, pressure));
+	}
+
+	if (libinput_tablet_tool_has_rotation(tool)) {
+		rotation = libinput_event_tablet_tool_get_rotation(t);
+		printq("\trotation: %.2f%s",
+		       rotation, changed_sym(t, rotation));
+	}
+
+	if (libinput_tablet_tool_has_slider(tool)) {
+		slider = libinput_event_tablet_tool_get_slider_position(t);
+		printq("\tslider: %.2f%s",
+		       slider, changed_sym(t, slider));
+	}
+
+	if (libinput_tablet_tool_has_wheel(tool)) {
+		wheel = libinput_event_tablet_tool_get_wheel_delta(t);
+		delta = libinput_event_tablet_tool_get_wheel_delta_discrete(t);
+		printq("\twheel: %.2f%s (%d)",
+		       wheel, changed_sym(t, wheel),
+		       (int)delta);
+	}
+}
+
+static void
+print_tablet_axis_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
+
+	print_event_time(libinput_event_tablet_tool_get_time(t));
+	print_tablet_axes(t);
+	printq("\n");
+}
+
+static void
+print_touch_event_without_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touch_event(ev);
+
+	print_event_time(libinput_event_touch_get_time(t));
+	printq("\n");
+}
+
+static void
+print_proximity_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
+	struct libinput_tablet_tool *tool = libinput_event_tablet_tool_get_tool(t);
+	enum libinput_tablet_tool_proximity_state state;
+	const char *tool_str,
+	           *state_str;
+
+	switch (libinput_tablet_tool_get_type(tool)) {
+	case LIBINPUT_TABLET_TOOL_TYPE_PEN:
+		tool_str = "pen";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_ERASER:
+		tool_str = "eraser";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_BRUSH:
+		tool_str = "brush";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_PENCIL:
+		tool_str = "pencil";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH:
+		tool_str = "airbrush";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_MOUSE:
+		tool_str = "mouse";
+		break;
+	case LIBINPUT_TABLET_TOOL_TYPE_LENS:
+		tool_str = "lens";
+		break;
+	default:
+		abort();
+	}
+
+	state = libinput_event_tablet_tool_get_proximity_state(t);
+
+	print_event_time(libinput_event_tablet_tool_get_time(t));
+
+	if (state == LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN) {
+		print_tablet_axes(t);
+		state_str = "proximity-in";
+	} else if (state == LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT) {
+		print_tablet_axes(t);
+		state_str = "proximity-out";
+	} else {
+		abort();
+	}
+
+	printq("\t%s (%#" PRIx64 ", id %#" PRIx64 ") %s",
+	       tool_str,
+	       libinput_tablet_tool_get_serial(tool),
+	       libinput_tablet_tool_get_tool_id(tool),
+	       state_str);
+
+	if (state == LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN) {
+		printq("\taxes:");
+		if (libinput_tablet_tool_has_distance(tool))
+			printq("d");
+		if (libinput_tablet_tool_has_pressure(tool))
+			printq("p");
+		if (libinput_tablet_tool_has_tilt(tool))
+			printq("t");
+		if (libinput_tablet_tool_has_rotation(tool))
+			printq("r");
+		if (libinput_tablet_tool_has_slider(tool))
+			printq("s");
+		if (libinput_tablet_tool_has_wheel(tool))
+			printq("w");
+
+		printq("\tbtn:");
+		if (libinput_tablet_tool_has_button(tool, BTN_TOUCH))
+			printq("T");
+		if (libinput_tablet_tool_has_button(tool, BTN_STYLUS))
+			printq("S");
+		if (libinput_tablet_tool_has_button(tool, BTN_STYLUS2))
+			printq("S2");
+		if (libinput_tablet_tool_has_button(tool, BTN_LEFT))
+			printq("L");
+		if (libinput_tablet_tool_has_button(tool, BTN_MIDDLE))
+			printq("M");
+		if (libinput_tablet_tool_has_button(tool, BTN_RIGHT))
+			printq("R");
+		if (libinput_tablet_tool_has_button(tool, BTN_SIDE))
+			printq("Sd");
+		if (libinput_tablet_tool_has_button(tool, BTN_EXTRA))
+			printq("Ex");
+	}
+
+	printq("\n");
+}
+
+static void
+print_touch_event_with_coords(struct libinput_event *ev)
+{
+	struct libinput_event_touch *t = libinput_event_get_touch_event(ev);
+	double x = libinput_event_touch_get_x_transformed(t, screen_width);
+	double y = libinput_event_touch_get_y_transformed(t, screen_height);
+	double xmm = libinput_event_touch_get_x(t);
+	double ymm = libinput_event_touch_get_y(t);
+
+	print_event_time(libinput_event_touch_get_time(t));
+
+	printq("%d (%d) %5.2f/%5.2f (%5.2f/%5.2fmm)\n",
+	       libinput_event_touch_get_slot(t),
+	       libinput_event_touch_get_seat_slot(t),
+	       x, y,
+	       xmm, ymm);
+}
+
+static void
+print_gesture_event_without_coords(struct libinput_event *ev)
+{
+	struct libinput_event_gesture *t = libinput_event_get_gesture_event(ev);
+	int finger_count = libinput_event_gesture_get_finger_count(t);
+	int cancelled = 0;
+	enum libinput_event_type type;
+
+	type = libinput_event_get_type(ev);
+
+	if (type == LIBINPUT_EVENT_GESTURE_SWIPE_END ||
+	    type == LIBINPUT_EVENT_GESTURE_PINCH_END)
+	    cancelled = libinput_event_gesture_get_cancelled(t);
+
+	print_event_time(libinput_event_gesture_get_time(t));
+	printq("%d%s\n", finger_count, cancelled ? " cancelled" : "");
+}
+
+static void
+print_gesture_event_with_coords(struct libinput_event *ev)
+{
+	struct libinput_event_gesture *t = libinput_event_get_gesture_event(ev);
+	double dx = libinput_event_gesture_get_dx(t);
+	double dy = libinput_event_gesture_get_dy(t);
+	double dx_unaccel = libinput_event_gesture_get_dx_unaccelerated(t);
+	double dy_unaccel = libinput_event_gesture_get_dy_unaccelerated(t);
+
+	print_event_time(libinput_event_gesture_get_time(t));
+
+	printq("%d %5.2f/%5.2f (%5.2f/%5.2f unaccelerated)",
+	       libinput_event_gesture_get_finger_count(t),
+	       dx, dy, dx_unaccel, dy_unaccel);
+
+	if (libinput_event_get_type(ev) ==
+	    LIBINPUT_EVENT_GESTURE_PINCH_UPDATE) {
+		double scale = libinput_event_gesture_get_scale(t);
+		double angle = libinput_event_gesture_get_angle_delta(t);
+
+		printq(" %5.2f @ %5.2f\n", scale, angle);
+	} else {
+		printq("\n");
+	}
+}
+
+static void
+print_tablet_pad_button_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_pad *p = libinput_event_get_tablet_pad_event(ev);
+	struct libinput_tablet_pad_mode_group *group;
+	enum libinput_button_state state;
+	unsigned int button, mode;
+
+	print_event_time(libinput_event_tablet_pad_get_time(p));
+
+	button = libinput_event_tablet_pad_get_button_number(p),
+	state = libinput_event_tablet_pad_get_button_state(p);
+	mode = libinput_event_tablet_pad_get_mode(p);
+	printq("%3d %s (mode %d)",
+	       button,
+	       state == LIBINPUT_BUTTON_STATE_PRESSED ? "pressed" : "released",
+	       mode);
+
+	group = libinput_event_tablet_pad_get_mode_group(p);
+	if (libinput_tablet_pad_mode_group_button_is_toggle(group, button))
+		printq(" <mode toggle>");
+
+	printq("\n");
+}
+
+static void
+print_tablet_pad_ring_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_pad *p = libinput_event_get_tablet_pad_event(ev);
+	const char *source = "<invalid>";
+	unsigned int mode;
+
+	print_event_time(libinput_event_tablet_pad_get_time(p));
+
+	switch (libinput_event_tablet_pad_get_ring_source(p)) {
+	case LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER:
+		source = "finger";
+		break;
+	case LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN:
+		source = "unknown";
+		break;
+	}
+
+	mode = libinput_event_tablet_pad_get_mode(p);
+	printq("ring %d position %.2f (source %s) (mode %d)\n",
+	       libinput_event_tablet_pad_get_ring_number(p),
+	       libinput_event_tablet_pad_get_ring_position(p),
+	       source,
+	       mode);
+}
+
+static void
+print_tablet_pad_strip_event(struct libinput_event *ev)
+{
+	struct libinput_event_tablet_pad *p = libinput_event_get_tablet_pad_event(ev);
+	const char *source = "<invalid>";
+	unsigned int mode;
+
+	print_event_time(libinput_event_tablet_pad_get_time(p));
+
+	switch (libinput_event_tablet_pad_get_strip_source(p)) {
+	case LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER:
+		source = "finger";
+		break;
+	case LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN:
+		source = "unknown";
+		break;
+	}
+
+	mode = libinput_event_tablet_pad_get_mode(p);
+	printq("strip %d position %.2f (source %s) (mode %d)\n",
+	       libinput_event_tablet_pad_get_strip_number(p),
+	       libinput_event_tablet_pad_get_strip_position(p),
+	       source,
+	       mode);
+}
+
+static void
+print_switch_event(struct libinput_event *ev)
+{
+	struct libinput_event_switch *sw = libinput_event_get_switch_event(ev);
+	enum libinput_switch_state state;
+	const char *which;
+
+	print_event_time(libinput_event_switch_get_time(sw));
+
+	switch (libinput_event_switch_get_switch(sw)) {
+	case LIBINPUT_SWITCH_LID:
+		which = "lid";
+		break;
+	case LIBINPUT_SWITCH_TABLET_MODE:
+		which = "tablet-mode";
+		break;
+	default:
+		abort();
+	}
+
+	state = libinput_event_switch_get_switch_state(sw);
+
+	printq("switch %s state %d\n", which, state);
+}
+
+static int
+handle_and_print_events(struct libinput *li)
+{
+	int rc = -1;
+	struct libinput_event *ev;
+
+	libinput_dispatch(li);
+	while ((ev = libinput_get_event(li))) {
+		print_event_header(ev);
+
+		switch (libinput_event_get_type(ev)) {
+		case LIBINPUT_EVENT_NONE:
+			abort();
+		case LIBINPUT_EVENT_DEVICE_ADDED:
+		case LIBINPUT_EVENT_DEVICE_REMOVED:
+			print_device_notify(ev);
+			tools_device_apply_config(libinput_event_get_device(ev),
+						  &options);
+			break;
+		case LIBINPUT_EVENT_KEYBOARD_KEY:
+			print_key_event(li, ev);
+			break;
+		case LIBINPUT_EVENT_POINTER_MOTION:
+			print_motion_event(ev);
+			break;
+		case LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE:
+			print_absmotion_event(ev);
+			break;
+		case LIBINPUT_EVENT_POINTER_BUTTON:
+			print_pointer_button_event(ev);
+			break;
+		case LIBINPUT_EVENT_POINTER_AXIS:
+			print_pointer_axis_event(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCH_DOWN:
+			print_touch_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCH_MOTION:
+			print_touch_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCH_UP:
+			print_touch_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCH_CANCEL:
+			print_touch_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TOUCH_FRAME:
+			print_touch_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
+			print_gesture_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE:
+			print_gesture_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_SWIPE_END:
+			print_gesture_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_PINCH_BEGIN:
+			print_gesture_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_PINCH_UPDATE:
+			print_gesture_event_with_coords(ev);
+			break;
+		case LIBINPUT_EVENT_GESTURE_PINCH_END:
+			print_gesture_event_without_coords(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+			print_tablet_axis_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+			print_proximity_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+			print_tablet_tip_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+			print_tablet_button_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+			print_tablet_pad_button_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_PAD_RING:
+			print_tablet_pad_ring_event(ev);
+			break;
+		case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+			print_tablet_pad_strip_event(ev);
+			break;
+		case LIBINPUT_EVENT_SWITCH_TOGGLE:
+			print_switch_event(ev);
+			break;
+		}
+
+		libinput_event_destroy(ev);
+		libinput_dispatch(li);
+		rc = 0;
+	}
+	return rc;
+}
+
+static void
+sighandler(int signal, siginfo_t *siginfo, void *userdata)
+{
+	stop = 1;
+}
+
+static void
+mainloop(struct libinput *li)
+{
+	struct pollfd fds;
+	struct sigaction act;
+
+	fds.fd = libinput_get_fd(li);
+	fds.events = POLLIN;
+	fds.revents = 0;
+
+	memset(&act, 0, sizeof(act));
+	act.sa_sigaction = sighandler;
+	act.sa_flags = SA_SIGINFO;
+
+	if (sigaction(SIGINT, &act, NULL) == -1) {
+		fprintf(stderr, "Failed to set up signal handling (%s)\n",
+				strerror(errno));
+		return;
+	}
+
+	/* Handle already-pending device added events */
+	if (handle_and_print_events(li))
+		fprintf(stderr, "Expected device added events on startup but got none. "
+				"Maybe you don't have the right permissions?\n");
+
+	while (!stop && poll(&fds, 1, -1) > -1)
+		handle_and_print_events(li);
+
+	printf("\n");
+}
+
+static void
+usage(void) {
+	printf("Usage: libinput debug-events [options] [--udev <seat>|--device /dev/input/event0]\n");
+}
+
+int
+main(int argc, char **argv)
+{
+	struct libinput *li;
+	struct timespec tp;
+	enum tools_backend backend = BACKEND_UDEV;
+	const char *seat_or_device = "seat0";
+	bool grab = false;
+	bool verbose = false;
+
+	clock_gettime(CLOCK_MONOTONIC, &tp);
+	start_time = tp.tv_sec * 1000 + tp.tv_nsec / 1000000;
+
+	tools_init_options(&options);
+
+	while (1) {
+		int c;
+		int option_index = 0;
+		enum {
+			OPT_DEVICE = 1,
+			OPT_UDEV,
+			OPT_GRAB,
+			OPT_VERBOSE,
+			OPT_SHOW_KEYCODES,
+			OPT_QUIET,
+		};
+		static struct option opts[] = {
+			CONFIGURATION_OPTIONS,
+			{ "help",                      no_argument,       0, 'h' },
+			{ "show-keycodes",             no_argument,       0, OPT_SHOW_KEYCODES },
+			{ "device",                    required_argument, 0, OPT_DEVICE },
+			{ "udev",                      required_argument, 0, OPT_UDEV },
+			{ "grab",                      no_argument,       0, OPT_GRAB },
+			{ "verbose",                   no_argument,       0, OPT_VERBOSE },
+			{ "quiet",                     no_argument,       0, OPT_QUIET },
+			{ 0, 0, 0, 0}
+		};
+
+		c = getopt_long(argc, argv, "h", opts, &option_index);
+		if (c == -1)
+			break;
+
+		switch(c) {
+		case '?':
+			exit(1);
+			break;
+		case 'h':
+			usage();
+			exit(0);
+			break;
+		case OPT_SHOW_KEYCODES:
+			show_keycodes = true;
+			break;
+		case OPT_QUIET:
+			be_quiet = true;
+			break;
+		case OPT_DEVICE:
+			backend = BACKEND_DEVICE;
+			seat_or_device = optarg;
+			break;
+		case OPT_UDEV:
+			backend = BACKEND_UDEV;
+			seat_or_device = optarg;
+			break;
+		case OPT_GRAB:
+			grab = true;
+			break;
+		case OPT_VERBOSE:
+			verbose = true;
+			break;
+		default:
+			if (tools_parse_option(c, optarg, &options) != 0) {
+				usage();
+				return 1;
+			}
+			break;
+		}
+
+	}
+
+	if (optind < argc) {
+		usage();
+		return 1;
+	}
+
+	li = tools_open_backend(backend, seat_or_device, verbose, grab);
+	if (!li)
+		return 1;
+
+	mainloop(li);
+
+	libinput_unref(li);
+
+	return 0;
+}
--- libinput-1.10.7.orig/tools/libinput-debug-gui.c
+++ libinput-1.10.7/tools/libinput-debug-gui.c
@@ -90,6 +90,10 @@ struct window {
 		double x, y;
 	} pinch;
 
+  struct {
+      int nfingers;
+  } tap;
+
 	struct {
 		double x, y;
 		double x_in, y_in;
@@ -832,6 +836,11 @@ handle_event_libinput(GIOChannel *source
 		case LIBINPUT_EVENT_GESTURE_PINCH_END:
 			handle_event_pinch(ev, w);
 			break;
+		case LIBINPUT_EVENT_GESTURE_TAP_BEGIN:
+		case LIBINPUT_EVENT_GESTURE_TAP_UPDATE:
+		case LIBINPUT_EVENT_GESTURE_TAP_END:
+        // TODO: draw tap gesture
+        break;
 		case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
 		case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
 		case LIBINPUT_EVENT_TABLET_TOOL_TIP:
--- /dev/null
+++ libinput-1.10.7/tools/libinput-debug-gui.c.orig
@@ -0,0 +1,963 @@
+/*
+ * Copyright © 2014 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include <config.h>
+
+#include <linux/input.h>
+
+#include <cairo.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <gtk/gtk.h>
+#include <glib.h>
+
+#include <libinput.h>
+#include <libinput-util.h>
+
+#include "shared.h"
+
+#define clip(val_, min_, max_) min((max_), max((min_), (val_)))
+
+struct touch {
+	int active;
+	int x, y;
+};
+
+struct point {
+	double x, y;
+};
+
+struct window {
+	struct tools_options options;
+
+	GtkWidget *win;
+	GtkWidget *area;
+	int width, height; /* of window */
+
+	/* sprite position */
+	double x, y;
+
+	/* abs position */
+	int absx, absy;
+
+	/* scroll bar positions */
+	double vx, vy;
+	double hx, hy;
+
+	/* touch positions */
+	struct touch touches[32];
+
+	/* l/m/r mouse buttons */
+	int l, m, r;
+
+	/* touchpad swipe */
+	struct {
+		int nfingers;
+		double x, y;
+	} swipe;
+
+	struct {
+		int nfingers;
+		double scale;
+		double angle;
+		double x, y;
+	} pinch;
+
+	struct {
+		double x, y;
+		double x_in, y_in;
+		double x_down, y_down;
+		double x_up, y_up;
+		double pressure;
+		double distance;
+		double tilt_x, tilt_y;
+
+		/* these are for the delta coordinates, but they're not
+		 * deltas, they are converted into abs positions */
+		size_t ndeltas;
+		struct point deltas[64];
+	} tool;
+
+	struct libinput_device *devices[50];
+};
+
+LIBINPUT_ATTRIBUTE_PRINTF(1, 2)
+static inline void
+msg(const char *fmt, ...)
+{
+	va_list args;
+	printf("info: ");
+
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	va_end(args);
+}
+
+static inline void
+draw_gestures(struct window *w, cairo_t *cr)
+{
+	int i;
+	int offset;
+
+	/* swipe */
+	cairo_save(cr);
+	cairo_translate(cr, w->swipe.x, w->swipe.y);
+	for (i = 0; i < w->swipe.nfingers; i++) {
+		cairo_set_source_rgb(cr, .8, .8, .4);
+		cairo_arc(cr, (i - 2) * 40, 0, 20, 0, 2 * M_PI);
+		cairo_fill(cr);
+	}
+
+	for (i = 0; i < 4; i++) { /* 4 fg max */
+		cairo_set_source_rgb(cr, 0, 0, 0);
+		cairo_arc(cr, (i - 2) * 40, 0, 20, 0, 2 * M_PI);
+		cairo_stroke(cr);
+	}
+	cairo_restore(cr);
+
+	/* pinch */
+	cairo_save(cr);
+	offset = w->pinch.scale * 100;
+	cairo_translate(cr, w->pinch.x, w->pinch.y);
+	cairo_rotate(cr, w->pinch.angle * M_PI/180.0);
+	if (w->pinch.nfingers > 0) {
+		cairo_set_source_rgb(cr, .4, .4, .8);
+		cairo_arc(cr, offset, -offset, 20, 0, 2 * M_PI);
+		cairo_arc(cr, -offset, offset, 20, 0, 2 * M_PI);
+		cairo_fill(cr);
+	}
+
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_arc(cr, offset, -offset, 20, 0, 2 * M_PI);
+	cairo_stroke(cr);
+	cairo_arc(cr, -offset, offset, 20, 0, 2 * M_PI);
+	cairo_stroke(cr);
+
+	cairo_restore(cr);
+
+}
+
+static inline void
+draw_scrollbars(struct window *w, cairo_t *cr)
+{
+	cairo_set_source_rgb(cr, .4, .8, 0);
+
+	cairo_save(cr);
+	cairo_rectangle(cr, w->vx - 10, w->vy - 20, 20, 40);
+	cairo_rectangle(cr, w->hx - 20, w->hy - 10, 40, 20);
+	cairo_fill(cr);
+	cairo_restore(cr);
+}
+
+static inline void
+draw_touchpoints(struct window *w, cairo_t *cr)
+{
+	struct touch *t;
+
+	cairo_set_source_rgb(cr, .8, .2, .2);
+
+	ARRAY_FOR_EACH(w->touches, t) {
+		cairo_save(cr);
+		cairo_arc(cr, t->x, t->y, 10, 0, 2 * M_PI);
+		cairo_fill(cr);
+		cairo_restore(cr);
+	}
+}
+
+static inline void
+draw_abs_pointer(struct window *w, cairo_t *cr)
+{
+	cairo_set_source_rgb(cr, .2, .4, .8);
+
+	cairo_save(cr);
+	cairo_arc(cr, w->absx, w->absy, 10, 0, 2 * M_PI);
+	cairo_fill(cr);
+	cairo_restore(cr);
+}
+
+static inline void
+draw_buttons(struct window *w, cairo_t *cr)
+{
+	cairo_save(cr);
+	if (w->l || w->m || w->r) {
+		cairo_set_source_rgb(cr, .2, .8, .8);
+		if (w->l)
+			cairo_rectangle(cr, w->width/2 - 100, w->height - 200, 70, 30);
+		if (w->m)
+			cairo_rectangle(cr, w->width/2 - 20, w->height - 200, 40, 30);
+		if (w->r)
+			cairo_rectangle(cr, w->width/2 + 30, w->height - 200, 70, 30);
+		cairo_fill(cr);
+	}
+
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_rectangle(cr, w->width/2 - 100, w->height - 200, 70, 30);
+	cairo_rectangle(cr, w->width/2 - 20, w->height - 200, 40, 30);
+	cairo_rectangle(cr, w->width/2 + 30, w->height - 200, 70, 30);
+	cairo_stroke(cr);
+	cairo_restore(cr);
+}
+
+static inline void
+draw_tablet(struct window *w, cairo_t *cr)
+{
+	double x, y;
+	int first, last;
+	size_t mask;
+	int i;
+
+	/* tablet tool, square for prox-in location */
+	cairo_save(cr);
+	cairo_set_source_rgb(cr, .8, .8, .8);
+	if (w->tool.x_in && w->tool.y_in) {
+		cairo_rectangle(cr, w->tool.x_in - 15, w->tool.y_in - 15, 30, 30);
+		cairo_stroke(cr);
+		cairo_restore(cr);
+		cairo_save(cr);
+	}
+
+	if (w->tool.x_down && w->tool.y_down) {
+		cairo_rectangle(cr, w->tool.x_down - 10, w->tool.y_down - 10, 20, 20);
+		cairo_stroke(cr);
+		cairo_restore(cr);
+		cairo_save(cr);
+	}
+
+	if (w->tool.x_up && w->tool.y_up) {
+		cairo_rectangle(cr, w->tool.x_up - 10, w->tool.y_up - 10, 20, 20);
+		cairo_stroke(cr);
+		cairo_restore(cr);
+		cairo_save(cr);
+	}
+
+	if (w->tool.pressure)
+		cairo_set_source_rgb(cr, .8, .8, .2);
+
+	cairo_translate(cr, w->tool.x, w->tool.y);
+	cairo_scale(cr, 1.0 + w->tool.tilt_x/30.0, 1.0 + w->tool.tilt_y/30.0);
+	cairo_arc(cr, 0, 0,
+		  1 + 10 * max(w->tool.pressure, w->tool.distance),
+		  0, 2 * M_PI);
+	cairo_fill(cr);
+	cairo_restore(cr);
+
+	/* tablet deltas */
+	mask = ARRAY_LENGTH(w->tool.deltas);
+	first = max(w->tool.ndeltas + 1, mask) - mask;
+	last = w->tool.ndeltas;
+
+	cairo_save(cr);
+	cairo_set_source_rgb(cr, .8, .8, .2);
+
+	x = w->tool.deltas[first % mask].x;
+	y = w->tool.deltas[first % mask].y;
+	cairo_move_to(cr, x, y);
+
+	for (i = first + 1; i < last; i++) {
+		x = w->tool.deltas[i % mask].x;
+		y = w->tool.deltas[i % mask].y;
+		cairo_line_to(cr, x, y);
+	}
+
+	cairo_stroke(cr);
+
+}
+
+static inline void
+draw_pointer(struct window *w, cairo_t *cr)
+{
+	/* draw pointer sprite */
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_save(cr);
+	cairo_move_to(cr, w->x, w->y);
+	cairo_rel_line_to(cr, 10, 15);
+	cairo_rel_line_to(cr, -10, 0);
+	cairo_rel_line_to(cr, 0, -15);
+	cairo_fill(cr);
+	cairo_restore(cr);
+}
+
+static inline void
+draw_background(struct window *w, cairo_t *cr)
+{
+	int x1, x2, y1, y2, x3, y3, x4, y4;
+	int cols;
+
+	/* 10px and 5px grids */
+	cairo_save(cr);
+	cairo_set_source_rgb(cr, 0.8, 0.8, 0.8);
+	x1 = w->width/2 - 200;
+	y1 = w->height/2 - 200;
+	x2 = w->width/2 + 200;
+	y2 = w->height/2 - 200;
+	for (cols = 1; cols < 10; cols++) {
+		cairo_move_to(cr, x1 + 10 * cols, y1);
+		cairo_rel_line_to(cr, 0, 100);
+		cairo_move_to(cr, x1, y1 + 10 * cols);
+		cairo_rel_line_to(cr, 100, 0);
+
+		cairo_move_to(cr, x2 + 5 * cols, y2);
+		cairo_rel_line_to(cr, 0, 50);
+		cairo_move_to(cr, x2, y2 + 5 * cols);
+		cairo_rel_line_to(cr, 50, 0);
+	}
+
+	/* 3px horiz/vert bar codes */
+	x3 = w->width/2 - 200;
+	y3 = w->height/2 + 200;
+	x4 = w->width/2 + 200;
+	y4 = w->height/2 + 100;
+	for (cols = 0; cols < 50; cols++) {
+		cairo_move_to(cr, x3 + 3 * cols, y3);
+		cairo_rel_line_to(cr, 0, 20);
+
+		cairo_move_to(cr, x4, y4 + 3 * cols);
+		cairo_rel_line_to(cr, 20, 0);
+	}
+	cairo_stroke(cr);
+}
+
+static gboolean
+draw(GtkWidget *widget, cairo_t *cr, gpointer data)
+{
+	struct window *w = data;
+
+	cairo_set_source_rgb(cr, 1, 1, 1);
+	cairo_rectangle(cr, 0, 0, w->width, w->height);
+	cairo_fill(cr);
+
+	draw_background(w, cr);
+
+	draw_gestures(w, cr);
+	draw_scrollbars(w, cr);
+	draw_touchpoints(w, cr);
+	draw_abs_pointer(w, cr);
+	draw_buttons(w, cr);
+	draw_tablet(w, cr);
+	draw_pointer(w, cr);
+
+	return TRUE;
+}
+
+static void
+map_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
+{
+	struct window *w = data;
+	GdkDisplay *display;
+	GdkSeat *seat;
+	GdkWindow *window;
+
+	gtk_window_get_size(GTK_WINDOW(widget), &w->width, &w->height);
+
+	w->x = w->width/2;
+	w->y = w->height/2;
+
+	w->vx = w->width/2;
+	w->vy = w->height/2;
+	w->hx = w->width/2;
+	w->hy = w->height/2;
+
+	w->swipe.x = w->width/2;
+	w->swipe.y = w->height/2;
+
+	w->pinch.scale = 1.0;
+	w->pinch.x = w->width/2;
+	w->pinch.y = w->height/2;
+
+	g_signal_connect(G_OBJECT(w->area), "draw", G_CALLBACK(draw), w);
+
+	window = gdk_event_get_window(event);
+	display = gdk_window_get_display(window);
+
+	gdk_window_set_cursor(gtk_widget_get_window(w->win),
+			      gdk_cursor_new_for_display(display,
+							 GDK_BLANK_CURSOR));
+
+	seat = gdk_display_get_default_seat(display);
+	gdk_seat_grab(seat,
+		      window,
+		      GDK_SEAT_CAPABILITY_ALL_POINTING,
+		      FALSE, /* owner-events */
+		      NULL, /* cursor */
+		      NULL, /* triggering event */
+		      NULL, /* prepare_func */
+		      NULL /* prepare_func_data */
+		     );
+}
+
+static void
+window_init(struct window *w)
+{
+	memset(w, 0, sizeof(*w));
+
+	w->win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	gtk_widget_set_events(w->win, 0);
+	gtk_window_set_title(GTK_WINDOW(w->win), "libinput debugging tool");
+	gtk_window_set_default_size(GTK_WINDOW(w->win), 1024, 768);
+	gtk_window_maximize(GTK_WINDOW(w->win));
+	gtk_window_set_resizable(GTK_WINDOW(w->win), TRUE);
+	gtk_widget_realize(w->win);
+	g_signal_connect(G_OBJECT(w->win), "map-event", G_CALLBACK(map_event_cb), w);
+	g_signal_connect(G_OBJECT(w->win), "delete-event", G_CALLBACK(gtk_main_quit), NULL);
+
+	w->area = gtk_drawing_area_new();
+	gtk_widget_set_events(w->area, 0);
+	gtk_container_add(GTK_CONTAINER(w->win), w->area);
+	gtk_widget_show_all(w->win);
+}
+
+static void
+window_cleanup(struct window *w)
+{
+	struct libinput_device **dev;
+	ARRAY_FOR_EACH(w->devices, dev) {
+		if (*dev)
+			libinput_device_unref(*dev);
+	}
+}
+
+static void
+change_ptraccel(struct window *w, double amount)
+{
+	struct libinput_device **dev;
+
+	ARRAY_FOR_EACH(w->devices, dev) {
+		double speed;
+		enum libinput_config_status status;
+
+		if (*dev == NULL)
+			continue;
+
+		if (!libinput_device_config_accel_is_available(*dev))
+			continue;
+
+		speed = libinput_device_config_accel_get_speed(*dev);
+		speed = clip(speed + amount, -1, 1);
+
+		status = libinput_device_config_accel_set_speed(*dev, speed);
+
+		if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+			msg("%s: failed to change accel to %.2f (%s)\n",
+			    libinput_device_get_name(*dev),
+			    speed,
+			    libinput_config_status_to_str(status));
+		} else {
+			printf("%s: speed is %.2f\n",
+			       libinput_device_get_name(*dev),
+			       speed);
+		}
+
+	}
+}
+
+static void
+handle_event_device_notify(struct libinput_event *ev)
+{
+	struct libinput_device *dev = libinput_event_get_device(ev);
+	struct libinput *li;
+	struct window *w;
+	const char *type;
+	size_t i;
+
+	if (libinput_event_get_type(ev) == LIBINPUT_EVENT_DEVICE_ADDED)
+		type = "added";
+	else
+		type = "removed";
+
+	msg("%s %-30s %s\n",
+	    libinput_device_get_sysname(dev),
+	    libinput_device_get_name(dev),
+	    type);
+
+	li = libinput_event_get_context(ev);
+	w = libinput_get_user_data(li);
+
+	tools_device_apply_config(libinput_event_get_device(ev),
+				  &w->options);
+
+	if (libinput_event_get_type(ev) == LIBINPUT_EVENT_DEVICE_ADDED) {
+		for (i = 0; i < ARRAY_LENGTH(w->devices); i++) {
+			if (w->devices[i] == NULL) {
+				w->devices[i] = libinput_device_ref(dev);
+				break;
+			}
+		}
+	} else  {
+		for (i = 0; i < ARRAY_LENGTH(w->devices); i++) {
+			if (w->devices[i] == dev) {
+				libinput_device_unref(w->devices[i]);
+				w->devices[i] = NULL;
+				break;
+			}
+		}
+	}
+}
+
+static void
+handle_event_motion(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double dx = libinput_event_pointer_get_dx(p),
+	       dy = libinput_event_pointer_get_dy(p);
+
+	w->x += dx;
+	w->y += dy;
+	w->x = clip(w->x, 0.0, w->width);
+	w->y = clip(w->y, 0.0, w->height);
+}
+
+static void
+handle_event_absmotion(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double x = libinput_event_pointer_get_absolute_x_transformed(p, w->width),
+	       y = libinput_event_pointer_get_absolute_y_transformed(p, w->height);
+
+	w->absx = x;
+	w->absy = y;
+}
+
+static void
+handle_event_touch(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_touch *t = libinput_event_get_touch_event(ev);
+	int slot = libinput_event_touch_get_seat_slot(t);
+	struct touch *touch;
+	double x, y;
+
+	if (slot == -1 || slot >= (int) ARRAY_LENGTH(w->touches))
+		return;
+
+	touch = &w->touches[slot];
+
+	if (libinput_event_get_type(ev) == LIBINPUT_EVENT_TOUCH_UP) {
+		touch->active = 0;
+		return;
+	}
+
+	x = libinput_event_touch_get_x_transformed(t, w->width),
+	y = libinput_event_touch_get_y_transformed(t, w->height);
+
+	touch->active = 1;
+	touch->x = (int)x;
+	touch->y = (int)y;
+}
+
+static void
+handle_event_axis(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	double value;
+
+	if (libinput_event_pointer_has_axis(p,
+			LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL)) {
+		value = libinput_event_pointer_get_axis_value(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL);
+		w->vy += value;
+		w->vy = clip(w->vy, 0, w->height);
+	}
+
+	if (libinput_event_pointer_has_axis(p,
+			LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL)) {
+		value = libinput_event_pointer_get_axis_value(p,
+				LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL);
+		w->hx += value;
+		w->hx = clip(w->hx, 0, w->width);
+	}
+}
+
+static int
+handle_event_keyboard(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_keyboard *k = libinput_event_get_keyboard_event(ev);
+	unsigned int key = libinput_event_keyboard_get_key(k);
+
+	if (libinput_event_keyboard_get_key_state(k) ==
+	    LIBINPUT_KEY_STATE_RELEASED)
+		return 0;
+
+	switch(key) {
+	case KEY_ESC:
+		return 1;
+	case KEY_UP:
+		change_ptraccel(w, 0.1);
+		break;
+	case KEY_DOWN:
+		change_ptraccel(w, -0.1);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void
+handle_event_button(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_pointer *p = libinput_event_get_pointer_event(ev);
+	unsigned int button = libinput_event_pointer_get_button(p);
+	int is_press;
+
+	is_press = libinput_event_pointer_get_button_state(p) == LIBINPUT_BUTTON_STATE_PRESSED;
+
+	switch (button) {
+	case BTN_LEFT:
+		w->l = is_press;
+		break;
+	case BTN_RIGHT:
+		w->r = is_press;
+		break;
+	case BTN_MIDDLE:
+		w->m = is_press;
+		break;
+	}
+
+}
+
+static void
+handle_event_swipe(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_gesture *g = libinput_event_get_gesture_event(ev);
+	int nfingers;
+	double dx, dy;
+
+	nfingers = libinput_event_gesture_get_finger_count(g);
+
+	switch (libinput_event_get_type(ev)) {
+	case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
+		w->swipe.nfingers = nfingers;
+		w->swipe.x = w->width/2;
+		w->swipe.y = w->height/2;
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE:
+		dx = libinput_event_gesture_get_dx(g);
+		dy = libinput_event_gesture_get_dy(g);
+		w->swipe.x += dx;
+		w->swipe.y += dy;
+		break;
+	case LIBINPUT_EVENT_GESTURE_SWIPE_END:
+		w->swipe.nfingers = 0;
+		w->swipe.x = w->width/2;
+		w->swipe.y = w->height/2;
+		break;
+	default:
+		abort();
+	}
+}
+
+static void
+handle_event_pinch(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_gesture *g = libinput_event_get_gesture_event(ev);
+	int nfingers;
+	double dx, dy;
+
+	nfingers = libinput_event_gesture_get_finger_count(g);
+
+	switch (libinput_event_get_type(ev)) {
+	case LIBINPUT_EVENT_GESTURE_PINCH_BEGIN:
+		w->pinch.nfingers = nfingers;
+		w->pinch.x = w->width/2;
+		w->pinch.y = w->height/2;
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_UPDATE:
+		dx = libinput_event_gesture_get_dx(g);
+		dy = libinput_event_gesture_get_dy(g);
+		w->pinch.x += dx;
+		w->pinch.y += dy;
+		w->pinch.scale = libinput_event_gesture_get_scale(g);
+		w->pinch.angle += libinput_event_gesture_get_angle_delta(g);
+		break;
+	case LIBINPUT_EVENT_GESTURE_PINCH_END:
+		w->pinch.nfingers = 0;
+		w->pinch.x = w->width/2;
+		w->pinch.y = w->height/2;
+		w->pinch.angle = 0.0;
+		w->pinch.scale = 1.0;
+		break;
+	default:
+		abort();
+	}
+}
+
+static void
+handle_event_tablet(struct libinput_event *ev, struct window *w)
+{
+	struct libinput_event_tablet_tool *t = libinput_event_get_tablet_tool_event(ev);
+	double x, y;
+	struct point point;
+	int idx;
+	const int mask = ARRAY_LENGTH(w->tool.deltas);
+
+	x = libinput_event_tablet_tool_get_x_transformed(t, w->width);
+	y = libinput_event_tablet_tool_get_y_transformed(t, w->height);
+
+	switch (libinput_event_get_type(ev)) {
+	case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+		if (libinput_event_tablet_tool_get_proximity_state(t) ==
+		    LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT) {
+			w->tool.x_in = 0;
+			w->tool.y_in = 0;
+			w->tool.x_down = 0;
+			w->tool.y_down = 0;
+			w->tool.x_up = 0;
+			w->tool.y_up = 0;
+		} else {
+			w->tool.x_in = x;
+			w->tool.y_in = y;
+			w->tool.ndeltas = 0;
+			w->tool.deltas[0].x = w->width/2;
+			w->tool.deltas[0].y = w->height/2;
+		}
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+		w->tool.pressure = libinput_event_tablet_tool_get_pressure(t);
+		w->tool.distance = libinput_event_tablet_tool_get_distance(t);
+		w->tool.tilt_x = libinput_event_tablet_tool_get_tilt_x(t);
+		w->tool.tilt_y = libinput_event_tablet_tool_get_tilt_y(t);
+		if (libinput_event_tablet_tool_get_tip_state(t) ==
+		    LIBINPUT_TABLET_TOOL_TIP_DOWN) {
+			w->tool.x_down = x;
+			w->tool.y_down = y;
+		} else {
+			w->tool.x_up = x;
+			w->tool.y_up = y;
+		}
+		/* fallthrough */
+	case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+		w->tool.x = x;
+		w->tool.y = y;
+		w->tool.pressure = libinput_event_tablet_tool_get_pressure(t);
+		w->tool.distance = libinput_event_tablet_tool_get_distance(t);
+		w->tool.tilt_x = libinput_event_tablet_tool_get_tilt_x(t);
+		w->tool.tilt_y = libinput_event_tablet_tool_get_tilt_y(t);
+
+		/* Add the delta to the last position and store them as abs
+		 * coordinates */
+		idx = w->tool.ndeltas % mask;
+		point = w->tool.deltas[idx];
+
+		idx = (w->tool.ndeltas + 1) % mask;
+		point.x += libinput_event_tablet_tool_get_dx(t);
+		point.y += libinput_event_tablet_tool_get_dy(t);
+		w->tool.deltas[idx] = point;
+		w->tool.ndeltas++;
+		break;
+	case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+		break;
+	default:
+		abort();
+	}
+}
+
+static gboolean
+handle_event_libinput(GIOChannel *source, GIOCondition condition, gpointer data)
+{
+	struct libinput *li = data;
+	struct window *w = libinput_get_user_data(li);
+	struct libinput_event *ev;
+
+	libinput_dispatch(li);
+
+	while ((ev = libinput_get_event(li))) {
+		switch (libinput_event_get_type(ev)) {
+		case LIBINPUT_EVENT_NONE:
+			abort();
+		case LIBINPUT_EVENT_DEVICE_ADDED:
+		case LIBINPUT_EVENT_DEVICE_REMOVED:
+			handle_event_device_notify(ev);
+			break;
+		case LIBINPUT_EVENT_POINTER_MOTION:
+			handle_event_motion(ev, w);
+			break;
+		case LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE:
+			handle_event_absmotion(ev, w);
+			break;
+		case LIBINPUT_EVENT_TOUCH_DOWN:
+		case LIBINPUT_EVENT_TOUCH_MOTION:
+		case LIBINPUT_EVENT_TOUCH_UP:
+			handle_event_touch(ev, w);
+			break;
+		case LIBINPUT_EVENT_POINTER_AXIS:
+			handle_event_axis(ev, w);
+			break;
+		case LIBINPUT_EVENT_TOUCH_CANCEL:
+		case LIBINPUT_EVENT_TOUCH_FRAME:
+			break;
+		case LIBINPUT_EVENT_POINTER_BUTTON:
+			handle_event_button(ev, w);
+			break;
+		case LIBINPUT_EVENT_KEYBOARD_KEY:
+			if (handle_event_keyboard(ev, w)) {
+				libinput_event_destroy(ev);
+				gtk_main_quit();
+				return FALSE;
+			}
+			break;
+		case LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN:
+		case LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE:
+		case LIBINPUT_EVENT_GESTURE_SWIPE_END:
+			handle_event_swipe(ev, w);
+			break;
+		case LIBINPUT_EVENT_GESTURE_PINCH_BEGIN:
+		case LIBINPUT_EVENT_GESTURE_PINCH_UPDATE:
+		case LIBINPUT_EVENT_GESTURE_PINCH_END:
+			handle_event_pinch(ev, w);
+			break;
+		case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
+		case LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY:
+		case LIBINPUT_EVENT_TABLET_TOOL_TIP:
+		case LIBINPUT_EVENT_TABLET_TOOL_BUTTON:
+			handle_event_tablet(ev, w);
+			break;
+		case LIBINPUT_EVENT_TABLET_PAD_BUTTON:
+		case LIBINPUT_EVENT_TABLET_PAD_RING:
+		case LIBINPUT_EVENT_TABLET_PAD_STRIP:
+			break;
+		case LIBINPUT_EVENT_SWITCH_TOGGLE:
+			break;
+		}
+
+		libinput_event_destroy(ev);
+		libinput_dispatch(li);
+	}
+	gtk_widget_queue_draw(w->area);
+
+	return TRUE;
+}
+
+static void
+sockets_init(struct libinput *li)
+{
+	GIOChannel *c = g_io_channel_unix_new(libinput_get_fd(li));
+
+	g_io_channel_set_encoding(c, NULL, NULL);
+	g_io_add_watch(c, G_IO_IN, handle_event_libinput, li);
+}
+
+static void
+usage(void) {
+	printf("Usage: libinput debug-gui [options] [--udev <seat>|--device /dev/input/event0]\n");
+}
+
+int
+main(int argc, char **argv)
+{
+	struct window w;
+	struct tools_options options;
+	struct libinput *li;
+	enum tools_backend backend = BACKEND_UDEV;
+	const char *seat_or_device = "seat0";
+	bool grab = false;
+	bool verbose = false;
+
+	gtk_init(&argc, &argv);
+
+	tools_init_options(&options);
+
+	while (1) {
+		int c;
+		int option_index = 0;
+		enum {
+			OPT_DEVICE = 1,
+			OPT_UDEV,
+			OPT_GRAB,
+			OPT_VERBOSE,
+		};
+		static struct option opts[] = {
+			CONFIGURATION_OPTIONS,
+			{ "help",                      no_argument,       0, 'h' },
+			{ "device",                    required_argument, 0, OPT_DEVICE },
+			{ "udev",                      required_argument, 0, OPT_UDEV },
+			{ "grab",                      no_argument,       0, OPT_GRAB },
+			{ "verbose",                   no_argument,       0, OPT_VERBOSE },
+			{ 0, 0, 0, 0}
+		};
+
+		c = getopt_long(argc, argv, "h", opts, &option_index);
+		if (c == -1)
+			break;
+
+		switch(c) {
+		case '?':
+			exit(1);
+			break;
+		case 'h':
+			usage();
+			exit(0);
+			break;
+		case OPT_DEVICE:
+			backend = BACKEND_DEVICE;
+			seat_or_device = optarg;
+			break;
+		case OPT_UDEV:
+			backend = BACKEND_UDEV;
+			seat_or_device = optarg;
+			break;
+		case OPT_GRAB:
+			grab = true;
+			break;
+		case OPT_VERBOSE:
+			verbose = true;
+			break;
+		default:
+			if (tools_parse_option(c, optarg, &options) != 0) {
+				usage();
+				return 1;
+			}
+			break;
+		}
+
+	}
+
+	if (optind < argc) {
+		usage();
+		return 1;
+	}
+
+	li = tools_open_backend(backend, seat_or_device, verbose, grab);
+	if (!li)
+		return 1;
+
+	libinput_set_user_data(li, &w);
+
+	window_init(&w);
+	w.options = options;
+	sockets_init(li);
+	handle_event_libinput(NULL, 0, li);
+
+	gtk_main();
+
+	window_cleanup(&w);
+	libinput_unref(li);
+
+	return 0;
+}
